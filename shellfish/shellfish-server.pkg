{
  "version": 2,
  "resources": {
    "server/davsession.js": "\"use strict\";shRequire([\"shellfish/core\",__dirname+\"/httpsession.js\",\"shellfish/core/xmlsax\"],(core,httpSession,xmlsax)=>{function escapeXml(text){return text.replace(/[\\\"'&<>]/g,a=>{return{\"\\\"\":\"&quot;\",\"'\":\"&apos;\",\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\"}[a]})}function formatDate(d){function padded(v,n,c){let s=\"\"+v;while(s.length<n)s=c+s;return s}const tzOffset=d.getTimezoneOffset();const offsetHours=Math.abs(tzOffset)/60;const offsetMinutes=Math.abs(tzOffset)%60;return d.getFullYear()+\"-\"+padded(d.getMonth()+1,2,\"0\")+\"-\"+padded(d.getDate(),2,\"0\")+\"T\"+padded(d.getHours(),2,\"0\")+\":\"+padded(d.getMinutes(),2,\"0\")+\":\"+padded(d.getSeconds(),2,\"0\")+(tzOffset<0?\"+\":\"-\")+padded(offsetHours,2,\"0\")+\":\"+padded(offsetMinutes,2,\"0\")}function hasProperty(props,prop){return props.indexOf(\"DAV::allprop\")!=-1||props.indexOf(prop)!=-1}function makeResponseXml(href,fileInfo,requestedProperties){let xml=\"<D:response>\"+\"<D:href>\"+href+\"</D:href>\"+\"<D:propstat>\"+\"<D:prop>\";if(hasProperty(requestedProperties,\"DAV::displayname\")){xml+=\"<D:displayname>\"+escapeXml(fileInfo.name)+\"</D:displayname>\"}if(hasProperty(requestedProperties,\"DAV::creationdate\")){xml+=\"<D:creationdate>\"+formatDate(fileInfo.ctime)+\"</D:creationdate>\"}if(hasProperty(requestedProperties,\"DAV::getlastmodified\")){xml+=\"<D:getlastmodified>\"+formatDate(fileInfo.mtime)+\"</D:getlastmodified>\"}if(hasProperty(requestedProperties,\"DAV::getcontentlength\")){xml+=\"<D:getcontentlength>\"+fileInfo.size+\"</D:getcontentlength>\"}if(hasProperty(requestedProperties,\"DAV::getcontenttype\")){xml+=\"<D:getcontenttype>\"+(fileInfo.type===\"d\"?\"application/x-folder\":fileInfo.mimetype)+\"</D:getcontenttype>\"}if(hasProperty(requestedProperties,\"DAV::resourcetype\")){xml+=\"<D:resourcetype>\"+(fileInfo.type===\"d\"?\"<D:collection/>\":\"\")+\"</D:resourcetype>\"}xml+=\"</D:prop>\"+\"<D:status>HTTP/1.1 200 OK</D:status>\"+\"</D:propstat>\"+\"</D:response>\\n\";return xml}function rootPath(root,path){let rooted=root+\"/\"+path;return rooted.replace(/\\/\\/+/g,\"/\")}function unrootPath(root,path){if(path.startsWith(root)){path=path.substring(root.length);if(!path.startsWith(\"/\")){path=\"/\"+path}return path}else{return path}}function pathToHref(path){return path.split(\"/\").map(p=>encodeURIComponent(p)).join(\"/\")}function hrefToPath(href){if(href.startsWith(\"http://\")||href.startsWith(\"https://\")){const url=new URL(href);return decodeURIComponent(url.pathname)}else{return decodeURIComponent(href)}}function makeIndexDocument(root,path,files){let out=\"<!DOCTYPE html>\";out+=\"<html>\";out+=\"<head>\";out+=\"<meta charset=\\\"utf-8\\\">\";out+=\"<title>Contents of \"+escapeXml(path)+\"</title>\";out+=\"</head>\";out+=\"<body>\";out+=\"<h1>\"+escapeXml(unrootPath(root,path))+\"</h1>\";out+=\"<ul>\";files.forEach(f=>{const unrootedPath=unrootPath(root,f.path);out+=\"<li>\";out+=\"<a href='\"+escapeXml(pathToHref(unrootedPath))+\"'>\"+escapeXml(f.name)+\"</a>\";out+=\"<br>\"+f.mimetype+\", \"+f.size+\" bytes\";out+=\"</li>\"});out+=\"</ul>\";out+=\"</body>\";out+=\"</html>\";return out}const d=new WeakMap;class DAVSession extends httpSession.HTTPSession{constructor(){super();d.set(this,{filesystem:null,root:\"/\"});this.notifyable(\"filesystem\");this.notifyable(\"root\");this.onRequest=ev=>{this.davRequest(ev)}}get filesystem(){return d.get(this).filesystem}set filesystem(fs){d.get(this).filesystem=fs;this.filesystemChanged()}get root(){return d.get(this).root}set root(r){d.get(this).root=r;this.rootChanged()}davRequest(ev){if(!d.get(this).filesystem){return}switch(ev.method){case\"COPY\":this.davCopy(ev);break;case\"DELETE\":this.davDelete(ev);break;case\"GET\":this.davGet(ev);break;case\"HEAD\":this.davHead(ev);break;case\"MKCOL\":this.davMkcol(ev);break;case\"MOVE\":this.davMove(ev);break;case\"OPTIONS\":this.davOptions(ev);break;case\"PROPFIND\":this.davPropfind(ev);break;case\"PROPPATCH\":this.davProppatch(ev);break;case\"PUT\":this.davPut(ev);break;default:ev.response(500,\"Unsupported\").send();}}davCopy(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));const destination=rootPath(priv.root,hrefToPath(ev.headers.get(\"destination\")||\"\"));this.log(\"DAV\",\"info\",\"COPY \"+path+\" -> \"+destination);priv.filesystem.copy(path,destination).then(()=>{ev.response(201,\"Copied\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(401,\"Forbidden\").send()})}davDelete(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"DAV\",\"info\",\"DELETE \"+path);this.filesystem.remove(path).then(()=>{ev.response(204,\"No Content\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(403,\"Forbidden\").send()})}davGet(ev){const priv=d.get(this);const mayCompress=(ev.headers.get(\"accept-encoding\")||\"\").indexOf(\"gzip\")!==-1;const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"DAV\",\"info\",\"GET \"+path);const range=ev.range;this.filesystem.fileInfo(path).then(finfo=>{if(finfo.type===\"d\"){this.filesystem.list(path).then(files=>{ev.response(200,\"OK\",mayCompress).body(makeIndexDocument(priv.root,path,files),\"text/html\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(403,\"Forbidden\").send()});return}this.readFile(path,finfo,ev).then(fileData=>{if(range.length===0){ev.response(200,\"OK\",mayCompress).header(\"Accept-Ranges\",\"bytes\").header(\"Last-Modified\",new Date(finfo.mtime).toUTCString()).stream(fileData.stream(),fileData.mimetype,fileData.size).send()}else{const from=Math.min(range[0],fileData.size-1);const to=Math.min(range[1]!==-1?range[1]:fileData.size-1,fileData.size-1);this.log(\"DAV\",\"info\",\"Bytes Range: \"+from+\"-\"+to+\"/\"+fileData.size);ev.response(206,\"Partital Content\",mayCompress).header(\"Accept-Ranges\",\"bytes\").header(\"Content-Range\",\"bytes \"+from+\"-\"+to+\"/\"+fileData.size).header(\"Last-Modified\",new Date(finfo.mtime).toUTCString()).stream(fileData.slice(from,to).stream(),fileData.mimetype,to-from+1).send()}}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(500,\"Internal Server Error\").send()})}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(404,\"Resource Not Available\").send()})}davHead(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"DAV\",\"info\",\"HEAD \"+path);this.filesystem.fileInfo(path).then(finfo=>{ev.response(200,\"OK\").header(\"Content-Size\",\"\"+finfo.size).header(\"Content-Type\",finfo.mimetype).header(\"Last-Modified\",new Date(finfo.mtime).toUTCString()).send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(404,\"Resource Not Available\").send()})}davMkcol(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"DAV\",\"info\",\"MKCOL \"+path);priv.filesystem.mkdir(path).then(()=>{ev.response(201,\"Created\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(403,\"Forbidden\").send()})}davMove(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));const destination=rootPath(priv.root,hrefToPath(ev.headers.get(\"destination\")||\"\"));this.log(\"DAV\",\"info\",\"MOVE \"+path+\" -> \"+destination);priv.filesystem.move(path,destination).then(()=>{ev.response(201,\"Moved\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(409,\"Conflict\").send()})}davOptions(ev){this.log(\"DAV\",\"info\",\"OPTIONS\");ev.response(200,\"OK\").header(\"DAV\",\"1, 2\").send()}davPropfind(ev){const priv=d.get(this);const mayCompress=(ev.headers.get(\"accept-encoding\")||\"\").indexOf(\"gzip\")!==-1;ev.body().then(xml=>{const depth=ev.headers.get(\"depth\")||\"infinity\";const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"DAV\",\"info\",\"PROPFIND \"+path);if(xml===\"\"){xml=\"<D:propstat xmlns:D='DAV:'><D:allprop/></D:propstat>\"}const saxHandler=new xmlsax.Handler;const saxParser=new xmlsax.Parser(saxHandler);saxParser.parseString(xml);const doc=saxHandler.document();if(!doc){ev.response(500,\"Internal Error\").send();return}const props=[];doc.children.forEach(propNode=>{if(propNode.name===\"DAV::prop\"){propNode.children.filter(c=>c.type===\"tag\").forEach(c=>{props.push(c.name)})}else if(propNode.name===\"DAV::allprop\"){props.push(propNode.name)}});priv.filesystem.fileInfo(path).then(finfo=>{if(finfo.type===\"d\"&&depth!==0){priv.filesystem.list(path).then(files=>{let xml=\"<?xml version='1.0' encoding='utf-8'?>\"+\"<D:multistatus xmlns:D='DAV:'>\";files.forEach(cfinfo=>{const unrootedPath=unrootPath(priv.root,cfinfo.path);xml+=makeResponseXml(pathToHref(unrootedPath),cfinfo,props)});xml+=\"</D:multistatus>\";ev.response(207,\"Multi-Status\",mayCompress).body(xml,\"application/xml\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(500,\"Internal Error\").send()})}else{const unrootedPath=unrootPath(priv.root,finfo.path);const xml=\"<?xml version='1.0' encoding='utf-8'?>\"+\"<D:multistatus xmlns:D='DAV:'>\"+makeResponseXml(pathToHref(unrootedPath),finfo,props)+\"</D:multistatus>\";ev.response(207,\"Multi-Status\",mayCompress).body(xml,\"application/xml\").send()}}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(404,\"Resource Not Available\").send()})}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(500,\"Internal Error\").send()})}davProppatch(ev){const priv=d.get(this);this.log(\"DAV\",\"info\",\"PROPPATCH\");ev.body().then(xml=>{const saxHandler=new xmlsax.Handler;const saxParser=new xmlsax.Parser(saxHandler);saxParser.parseString(xml);const doc=saxHandler.document();if(!doc){ev.response(500,\"Internal Error\").send();return}let out=\"<?xml version='1.0' encoding='utf-8'?>\"+\"<D:multistatus xmlns:D='DAV:'>\";doc.children.forEach(updateNode=>{if(updateNode.name===\"DAV::set\"){const propsNode=updateNode.children[0];updateNode.children[0].children.forEach(propNode=>{const propName=propNode.name;const propValue=propNode.children[0].data;out+=\"<D:propstat>\"+\"<D:prop><\"+propName+\"/></D:prop>\"+\"<D:status>HTTP/1.1 424 Failed Dependency</D:status>\"+\"</D:propstat>\"})}else if(updateNode.name===\"DAV::remove\"){updateNode.children[0].children.forEach(propNode=>{const propName=propNode.name;out+=\"<D:propstat>\"+\"<D:prop><\"+propName+\"/></D:prop>\"+\"<D:status>HTTP/1.1 409 Conflict</D:status>\"+\"</D:propstat>\"})}});out+=\"</D:multistatus>\";ev.response(207,\"Multi-Status\").body(out,\"application/xml\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(500,\"Internal Error\").send()})}davPut(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"DAV\",\"info\",\"PUT \"+path);priv.filesystem.write(path,new core.FileData(ev.stream)).then(()=>{ev.response(200,\"OK\").send()}).catch(err=>{this.log(\"DAV\",\"error\",err);ev.response(409,\"Conflict\").send()})}readFile(path,finfo,ev){return this.filesystem.read(path)}}exports.DAVSession=DAVSession});",
    "server/httpauth.js": "\"use strict\";shRequire([\"shellfish/core\"],core=>{const modCrypto=require(\"crypto\");function md5(data){return modCrypto.createHash(\"md5\").update(data).digest(\"hex\")}function parseDigestParameters(s){const result={};const parts=s.split(\",\");parts.forEach(part=>{const pos=part.indexOf(\"=\");if(pos!==-1){const key=part.substr(0,pos).trim();let value=part.substr(pos+1).trim();if(value.startsWith(\"\\\"\")&&value.endsWith(\"\\\"\")){value=value.substr(1,value.length-2)}result[key]=value}});return result}function basicAuth(authHeader,realm,users){if(authHeader.indexOf(\"Basic \")!==0){return null}const parts=authHeader.split(\" \");const token=Buffer.from(parts[1],\"base64\").toString(\"utf8\");const tokenParts=token.split(\":\");if(tokenParts.length!==2){return null}const userName=tokenParts[0];const password=tokenParts[1];const passwordHash=md5(userName+\":\"+realm+\":\"+password);if(users[userName]!==undefined&&users[userName]===passwordHash){return userName}else{return null}}function digestAuth(authHeader,httpMethod,users){if(authHeader.indexOf(\"Digest \")!=0){return null}const params=parseDigestParameters(authHeader.replace(/^Digest /,\"\"));if(!users[params.username]){return null}const ha1=users[params.username];const ha2=md5(httpMethod+\":\"+params.uri);const expected=md5([ha1,params.nonce,params.nc,params.cnonce,params.qop,ha2].join(\":\"));if(params.response!==expected){return null}return params.username}const d=new WeakMap;class HTTPAuth extends core.Object{constructor(){super();d.set(this,{mode:\"basic\",realm:\"\",users:{}});this.notifyable(\"mode\");this.notifyable(\"realm\");this.notifyable(\"users\")}get mode(){return d.get(this).mode}set mode(m){d.get(this).mode=m;this.modeChanged()}get realm(){return d.get(this).realm}set realm(r){d.get(this).realm=r;this.realmChanged()}get users(){return d.get(this).users}set users(u){d.get(this).users=u;this.usersChanged()}passwordHash(user,realm,password){return md5(`${user}:${realm}:${password}`)}authorize(request){const priv=d.get(this);const authHeader=request.headers.get(\"authorization\");return new Promise((resolve,reject)=>{if(authHeader===undefined){resolve(null)}else if(priv.mode===\"basic\"){const user=basicAuth(authHeader,priv.realm,priv.users);resolve(user)}else if(priv.mode===\"digest\"){const user=digestAuth(authHeader,request.method,priv.users);resolve(user)}else{reject(`Invalid authentication mode: '${priv.mode}'`)}})}requestAuthorization(response){const priv=d.get(this);if(priv.mode===\"basic\"){response.writeHead(401,{\"WWW-Authenticate\":\"Basic realm=\\\"\"+priv.realm+\"\\\"\"})}else if(priv.mode===\"digest\"){const nonce=Math.random();const opaque=md5(priv.realm);response.writeHead(401,{\"WWW-Authenticate\":\"Digest realm=\\\"\"+priv.realm+\"\\\", \"+\"qop=\\\"auth\\\", \"+\"nonce=\\\"\"+nonce+\"\\\", \"+\"opaque=\\\"\"+opaque+\"\\\"\"})}response.write(\"Not Authorized\")}}exports.HTTPAuth=HTTPAuth});",
    "server/httproute.js": "\"use strict\";shRequire([\"shellfish/core\"],core=>{const d=new WeakMap;class HTTPRoute extends core.Object{constructor(){super();d.set(this,{authentication:null,delegate:null,connecting:false,sessions:new Map,when:request=>true,generateSessionId:request=>{return request.sourceAddress+\":\"+request.sourcePort}});this.notifyable(\"authentication\")}get authentication(){return d.get(this).authentication}set authentication(a){d.get(this).authentication=a;this.authenticationChanged()}get generateSessionId(){return d.get(this).generateSessionId}set generateSessionId(f){d.get(this).generateSessionId=f}get when(){return d.get(this).when}set when(w){d.get(this).when=w}get delegate(){return d.get(this).delegate}set delegate(del){d.get(this).delegate=del}pathPrefix(p){return req=>{return req.url.path.startsWith(p)}}getSession(id){const priv=d.get(this);if(priv.sessions.has(id)){return priv.sessions.get(id)}else{const session=priv.delegate();session.parent=this;session.sessionId=id;session.onDestruction=()=>{priv.sessions.delete(id)};priv.sessions.set(id,session);return session}}handleRequest(request,response){const priv=d.get(this);if(!priv.delegate){console.error(\"HTTP route at \"+this.objectLocation+\" has no delegate.\");return}let user=\"\";if(priv.authentication){priv.authentication.authorize(request).then(user=>{if(user===null){this.log(\"HTTP\",\"info\",\"Requesting Authorization for \"+request.sourceAddress+\":\"+request.sourcePort+\" - \"+request.method+\" \"+request.url.path);priv.authentication.requestAuthorization(response);this.wait(3000).then(()=>{response.end()})}else{request.user=user;const sessionId=priv.generateSessionId(request);const session=this.getSession(sessionId);session.user=user;session.handleRequest(request,response,user)}})}else{request.user=user;const sessionId=priv.generateSessionId(request);const session=this.getSession(sessionId);session.user=user;session.handleRequest(request,response,user)}}}exports.HTTPRoute=HTTPRoute});",
    "server/httpserver.js": "\"use strict\";shRequire([\"shellfish/core\"],core=>{const modFs=require(\"fs\");const modHttp=require(\"http\");const modHttps=require(\"https\");const modUrl=require(\"url\");function parseRange(range){let parts=range.split(\"=\");if(parts[0]===\"bytes\"){parts=parts[1].split(\"-\");return[parseInt(parts[0],10),parseInt(parts[1]||\"-1\",10)]}else{return[]}}function makeRequestEvent(request){const now=Date.now();const cookies=new Map;if(request.headers.cookie){const cookieString=request.headers.cookie;cookieString.split(\";\").forEach(part=>{const cookie=part.split(\"=\");cookies.set(cookie[0].replace(/^ /g,\"\"),decodeURIComponent(cookie[1]))})}const headers=new Map;for(const key in request.headers){headers.set(key.toLowerCase(),request.headers[key])}const urlObj=new modUrl.URL(\"\"+request.url,\"http://localhost\");const params={};for(const entry of urlObj.searchParams.entries()){params[entry[0]]=entry[1]}return{accepted:false,original:request,sourceAddress:request.connection.remoteAddress,sourcePort:request.connection.remotePort,cookies:cookies,headers:headers,method:request.method,range:headers.has(\"range\")?parseRange(headers.get(\"range\")):[],url:{hash:urlObj.hash,host:urlObj.host,hostname:urlObj.hostname,href:urlObj.href,origin:urlObj.origin,parameters:params,password:urlObj.password,path:urlObj.pathname,port:urlObj.port,protocol:urlObj.protocol,search:urlObj.search,username:urlObj.username}}}const d=new WeakMap;class HTTPServer extends core.Object{constructor(){super();d.set(this,{enabled:true,host:\"0.0.0.0\",port:8000,secure:false,certificate:\"\",key:\"\",server:null,keepAlive:5000,connecting:false});this.notifyable(\"certificate\");this.notifyable(\"enabled\");this.notifyable(\"host\");this.notifyable(\"keepAlive\");this.notifyable(\"key\");this.notifyable(\"port\");this.notifyable(\"secure\");this.onInitialization=()=>{this.listen()}}get enabled(){return d.get(this).enabled}set enabled(e){if(e!==d.get(this).enabled){d.get(this).enabled=e;this.enabledChanged();this.listen()}}get certificate(){return d.get(this).certificate}set certificate(c){if(c!==d.get(this).certificate){d.get(this).certificate=c;this.certificateChanged();this.listen()}}get host(){return d.get(this).host}set host(h){if(h!==d.get(this).host){d.get(this).host=h;this.hostChanged();this.listen()}}get keepAlive(){return d.get(this).keepAlive}set keepAlive(k){const priv=d.get(this);priv.keepAlive=k;this.keepAliveChanged();if(priv.server){priv.server.keepAliveTimeout=k}}get key(){return d.get(this).key}set key(k){if(k!==d.get(this).key){d.get(this).key=k;this.keyChanged();this.listen()}}get port(){return d.get(this).port}set port(p){if(p!==d.get(this).port){d.get(this).port=p;this.portChanged();this.listen()}}get secure(){return d.get(this).secure}set secure(s){if(s!==d.get(this).secure){d.get(this).secure=s;this.secureChanged();this.listen()}}listen(){const priv=d.get(this);if(!priv.connecting&&this.lifeCycleStatus!==\"new\"){priv.connecting=true;this.defer(()=>{priv.connecting=false;this.doListen()},\"listen\")}}doListen(){const priv=d.get(this);if(priv.server){priv.server.close();this.log(\"HTTPServer\",\"info\",\"Closed Server\")}if(!priv.enabled){return}if(priv.secure){try{const sslServerKey=modFs.readFileSync(priv.key,\"utf8\");const sslServerCert=modFs.readFileSync(priv.certificate,\"utf8\");priv.server=modHttps.createServer({key:sslServerKey,cert:sslServerCert})}catch(err){this.log(\"HTTPServer\",\"fatal\",\"Invalid or missing server certificate or key: \"+err);return}}else{priv.server=modHttp.createServer()}priv.server.keepAliveTimeout=priv.keepAlive;priv.server.on(\"request\",(request,response)=>{const ev=makeRequestEvent(request);let handled=false;this.children.filter(c=>c.when!==undefined&&c.handleRequest!==undefined).filter(c=>c.when(ev)).forEach((route,idx)=>{if(idx===0){route.handleRequest(ev,response);handled=true}});if(!handled){this.log(\"HTTPServer\",\"warning\",\"No HTTP route available: \"+request.method+\" \"+request.url);response.writeHead(404,\"Not Found\");response.end()}});priv.server.listen(priv.port,priv.host);this.log(\"HTTPServer\",\"info\",\"Listen at \"+priv.host+\":\"+priv.port+(priv.secure?\" (SSL)\":\"\"))}}exports.HTTPServer=HTTPServer});",
    "server/httpsession.js": "\"use strict\";shRequire([\"shellfish/core\"],core=>{const modUrl=require(\"url\");const modZlib=require(\"zlib\");function readRequest(request,type){return new Promise((resolve,reject)=>{const chunks=[];request.on(\"data\",chunk=>{chunks.push(chunk)});request.on(\"end\",()=>{const data=Buffer.concat(chunks);if(type===\"buffer\"){resolve(data.buffer.slice(data.byteOffset,data.byteOffset+data.byteLength))}else{resolve(data.toString(\"binary\"))}})})}function makeRequestEvent(self,urlMapper,request,response,user){const now=Date.now();const makeResponse=(code,status,compress)=>{const r=new HTTPResponse(response,code,status,compress,self.safeCallback(res=>{self.log(\"HTTP\",\"info\",(user?user+\"@\":\"\")+d.get(self).sessionId+\" - \"+request.method+\" \"+request.unmappedUrl.path+\": \"+code+\" \"+status+\" \"+(Date.now()-now)+\"ms\");self.responseReady(res)}));return r};const urlObj=new modUrl.URL(urlMapper(\"\"+request.original.url),\"http://localhost\");const params={};for(const entry of urlObj.searchParams.entries()){params[entry[0]]=entry[1]}request.body=()=>{return readRequest(request.original)},request.arrayBuffer=()=>{return readRequest(request.original,\"buffer\")},request.stream=request.original,request.response=makeResponse,request.unmappedUrl=request.url;request.url={hash:urlObj.hash,host:urlObj.host,hostname:urlObj.hostname,href:urlObj.href,origin:urlObj.origin,parameters:params,password:urlObj.password,path:urlObj.pathname,port:urlObj.port,protocol:urlObj.protocol,search:urlObj.search,username:urlObj.username};return request}class HTTPResponse{constructor(response,code,status,compress,callback){this.code=code;this.status=status;this.response=response;this.cookies=new Map;this.headers=new Map;this.data=\"\";this.dataStream=null;this.dataSize=-1;this.compress=compress||false;this.callback=callback}send(){this.callback(this);if(this.compress){this.response.setHeader(\"Content-Encoding\",\"gzip\")}const cookies=[...this.cookies].map(item=>{return item[0]+\"=\"+encodeURIComponent(item[1])});cookies.forEach(cookie=>{this.response.setHeader(\"Set-Cookie\",cookie)});[...this.headers].forEach(item=>{this.response.setHeader(item[0],item[1])});if(this.data.length>0){if(this.compress){modZlib.gzip(this.data,(err,data)=>{this.response.setHeader(\"Content-Length\",\"\"+data.length);this.response.writeHead(this.code,this.status);this.response.write(data);this.response.end()})}else{this.response.setHeader(\"Content-Length\",\"\"+this.data.length);this.response.writeHead(this.code,this.status);this.response.write(this.data);this.response.end()}}else if(this.dataStream){this.dataStream.on(\"error\",err=>{console.error(\"broken pipe: \"+err);this.response.end()});this.response.on(\"close\",()=>{this.dataStream.destroy()});if(this.dataSize!==-1&&!this.compress){this.response.setHeader(\"Content-Length\",\"\"+this.dataSize)}else{this.response.setHeader(\"Transfer-Encoding\",\"chunked\")}this.response.writeHead(this.code,this.status);if(this.compress){this.dataStream.pipe(modZlib.createGzip()).pipe(this.response)}else{this.dataStream.pipe(this.response)}}else{this.response.writeHead(this.code,this.status);this.response.end()}}body(s,mimetype){this.header(\"Content-Type\",mimetype);this.data=s;return this}stream(s,mimetype,dataSize){this.header(\"Content-Type\",mimetype);this.dataStream=s;this.dataSize=dataSize;return this}header(name,value){if(!this.headers.get(name)){this.headers.set(name,[])}this.headers.get(name).push(value);return this}enableCrossOriginIsolation(){this.header(\"Access-Control-Allow-Origin\",\"*\");this.header(\"Cross-Origin-Opener-Policy\",\"same-origin\");this.header(\"Cross-Origin-Embedder-Policy\",\"require-corp\");return this}cookie(name,value){this.cookies.set(name,value);return this}}const d=new WeakMap;class HTTPSession extends core.Object{constructor(){super();d.set(this,{sessionId:\"\",request:null,response:null,user:null,timeout:60000,timeoutHandler:null,urlMapper:url=>url});this.notifyable(\"timeout\");this.notifyable(\"urlMapper\");this.notifyable(\"user\");this.registerEvent(\"request\");this.registerEvent(\"responseReady\")}get sessionId(){return d.get(this).sessionId}set sessionId(id){d.get(this).sessionId=id}get user(){return d.get(this).user}set user(u){d.get(this).user=u;this.userChanged()}get timeout(){return d.get(this).timeout}set timeout(t){d.get(this).timeout=t;this.timeoutChanged()}get urlMapper(){return d.get(this).urlMapper}set urlMapper(f){d.get(this).urlMapper=f;this.urlMapperChanged()}handleRequest(request,response,user){const priv=d.get(this);priv.request=request;priv.response=response;this.request(makeRequestEvent(this,priv.urlMapper,request,response,user));if(priv.timeoutHandler){clearTimeout(priv.timeoutHandler)}priv.timeoutHandler=setTimeout(()=>{this.log(\"HTTP\",\"debug\",\"Session timeout reached of \"+this.objectType+\" \"+priv.sessionId);this.close()},priv.timeout)}response(code,status){this.log(\"HTTP\",\"info\",(d.get(this).user?d.get(this).user+\"@\":\"\")+d.get(this).sessionId+\" - \"+d.get(this).request.method+\" \"+d.get(this).request.unmappedUrl.path+\": \"+code+\" \"+status);const r=new HTTPResponse(d.get(this).response,code,status,false,this.safeCallback(res=>{this.responseReady(res)}));return r}close(){this.log(\"HTTPSession\",\"info\",\"Session closed: \"+d.get(this).sessionId);this.parent=null}}exports.HTTPSession=HTTPSession});",
    "server/localfs.js": "\"use strict\";shRequire([\"shellfish/core\",\"shellfish/core/mime\"],function(core,mime){const modFs=require(\"fs\");const modOs=require(\"os\");const modPath=require(\"path\");const modStream=require(\"stream\");class File{constructor(finfo,buffer){this.path=finfo.path;this.buffer=buffer;this.from=0;this.to=-1;this.finfo=finfo}get size(){return this.finfo.size}get mimetype(){return this.finfo.mimetype}slice(from,to){const f=new File(this.finfo,this.buffer);f.from=from;f.to=to;return f}arrayBuffer(){return new Promise((resolve,reject)=>{if(this.buffer){if(this.to>this.from){return this.buffer.slice(this.from,this.to)}else{return this.buffer}}const chunks=[];const stream=modFs.createReadStream(this.path,{encoding:\"binary\"});stream.on(\"data\",chunk=>{chunks.push(Buffer.from(chunk,\"binary\"))});stream.on(\"end\",()=>{if(this.to>this.from){resolve(Buffer.concat(chunks).slice(this.from,this.to))}else{resolve(Buffer.concat(chunks))}});stream.on(\"error\",err=>{reject(err)})})}stream(){if(this.buffer){if(this.to>this.from){async function*generate(buffer){yield buffer}const s=modStream.Readable.from(generate(this.buffer.slice(this.from,this.to)));return s}else{async function*generate(buffer){yield buffer}const s=modStream.Readable.from(generate(this.buffer));return s}}else{if(this.to>this.from){return modFs.createReadStream(this.path,{start:this.from,end:this.to})}else{return modFs.createReadStream(this.path)}}}text(){return this.arrayBuffer()}}exports.File=File;function makeFileItem(path,filePath,name,stats){const item={path:filePath,dir:path,name:name,type:stats.isDirectory()?\"d\":\"f\",size:stats.size,mimetype:stats.isDirectory()?\"application/x-folder\":mime.mimeType(name),ctime:stats.ctime,mtime:stats.mtime};return item}function fsCopy(sourcePath,destPath){return new Promise(async(resolve,reject)=>{const stats=await fsStat(sourcePath);if(stats.isDirectory()){await fsMkdir(destPath);const files=await fsList(sourcePath);for(let i=0;i<files.length;++i){try{await fsCopy(modPath.join(sourcePath,files[i]),modPath.join(destPath,files[i]))}catch(err){}}resolve()}else{modFs.copyFile(sourcePath,destPath,err=>{if(err){reject(err)}else{resolve()}})}})}function fsExist(path){return new Promise((resolve,reject)=>{modFs.access(path,modFs.constants.F_OK,err=>{resolve(!err)})})}function fsList(path){return new Promise((resolve,reject)=>{modFs.readdir(path,(err,files)=>{if(err){reject(err)}else{resolve(files)}})})}function fsMkdir(path){return new Promise((resolve,reject)=>{modFs.mkdir(path,err=>{if(err){reject(err)}else{resolve()}})})}function fsRename(sourcePath,destPath){return new Promise((resolve,reject)=>{modFs.rename(sourcePath,destPath,err=>{if(err){console.error(err);reject(err)}else{resolve()}})})}function fsStat(path){return new Promise((resolve,reject)=>{modFs.stat(path,(err,stats)=>{if(err){reject(err)}else{resolve(stats)}})})}function fsRemove(path){path=modPath.normalize(path);return new Promise(async(resolve,reject)=>{const stats=await fsStat(path);if(stats.isDirectory()){const files=await fsList(path);for(let i=0;i<files.length;++i){await fsRemove(modPath.join(path,files[i]))}modFs.rmdir(path,err=>{if(err){reject(err)}else{resolve()}})}else{modFs.unlink(path,err=>{if(err){reject(err)}else{resolve()}})}})}function fsRead(path){return new Promise((resolve,reject)=>{modFs.readFile(path,(err,data)=>{if(err){reject(err)}else{resolve(data)}})})}const d=new WeakMap;class LocalFS extends core.Filesystem{constructor(){super();d.set(this,{})}get homeDirectory(){return this.normalizePath(modOs.homedir())}get tempDir(){return this.normalizePath(modOs.tmpdir())}normalizePath(path){if(modOs.platform()===\"win32\"){path=path.replace(/\\\\/g,\"/\")}return super.normalizePath(path)}exists(path){return fsExist(path)}list(path){const priv=d.get(this);const f=async()=>{const result=[];const files=await fsList(path);for(let i=0;i<files.length;++i){const filePath=this.pathJoin(path,files[i]);try{result.push(makeFileItem(path,filePath,files[i],await fsStat(filePath)))}catch(err){}}return result};return f()}mkdir(path,name){return fsMkdir(this.pathJoin(path,name))}move(sourcePath,destPath){return fsRename(modPath.normalize(sourcePath),modPath.normalize(destPath))}copy(sourcePath,destPath){return fsCopy(modPath.normalize(sourcePath),modPath.normalize(destPath))}remove(path){return fsRemove(path)}read(path){const f=async()=>{const finfo=await this.fileInfo(path);return new core.FileData(finfo)};return f()}write(path,fileData){return new Promise((resolve,reject)=>{modFs.open(path,\"w\",(err,fd)=>{if(err){reject(err);return}const writeStream=modFs.createWriteStream(\"\",{fd});writeStream.on(\"finish\",()=>{resolve()});const stream=fileData.stream();stream.on(\"data\",data=>{writeStream.write(data)});stream.on(\"end\",()=>{writeStream.end()})})})}}exports.LocalFS=LocalFS});",
    "server/rpcsession.js": "shRequire([\"shellfish/core\",__dirname+\"/httpsession.js\"],(core,httpsession)=>{const modStream=require(\"stream\");let idCounter=0;function processSendParameters(parameters){const binaries=[];const convertedParameters=parameters.map(p=>{if(typeof p===\"object\"&&(p.constructor.name===\"Uint8Array\"||p.constructor.name===\"Buffer\")){binaries.push(p);return{type:\"binary\",size:p.length}}else{return p}});return[convertedParameters,binaries]}function processReceiveParameters(self,clientId,parameters,binaryData){let binaryOffset=0;return parameters.map(p=>{if(!!p&&typeof p===\"object\"){if(p.type===\"callback\"){const callbackId=p.callbackId;return(...parameters)=>{const[convertedParameters,binaries]=processSendParameters(parameters);self.postMessage(clientId,{type:\"callback\",callbackId:callbackId,parameters:convertedParameters},binaries)}}else if(p.type===\"binary\"){const data=binaryData.slice(binaryOffset,binaryOffset+p.size);binaryOffset+=p.size;return data}else{return p}}else{return p}})}function handleResult(self,clientId,r,onResult,onError){if(typeof r===\"object\"&&r.constructor.name===\"Promise\"){r.then(v=>onResult(v)).catch(err=>onError(err))}else if(typeof r===\"object\"&&r.type===\"proxy\"){d.get(self).clients.get(clientId).proxies.push(r.instanceId);onResult(r)}else{onResult(r)}}function handleMessage(self,clientId,msg,binaryData){const priv=d.get(self);priv.clients.get(clientId).expires=Date.now()+60000;if(msg.type===\"heartbeat\"){}else if(msg.type===\"call\"){if(priv.methods.has(msg.name)){const parameters=processReceiveParameters(self,clientId,msg.parameters,binaryData);try{const result=priv.methods.get(msg.name)(...parameters);handleResult(self,clientId,result,r=>{const[convertedParameters,binaries]=processSendParameters([r]);self.postMessage(clientId,{type:\"result\",callId:msg.callId,value:convertedParameters[0]},binaries)},err=>{self.postMessage(clientId,{type:\"error\",callId:msg.callId,value:\"\"+err})})}catch(err){self.postMessage(clientId,{type:\"error\",callId:msg.callId,value:\"\"+err})}}else{const err=\"No such method to call: \"+msg.name;self.postMessage(clientId,{type:\"error\",callId:msg.callId,value:err})}}else if(msg.type===\"exit\"){self.removeClient(clientId)}}const d=new WeakMap;class RpcSession extends httpsession.HTTPSession{constructor(){super();d.set(this,{clients:new Map,methods:new Map});const priv=d.get(this);this.onRequest=req=>{if(req.method===\"GET\"){const clientId=core.generateUid();this.log(\"RPC\",\"info\",\"RPC client \"+clientId+\" connected from \"+req.sourceAddress);const reverseChannel=new modStream.PassThrough;reverseChannel.on(\"close\",()=>{this.log(\"RPC\",\"debug\",\"RPC reverse channel to client \"+clientId+\" closed\");priv.clients.delete(clientId)});reverseChannel.on(\"error\",err=>{this.log(\"RPC\",\"debug\",\"RPC reverse channel to client \"+clientId+\" closed on error: \"+err);priv.clients.delete(clientId)});priv.clients.set(clientId,{reverseChannel,proxies:[],expires:Date.now()+50000});req.response(200,\"OK\").header(\"Keep-Alive\",\"timeout=60\").stream(reverseChannel,\"application/x-shellfish-rpc\",-1).send();this.postMessage(clientId,{type:\"ready\",clientId:clientId,sessionId:this.sessionId});this.log(\"RPC\",\"debug\",\"Connected clients on \"+this.objectId+\": \"+priv.clients.size);if(priv.clients.size===1){this.heartbeat();this.closeExpired()}}else if(req.method===\"POST\"){req.arrayBuffer().then(data=>{let msg=null;let binaryData=null;try{const view32=new Uint32Array(data,0,2);const jsonSize=view32[0];const jsonData=data.slice(8,8+jsonSize);binaryData=data.slice(8+jsonSize);msg=JSON.parse(new TextDecoder().decode(jsonData))}catch(err){console.error(err);return}let logDetails=\"\";if(msg.type===\"call\"){logDetails=\", call ID: \"+msg.callId+\", name: \"+msg.name+\", \"+msg.parameters.length+\" parameters\"}this.log(\"RPC\",\"info\",\"RECEIVE message from client \"+msg.clientId+\", type: \"+msg.type+logDetails);if(!priv.clients.has(msg.clientId)){this.log(\"RPC\",\"error\",\"RPC client \"+msg.clientId+\" is not connected\");req.response(500,\"Not Connected\").send()}else{handleMessage(this,msg.clientId,msg,binaryData);req.response(200,\"OK\").send()}})}};this.onDestruction=()=>{const clientIds=[...priv.clients.keys()];clientIds.forEach(clientId=>{this.removeClient(clientId)})}}heartbeat(){const priv=d.get(this);if(priv.clients.size===0){return}const clientIds=[...priv.clients.keys()];clientIds.forEach(clientId=>{const client=priv.clients.get(clientId);if(client.expires<Date.now()+25000){this.postMessage(clientId,{type:\"heartbeat\"})}});this.wait(25000,\"heartbeat\").then(()=>{this.heartbeat()})}closeExpired(){const priv=d.get(this);if(priv.clients.size===0){return}const clientIds=[...priv.clients.keys()];clientIds.forEach(clientId=>{const client=priv.clients.get(clientId);if(client.expires<Date.now()){this.log(\"RPC\",\"info\",\"RPC client \"+clientId+\" expired\");this.removeClient(clientId)}});this.wait(60000,\"closeExpired\").then(()=>{this.closeExpired()})}removeClient(clientId){const priv=d.get(this);const client=priv.clients.get(clientId);client.reverseChannel.end();client.proxies.forEach(proxyId=>{const methods=[...priv.methods.keys()];methods.forEach(methodId=>{if(methodId.startsWith(proxyId+\".\")){priv.methods.delete(methodId)}})});priv.clients.delete(clientId);if(priv.clients.size===0){this.log(\"RPC\",\"debug\",\"All clients disconnected from \"+this.objectId);this.abortWait(\"heartbeat\");this.abortWait(\"closeExpired\")}else{this.log(\"RPC\",\"debug\",\"Connected clients on \"+this.objectId+\": \"+priv.clients.size)}}postMessage(clientId,message,binaries){const priv=d.get(this);const client=priv.clients.get(clientId);if(client){if(!binaries){binaries=[]}const enc=new TextEncoder;const data=enc.encode(JSON.stringify(message));let logDetails=\"\";if(message.type===\"result\"||message.type===\"error\"){logDetails=\", call ID: \"+message.callId}this.log(\"RPC\",\"info\",\"SEND message to client \"+clientId+\", type: \"+message.type+logDetails);const size=data.length;const buffer=new ArrayBuffer(size+8);const view32=new Uint32Array(buffer,0,2);view32[0]=size;view32[1]=binaries.map(b=>b.length).reduce((a,b)=>a+b,0);const view8=new Uint8Array(buffer);view8.set(data,8);client.reverseChannel.write(view8);if(binaries){binaries.forEach(b=>client.reverseChannel.write(b))}}else{this.log(\"RPC\",\"debug\",\"Client \"+clientId+\" is not available\")}}registerMethod(name,f){d.get(this).methods.set(name,f)}proxyObject(obj,exposedMethods){const proxyId=idCounter;++idCounter;const methods=[];function allKeys(obj){let keys=Object.getOwnPropertyNames(obj).filter(n=>n!==\"constructor\").filter(n=>typeof obj[n]===\"function\").filter(n=>exposedMethods?exposedMethods.indexOf(n)!==-1:true);const proto=Object.getPrototypeOf(obj);if(!proto.hasOwnProperty(\"hasOwnProperty\")){keys=keys.concat(allKeys(proto))}return keys}allKeys(obj).forEach(key=>{this.registerMethod(proxyId+\".\"+key,obj[key].bind(obj));methods.push(key)});return{type:\"proxy\",instanceId:proxyId,methods:methods}}}exports.RpcSession=RpcSession});",
    "server/tokenauth.js": "\"use strict\";shRequire([\"shellfish/core\"],core=>{const modUrl=require(\"url\");const d=new WeakMap;class TokenAuth extends core.Object{constructor(){super();d.set(this,{pending:new Map,tokens:new Map})}generateToken(){let token=\"\";do{token=Math.floor(Math.random()*16777216).toString(16)+\"-\"+Math.floor(Math.random()*16777216).toString(16)+\"-\"+Math.floor(Math.random()*16777216).toString(16)}while(d.get(this).tokens.has(token));return token}authorize(request){const priv=d.get(this);const authToken=request.cookies.get(\"AuthToken\");const sourceAddress=request.sourceAddress;return new Promise((resolve,reject)=>{const authData=priv.tokens.get(authToken);if(authData&&authData.sourceAddress===sourceAddress){this.log(\"TokenAuth\",\"info\",\"Authorized user \"+authData.user+\" with token \"+authToken);resolve(authData.user)}else{resolve(null)}})}requestAuthorization(response){response.writeHead(401,{\"Content-Type\":\"text/plain\"});response.write(\"Not Authorized\")}issueTokenFor(user,sourceAddress){const token=this.generateToken();d.get(this).tokens.set(token,{user,sourceAddress});return token}revokeToken(token){const priv=d.get(this);priv.tokens.delete(token)}awaitToken(code,user,sourceAddress){this.log(\"TokenAuth\",\"info\",\"Awaiting token for \"+user+\" from \"+sourceAddress+\" with code \"+code);const priv=d.get(this);return new Promise((resolve,reject)=>{if(priv.pending.has(code)){reject(\"Code Already in Use\");return}priv.pending.set(code,ok=>{if(ok){const token=this.issueTokenFor(user,sourceAddress);this.log(\"TokenAuth\",\"info\",\"Issued token \"+token+\" for code \"+code);priv.pending.delete(code);resolve(token)}else{priv.pending.delete(code);reject(\"Not Authorized\")}});setTimeout(()=>{if(priv.pending.has(code)){this.log(\"TokenAuth\",\"info\",\"Code \"+code+\" expired\");const f=priv.pending.get(code);f(false)}},60000)})}authorizeCode(code){const priv=d.get(this);if(priv.pending.has(code)){const f=priv.pending.get(code);f(true)}}}exports.TokenAuth=TokenAuth});",
    "server/websession.js": "\"use strict\";shRequire([__dirname+\"/httpsession.js\",__dirname+\"/localfs.js\"],(httpSession,localFs)=>{const modFs=require(\"fs\");function escapeXml(text){return text.replace(/[\\\"'&<>]/g,a=>{return{\"\\\"\":\"&quot;\",\"'\":\"&apos;\",\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\"}[a]})}function formatDate(d){function padded(v,n,c){let s=\"\"+v;while(s.length<n)s=c+s;return s}const tzOffset=d.getTimezoneOffset();const offsetHours=Math.abs(tzOffset)/60;const offsetMinutes=Math.abs(tzOffset)%60;return d.getFullYear()+\"-\"+padded(d.getMonth()+1,2,\"0\")+\"-\"+padded(d.getDate(),2,\"0\")+\"T\"+padded(d.getHours(),2,\"0\")+\":\"+padded(d.getMinutes(),2,\"0\")+\":\"+padded(d.getSeconds(),2,\"0\")+(tzOffset<0?\"+\":\"-\")+padded(offsetHours,2,\"0\")+\":\"+padded(offsetMinutes,2,\"0\")}function rootPath(root,path){let rooted=root+\"/\"+path;return rooted.replace(/\\/\\/+/g,\"/\")}function unrootPath(root,path){if(path.startsWith(root)){path=path.substring(root.length);if(!path.startsWith(\"/\")){path=\"/\"+path}return path}else{return path}}function pathToHref(path){return path.split(\"/\").map(p=>encodeURIComponent(p)).join(\"/\")}function hrefToPath(href){if(href.startsWith(\"http://\")||href.startsWith(\"https://\")){const url=new URL(href);return decodeURIComponent(url.pathname)}else{return decodeURIComponent(href.replace(/\\?.*$/,\"\"))}}function makeIndexDocument(unmappedUrl,root,path,files){let out=\"<!DOCTYPE html>\";out+=\"<html>\";out+=\"<head>\";out+=\"<meta charset=\\\"utf-8\\\">\";out+=\"<title>Contents of \"+escapeXml(unmappedUrl)+\"</title>\";out+=\"</head>\";out+=\"<body>\";out+=\"<h1>\"+escapeXml(unmappedUrl)+\"</h1>\";out+=\"<ul>\";files.forEach(f=>{const fileUrl=(unmappedUrl+\"/\"+f.name).replace(/\\/\\//g,\"/\");out+=\"<li>\";out+=\"<a href='\"+escapeXml(fileUrl)+\"'>\"+escapeXml(f.name)+\"</a>\";out+=\"<br>\"+f.mimetype+\", \"+f.size+\" bytes\";out+=\"</li>\"});out+=\"</ul>\";out+=\"</body>\";out+=\"</html>\";return out}const d=new WeakMap;class WebSession extends httpSession.HTTPSession{constructor(){super();d.set(this,{filesystem:null,indexFile:\"\",root:\"/\"});this.notifyable(\"filesystem\");this.notifyable(\"indexFile\");this.notifyable(\"root\");this.onRequest=ev=>{this.webRequest(ev)}}get filesystem(){return d.get(this).filesystem}set filesystem(fs){d.get(this).filesystem=fs;this.filesystemChanged()}get indexFile(){return d.get(this).indexFile}set indexFile(f){d.get(this).indexFile=f;this.indexFileChanged()}get root(){return d.get(this).root}set root(r){d.get(this).root=r;this.rootChanged()}webRequest(ev){switch(ev.method){case\"GET\":this.webGet(ev);break;case\"HEAD\":this.webHead(ev);break;default:ev.response(500,\"Unsupported\").send();}}webGet(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"WWW\",\"info\",\"GET \"+path);const range=ev.range;const mayCompress=(ev.headers.get(\"accept-encoding\")||\"\").indexOf(\"gzip\")!==-1;priv.filesystem.fileInfo(path).then(finfo=>{if(finfo.type===\"d\"){if(priv.indexFile!==\"\"){ev.response(302,\"Relocate\").header(\"Location\",ev.unmappedUrl.path+(ev.unmappedUrl.path.endsWith(\"/\")?\"\":\"/\")+priv.indexFile).send()}else{priv.filesystem.list(path).then(files=>{ev.response(200,\"OK\",mayCompress).body(makeIndexDocument(ev.unmappedUrl.path,priv.root,path,files),\"text/html\").send()}).catch(err=>{this.log(\"WWW\",\"error\",err);ev.response(500,\"Internal Server Error\").send()})}return}priv.filesystem.read(path).then(file=>{if(range.length===0){ev.response(200,\"OK\",mayCompress).header(\"Accept-Ranges\",\"bytes\").stream(file.stream(),finfo.mimetype,finfo.size).send()}else{const from=Math.min(range[0],finfo.size-1);const to=Math.min(range[1]!==-1?range[1]:finfo.size-1,finfo.size-1);this.log(\"WWW\",\"info\",\"Bytes Range: \"+from+\"-\"+to+\"/\"+finfo.size);ev.response(206,\"Partital Content\",mayCompress).header(\"Accept-Ranges\",\"bytes\").header(\"Content-Range\",\"bytes \"+from+\"-\"+to+\"/\"+finfo.size).header(\"Last-Modified\",new Date(finfo.mtime).toUTCString()).stream(file.slice(from,to).stream(),finfo.mimetype,to-from+1).send()}}).catch(err=>{this.log(\"WWW\",\"error\",err);ev.response(500,\"Internal Server Error\").send()})}).catch(err=>{this.log(\"WWW\",\"error\",err);ev.response(403,\"Forbidden\").send()})}webHead(ev){const priv=d.get(this);const path=rootPath(priv.root,hrefToPath(ev.url.path));this.log(\"WWW\",\"info\",\"HEAD \"+path);priv.filesystem.fileInfo(path).then(finfo=>{ev.response(200,\"OK\").header(\"Content-Size\",\"\"+finfo.size).header(\"Content-Type\",finfo.mimetype).header(\"Last-Modified\",new Date(finfo.mtime).toUTCString()).send()}).catch(err=>{this.log(\"WWW\",\"error\",err);ev.response(403,\"Forbidden\").send()})}}exports.WebSession=WebSession});",
    "server.js": "\"use strict\";exports.__id=\"shellfish/server\";const includes=[\"davsession\",\"httpauth\",\"httproute\",\"httpserver\",\"httpsession\",\"localfs\",\"rpcsession\",\"tokenauth\",\"websession\"];shRequire(includes.map(m=>__dirname+\"/server/\"+m+\".js\"),(...args)=>{args.forEach(a=>exports.include(a))});"
  },
  "aliases": {
    "shellfish/server": "server.js"
  },
  "formats": {
    "server/davsession.js": "utf-8",
    "server/httpauth.js": "utf-8",
    "server/httproute.js": "utf-8",
    "server/httpserver.js": "utf-8",
    "server/httpsession.js": "utf-8",
    "server/localfs.js": "utf-8",
    "server/rpcsession.js": "utf-8",
    "server/tokenauth.js": "utf-8",
    "server/websession.js": "utf-8",
    "server.js": "utf-8"
  }
}