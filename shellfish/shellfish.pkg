{
  "version": 2,
  "resources": {
    "core/action.js": "shRequire([__dirname+\"/object.js\"],obj=>{const d=new WeakMap;class Action extends obj.Object{constructor(){super();this._sh_action=true;d.set(this,{busy:false,enabled:true,finishHandlers:[],stopHandlers:[],status:\"idle\"});this.notifyable(\"busy\");this.notifyable(\"enabled\");this.notifyable(\"status\");this.registerEvent(\"begin\");this.registerEvent(\"finish\");this.onBegin=()=>{d.get(this).busy=true;this.busyChanged();d.get(this).status=\"running\";this.statusChanged()};this.onFinish=()=>{d.get(this).finishHandlers.forEach(f=>f());d.get(this).finishHandlers=[];d.get(this).stopHandlers.forEach(f=>f());d.get(this).stopHandlers=[];d.get(this).busy=false;this.busyChanged();d.get(this).status=\"idle\";this.statusChanged()}}get busy(){return d.get(this).busy}get status(){return d.get(this).status}get enabled(){return d.get(this).enabled}set enabled(e){d.get(this).enabled=e;this.enabledChanged()}start(){this.begin();return new Promise((resolve,reject)=>{d.get(this).finishHandlers.push(resolve)})}stop(){const priv=d.get(this);return new Promise((resolve,reject)=>{if(priv.status===\"running\"){priv.stopHandlers.push(resolve);priv.status=\"stopping\";this.statusChanged()}else if(priv.status===\"stopping\"){priv.stopHandlers.push(resolve)}else{resolve()}})}}exports.Action=Action});",
    "core/filefs.js": "shRequire([__dirname+\"/filesystem.js\",__dirname+\"/util/mime.js\"],(fs,mime)=>{const VERSION=1;const BLOCK_SIZE=4096;const d=new WeakMap;function newBlock(self){const priv=d.get(self);if(priv.freeBlocks.length>0){return priv.freeBlocks.pop()}else{const block=priv.maxFree;++priv.maxFree;if(priv.data.byteLength<block*BLOCK_SIZE+BLOCK_SIZE){const newSize=Math.min(priv.data.byteLength+BLOCK_SIZE*100,priv.data.byteLength*2);self.log(\"\",\"trace\",\"File FS resize data buffer to \"+2*newSize+\" for block \"+block);const newBuffer=new ArrayBuffer(newSize);new BigUint64Array(newBuffer).set(new BigUint64Array(priv.data));priv.data=newBuffer}return block}}function freeBlock(self,block){const priv=d.get(self);priv.freeBlocks.push(block)}function getBlock(self,block){const priv=d.get(self);const view=new Uint8Array(priv.data,block*BLOCK_SIZE,BLOCK_SIZE);return view}function readFile(self,block){const firstBlock=getBlock(self,block);let block32=new Uint32Array(firstBlock.buffer,firstBlock.byteOffset,firstBlock.byteLength/4);const size=block32.at(0);let nextBlock=block32.at(-1);let remaining=size;const buffer=new ArrayBuffer(size);const buffer8=new Uint8Array(buffer);let chunkSize=Math.min(remaining,BLOCK_SIZE-8);buffer8.set(firstBlock.subarray(4,4+chunkSize),0,chunkSize);remaining-=chunkSize;while(remaining>0&&nextBlock>0){const block8=getBlock(self,nextBlock);block32=new Uint32Array(block8.buffer,block8.byteOffset,block8.byteLength/4);nextBlock=block32.at(-1);chunkSize=Math.min(remaining,BLOCK_SIZE-4);buffer8.set(block8.subarray(0,chunkSize),size-remaining,chunkSize);remaining-=chunkSize}return buffer}function writeFile(self,data){const size=data.byteLength;let remaining=size;const firstBlockId=newBlock(self);let blockId=firstBlockId;const firstBlock=getBlock(self,blockId);let block32=new Uint32Array(firstBlock.buffer,firstBlock.byteOffset,firstBlock.byteLength/4);block32.set([size]);block32.set([0],block32.length-1);const data8=new Uint8Array(data);let chunkSize=Math.min(remaining,BLOCK_SIZE-8);firstBlock.set(data8.subarray(0,chunkSize),4);remaining-=chunkSize;while(remaining>0){const prevBlockId=blockId;blockId=newBlock(self);const prevBlock8=getBlock(self,prevBlockId);block32=new Uint32Array(prevBlock8.buffer,prevBlock8.byteOffset,prevBlock8.byteLength/4);block32.set([blockId],block32.length-1);const block8=getBlock(self,blockId);block32=new Uint32Array(block8.buffer,block8.byteOffset,block8.byteLength/4);block32.set([0],block32.length-1);chunkSize=Math.min(remaining,BLOCK_SIZE-4);block8.set(data8.subarray(size-remaining,size-remaining+chunkSize));remaining-=chunkSize}return firstBlockId}function eraseFile(self,blockId){const firstBlock=getBlock(self,blockId);let block32=new Uint32Array(firstBlock.buffer,firstBlock.byteOffset,firstBlock.byteLength/4);let nextBlockId=block32.at(-1);freeBlock(self,blockId);while(nextBlockId>0){blockId=nextBlockId;const block8=getBlock(self,blockId);block32=new Uint32Array(block8.buffer,block8.byteOffset,block8.byteLength/4);nextBlockId=block32.at(-1);freeBlock(self,blockId)}}function getIndexNode(self,path){const priv=d.get(self);const pathParts=path.split(\"/\").filter(p=>p!==\"\");let node=priv.index;pathParts.forEach(p=>{if(node===null||node.type!==\"d\"){node=null;return}node=node.children[p]||null});return node}function load(self){const priv=d.get(self);priv.status=\"loading\";self.statusChanged();return new Promise(async(resolve,reject)=>{if(!priv.filesystem||priv.path===\"\"){priv.index={name:\"/\",type:\"d\",children:{}};priv.data=new ArrayBuffer(BLOCK_SIZE),priv.freeBlocks=[];priv.maxFree=0;resolve();priv.status=\"success\";self.statusChanged();return}if(!(await priv.filesystem.exists(priv.path))){priv.index={name:\"/\",type:\"d\",children:{}};priv.data=new ArrayBuffer(BLOCK_SIZE),priv.freeBlocks=[];priv.maxFree=0;resolve();priv.status=\"success\";self.statusChanged();return}self.log(\"\",\"trace\",\"Opening File FS from \"+priv.path);const fileData=await priv.filesystem.read(priv.path);const buffer=await fileData.arrayBuffer();console.log(buffer);if(self.lifeCycleStatus===\"destroyed\"){resolve();return}const buffer32=new Uint32Array(buffer,0,16);const version=buffer32.at(0);if(version>VERSION){self.log(\"\",\"error\",\"Cannot handle File FS version \"+version);reject();priv.status=\"error\";self.statusChanged();return}const dataSize=buffer32.at(1);const jsonSize=buffer32.at(2);const data8=new Uint8Array(buffer,16,dataSize);const json8=new Uint8Array(buffer,16+dataSize,jsonSize);const dataBuffer=new ArrayBuffer(dataSize);new Uint8Array(dataBuffer).set(data8);const jsonBuffer=new ArrayBuffer(jsonSize);new Uint8Array(jsonBuffer).set(json8);const jsonBlob=new Blob([jsonBuffer]);const json=await jsonBlob.text();const obj=JSON.parse(json);if(self.lifeCycleStatus===\"destroyed\"){resolve();return}priv.data=dataBuffer;priv.index=obj.index;priv.freeBlocks=obj.freeBlocks;priv.maxFree=buffer32.at(3);resolve();priv.status=\"success\";self.statusChanged()})}class FileFS extends fs.Filesystem{constructor(){super();d.set(this,{filesystem:null,path:\"\",status:\"empty\",pending:false,dirty:false,index:{name:\"/\",type:\"d\",children:{}},data:new ArrayBuffer(BLOCK_SIZE),freeBlocks:[],maxFree:0});this.notifyable(\"filesystem\");this.notifyable(\"path\");this.notifyable(\"status\");this.onDestruction=()=>{this.sync()}}get filesystem(){return d.get(this).filesystem}set filesystem(fs){this.sync();d.get(this).filesystem=fs;load(this);this.filesystemChanged()}get path(){return d.get(this).path}set path(p){this.sync();d.get(this).path=p;load(this);this.pathChanged()}get status(){return d.get(this).status}sync(){const priv=d.get(this);const obj={};d.set(obj,{filesystem:priv.filesystem,path:priv.path,dirty:priv.dirty,index:JSON.parse(JSON.stringify(priv.index)),data:priv.data.slice(),freeBlocks:priv.freeBlocks.slice(),maxFree:priv.maxFree});priv.dirty=false;return new Promise(async(resolve,reject)=>{const ppriv=d.get(obj);if(!ppriv.filesystem||ppriv.path===\"\"||!ppriv.dirty){resolve();return}const json=JSON.stringify({index:ppriv.index,freeBlocks:ppriv.freeBlocks});const jsonBlob=new Blob([json]);const jsonBuffer=await jsonBlob.arrayBuffer();const outBuffer=new ArrayBuffer(4+4+4+4+ppriv.data.byteLength+jsonBuffer.byteLength);const out32=new Uint32Array(outBuffer,0,16);out32.set([VERSION,ppriv.data.byteLength,jsonBuffer.byteLength,ppriv.maxFree],0);const out8=new Uint8Array(outBuffer,16);out8.set(new Uint8Array(ppriv.data));out8.set(new Uint8Array(jsonBuffer),ppriv.data.byteLength);const fileData=new fs.FileData(outBuffer);console.log(\"SYNC \"+ppriv.path);console.log(fileData.sourceType);this.log(\"\",\"trace\",\"Synchronizing File FS with \"+ppriv.path);await ppriv.filesystem.write(ppriv.path,fileData);resolve()})}list(path){return new Promise((resolve,reject)=>{path=this.normalizePath(path);let node=getIndexNode(this,path);if(node&&node.type===\"d\"){const items=Object.keys(node.children).map(key=>{const child=node.children[key];return{name:child.name,path:this.pathJoin(path,child.name),dir:path,name:child.name,type:child.type,size:child.type===\"d\"?0:child.size,mimetype:child.type==\"d\"?\"application/x-folder\":mime.mimeType(child.name),ctime:0,mtime:0}});resolve(items)}else if(node&&node.type===\"f\"){resolve([{name:node.name,path:url,dir:this.dirname(path),name:node.name,type:node.type,size:node.size,mimetype:mime.mimeType(node.name),ctime:0,mtime:0}])}else{resolve([])}})}mkdir(path,name){const priv=d.get(this);return new Promise((resolve,reject)=>{path=this.normalizePath(path);const node=getIndexNode(this,path);if(!node||node.type!==\"d\"){reject();return}const newNode={type:\"d\",name:name,children:{}};node.children[name]=newNode;priv.dirty=true;resolve();this.fsChange(path)})}move(sourcePath,destPath){const priv=d.get(this);return new Promise((resolve,reject)=>{sourcePath=this.normalizePath(sourcePath);destPath=this.normalizePath(destPath);const parentSourcePath=this.dirname(sourcePath);const parentDestPath=this.dirname(destPath);const newName=this.filename(destPath);const node=getIndexNode(this,sourcePath);const parentSourceNode=getIndexNode(this,parentSourcePath);const parentDestNode=getIndexNode(this,parentDestPath);if(!node||!parentSourceNode||!parentDestNode||parentSourceNode.type!==\"d\"||parentDestNode.type!==\"d\"){reject();return}delete parentSourceNode.children[node.name];node.name=newName;parentDestNode.children[node.name]=node;priv.dirty=true;resolve();this.fsChange(sourcePath);this.fsChange(destPath);this.fsChange(this.dirname(sourcePath));this.fsChange(this.dirname(destPath))})}copy(sourcePath,destPath){const priv=d.get(this);return new Promise(async(resolve,reject)=>{sourcePath=this.normalizePath(sourcePath);destPath=this.normalizePath(destPath);const fileData=await this.read(sourcePath);await this.write(destPath,fileData);priv.dirty=true;resolve();this.fsChange(destPath);this.fsChange(this.dirname(destPath))})}remove(path){const priv=d.get(this);return new Promise(async(resolve,reject)=>{path=this.normalizePath(path);const node=getIndexNode(this,path);if(!node){resolve();return}const parentPath=this.dirname(path);const parentNode=getIndexNode(this,parentPath);if(!parentNode||parentNode.type!==\"d\"){reject();return}delete parentNode.children[node.name];if(node.type===\"f\"){eraseFile(this,node.block)}priv.dirty=true;resolve();this.fsChange(path);this.fsChange(this.dirname(path))})}read(path){return new Promise((resolve,reject)=>{path=this.normalizePath(path);const node=getIndexNode(this,path);if(!node||node.type!==\"f\"){reject();return}const buffer=readFile(this,node.block);const fileData=new fs.FileData(buffer);resolve(fileData)})}write(path,fileData){const priv=d.get(this);return new Promise(async(resolve,reject)=>{path=this.normalizePath(path);const prevNode=getIndexNode(this,path);if(prevNode&&prevNode.type===\"f\"){eraseFile(this,prevNode.block)}const parentPath=this.dirname(path);const name=this.filename(path);const node=getIndexNode(this,parentPath);if(!node||node.type!==\"d\"){reject();return}if(!fileData){reject();return}const buffer=await fileData.arrayBuffer();const block=writeFile(this,buffer);const fileNode={type:\"f\",name:name,size:buffer.byteLength,block:block};node.children[name]=fileNode;priv.dirty=true;resolve();this.fsChange(path);this.fsChange(parentPath)})}}exports.FileFS=FileFS});",
    "core/filestorage.js": "\"use strict\";shRequire([__dirname+\"/object.js\",__dirname+\"/filesystem.js\"],(obj,fs)=>{const d=new WeakMap;class FileStorage extends obj.Object{constructor(){super();d.set(this,{ready:false,filesystem:null,path:\"\",doc:{},properties:new Set});this.notifyable(\"filesystem\");this.notifyable(\"path\");this.notifyable(\"ready\")}get ready(){return d.get(this).ready}get filesystem(){return d.get(this).filesystem}set filesystem(fs){d.get(this).filesystem=fs;this.filesystemChanged();this.readDocument()}get path(){return d.get(this).path}set path(p){d.get(this).path=p;this.pathChanged();this.readDocument()}readDocument(){const priv=d.get(this);if(priv.filesystem!==null&&priv.path!==\"\"){priv.filesystem.read(priv.path).then(async blob=>{const data=await blob.text();priv.doc=JSON.parse(data);for(let key in priv.doc){if(priv.properties.has(key)){this[key]=priv.doc[key]}}priv.ready=true;this.readyChanged()}).catch(err=>{priv.ready=true;this.readyChanged()})}}saveDocument(){const priv=d.get(this);if(!priv.ready){return}if(priv.filesystem!==null&&priv.path!==\"\"){this.log(\"\",\"debug\",\"Saving File Storage: \"+priv.path);const fileData=new fs.FileData(JSON.stringify(priv.doc,null,2));priv.filesystem.write(priv.path,fileData).then(()=>{}).catch(err=>{console.error(this.objectType+\"@\"+this.objectLocation+\": Failed to save file '\"+priv.path+\"'\")})}}addProperty(key,getter,setter,innate){if(innate){super.addProperty(key,getter,setter);return}const priv=d.get(this);priv.properties.add(key);let isSet=false;const s=v=>{if(!isSet&&priv.doc[key]!==undefined){isSet=true;return setter(priv.doc[key])}else{priv.doc[key]=v;if(priv.ready){this.saveDocument()}isSet=true;return setter(v)}};super.addProperty(key,getter,s)}}exports.FileStorage=FileStorage});",
    "core/filesystem.js": "\"use strict\";shRequire([__dirname+\"/object.js\"],obj=>{const modFs=shRequire.environment===\"node\"?require(\"node:fs\"):null;const modStream=shRequire.environment===\"node\"?require(\"node:stream\"):null;class FileData{constructor(dataSource){this.sourceType=\"unknown\";this.from=0;this.to=-1;if(!dataSource){this.sourceType=\"string\";this.dataSource=\"\"}else if(dataSource.constructor.name===\"ArrayBuffer\"){this.sourceType=\"buffer\";this.dataSource=dataSource}else if(dataSource.constructor.name===\"Blob\"){this.sourceType=\"blob\";this.dataSource=dataSource}else if(dataSource.constructor.name===\"File\"){this.sourceType=\"blob\";this.dataSource=dataSource}else if(typeof dataSource===\"string\"){this.sourceType=\"buffer\";this.dataSource=new TextEncoder().encode(dataSource)}else if(typeof dataSource.read===\"function\"||dataSource.rawHeaders){this.sourceType=\"stream\";this.dataSource=dataSource}else if(dataSource.path){this.sourceType=\"finfo\";this.dataSource=dataSource}}get size(){if(this.sourceType===\"finfo\"||this.sourceType===\"blob\"){return this.dataSource.size}else if(this.sourceType===\"buffer\"||this.sourceType===\"string\"){if(this.dataSource.byteLength!==undefined){return this.dataSource.byteLength}else{return this.dataSource.length}}else{return 0}}get mimetype(){if(this.sourceType===\"finfo\"){return this.dataSource.mimetype}else if(this.sourceType===\"blob\"){return this.dataSource.type}else{return\"application/octet-stream\"}}slice(from,to){const f=new FileData(this.dataSource);f.from=from;f.to=to;return f}async arrayBuffer(){if(this.sourceType===\"blob\"){if(this.to>this.from){return(await this.dataSource.arrayBuffer()).slice(this.from,this.to)}else{return await this.dataSource.arrayBuffer()}}else if(this.sourceType===\"buffer\"){if(this.to>this.from){return this.dataSource.slice(this.from,this.to)}else{return this.dataSource}}else if(this.sourceType===\"finfo\"&&modFs){const streamReader=new Promise((resolve,reject)=>{const chunks=[];const stream=modFs.createReadStream(this.dataSource.path,{encoding:\"binary\"});stream.on(\"data\",chunk=>{chunks.push(Buffer.from(chunk,\"binary\"))});stream.on(\"end\",()=>{let buffer=null;if(this.to>this.from){buffer=Buffer.concat(chunks).slice(this.from,this.to)}else{buffer=Buffer.concat(chunks)}resolve(buffer.buffer.slice(buffer.byteOffset,buffer.byteOffset+buffer.byteLength))});stream.on(\"error\",err=>{reject(err)})});return await streamReader}else if(this.sourceType===\"stream\"&&modStream){const streamReader=new Promise((resolve,reject)=>{const chunks=[];const stream=this.dataSource;stream.on(\"data\",chunk=>{chunks.push(Buffer.from(chunk,\"binary\"))});stream.on(\"end\",()=>{if(this.to>this.from){resolve(Buffer.concat(chunks).slice(this.from,this.to))}else{resolve(Buffer.concat(chunks))}});stream.on(\"error\",err=>{reject(err)})});return await streamReader}else{console.error(\"Unsupported FileData source type: \"+this.sourceType);return null}}blob(){if(this.sourceType===\"blob\"){return this.dataSource}else if(this.sourceType===\"buffer\"){return new Blob([this.dataSource])}else{return null}}stream(){if(!modStream){return null}if(this.sourceType===\"stream\"){return this.dataSource}else if(this.sourceType===\"buffer\"){if(this.to>this.from){async function*generate(buffer){yield buffer}const s=modStream.Readable.from(generate(new Uint8Array(this.dataSource.slice(this.from,this.to))));return s}else{async function*generate(buffer){yield buffer}const s=modStream.Readable.from(generate(new Uint8Array(this.dataSource)));return s}}else if(this.sourceType===\"finfo\"){if(this.to>this.from){return modFs.createReadStream(this.dataSource.path,{start:this.from,end:this.to})}else{return modFs.createReadStream(this.dataSource.path)}}else{console.error(\"Unsupported FileData source type: \"+this.sourceType);return null}}async text(){return new TextDecoder().decode(await this.arrayBuffer())}}exports.FileData=FileData;class Filesystem extends obj.Object{constructor(){super();this.registerEvent(\"fsChange\")}normalizePath(path){return path.replace(/\\/\\/+/g,\"/\").replace(/\\/$/,\"\")||\"/\"}pathJoin(...args){return this.normalizePath(args.join(\"/\"))}dirname(path){const pos=path.lastIndexOf(\"/\");if(pos!==-1){return this.normalizePath(path.substring(0,pos))}else{return\"/\"}}filename(path){const pos=path.lastIndexOf(\"/\");if(pos!==-1){return path.substring(pos+1)}else{return path}}encodeName(name){return name}exists(path){const f=async()=>{const dir=this.dirname(path);const filename=this.filename(path);const files=await this.list(dir);return files.findIndex(item=>item.name===filename)!==-1};return f()}fileInfo(path){return new Promise(async(resolve,reject)=>{if(path===\"/\"){resolve({path:\"/\",dir:\"/\",name:\"\",type:\"d\",size:0,mimetype:\"application/x-folder\",ctime:0,mtime:0})}else{if(path.endsWith(\"/\")){path=path.substring(0,path.length-1)}try{const files=await this.list(this.dirname(path));const info=files.find(f=>f.path===path);if(info){resolve(info)}else{reject(\"'\"+path+\"' not found\")}}catch(err){reject(err)}}})}list(path){throw\"Not implemented\"}search(path,query){return new Promise((resolve,reject)=>{resolve([])})}mkdir(path,name){throw\"Not implemented\"}mkdirs(path){const mkdirRecursive=async path=>{if(!(await this.exists(path))){const parentPath=this.dirname(path);const name=this.filename(path);if(!(await this.exists(parentPath))){await mkdirRecursive(parentPath)}await this.mkdir(parentPath,name)}};return mkdirRecursive(path)}move(sourcePath,destPath){throw\"Not implemented\"}copy(sourcePath,destPath){const f=async()=>{const fileData=await this.read(sourcePath);await this.write(destPath,fileData)};return f()}remove(path){throw\"Not implemented\"}read(path,progressCallback){throw\"Not implemented\"}write(path,fileData,progressCallback){throw\"Not implemented\"}}exports.Filesystem=Filesystem});",
    "core/fsmodel.js": "\"use strict\";shRequire([__dirname+\"/listmodel.js\"],function(lm){const pathMap=new Map;const newPathMap=new Map;let d=new WeakMap;class FSModel extends lm.ListModel{constructor(){super();d.set(this,{fs:null,path:\"\",query:\"\",filter:item=>!item.name.startsWith(\".\"),sorter:(a,b)=>a.name.toLowerCase()<b.name.toLowerCase()?-1:1,directoriesFirst:true,loading:false,items:[]});this.notifyable(\"directoriesFirst\");this.notifyable(\"filesystem\");this.notifyable(\"filter\");this.notifyable(\"loading\");this.notifyable(\"path\");this.notifyable(\"query\");this.notifyable(\"sorter\")}get filesystem(){return d.get(this).fs}set filesystem(f){if(d.get(this).fs){d.get(this).fs.referenceRemove(this)}d.get(this).fs=f;this.filesystemChanged();this.update(true);if(f){f.connect(\"fsChange\",this,changedPath=>{if(changedPath===d.get(this).path){this.update(false)}});f.referenceAdd(this)}}get path(){return d.get(this).path}set path(p){d.get(this).path=p;this.pathChanged();this.update(true)}get query(){return d.get(this).query}set query(q){d.get(this).query=q;this.queryChanged();this.update(true)}get loading(){return d.get(this).loading}get filter(){return d.get(this).filter}set filter(f){d.get(this).filter=f;this.processItems(d.get(this).items,true);this.filterChanged()}get directoriesFirst(){return d.get(this).directoriesFirst}set directoriesFirst(value){d.get(this).directoriesFirst=value;this.processItems(d.get(this).items,true);this.directoriesFirstChanged()}get sorter(){return d.get(this).sorter}set sorter(s){d.get(this).sorter=s;this.processItems(d.get(this).items,true);this.sorterChanged()}makeFilter(withDirectories,withFiles,withHidden){return item=>{if(item.type===\"d\"&&!withDirectories){return false}if(item.type===\"f\"&&!withFiles){return false}if(item.name.startsWith(\".\")&&!withHidden){return false}return true}}makeSorter(role,ascending){return(a,b)=>{const aValue=a[role];const bValue=b[role];const comp=(a,b)=>{return ascending?a<b?-1:1:a>b?-1:1};if(role===\"name\"){return comp(aValue.toLowerCase(),bValue.toLowerCase())}else{return comp(aValue,bValue)}}}comparator(a,b){if(d.get(this).directoriesFirst){if(a.type===\"d\"&&b.type!==\"d\"){return-1}else if(a.type!==\"d\"&&b.type===\"d\"){return 1}}return d.get(this).sorter(a,b)}mergeWithUpdate(newItems){newPathMap.clear();for(let i=0;i<newItems.length;++i){const item=newItems[i];newPathMap.set(item.path,i)}const removals=[];pathMap.clear();for(let i=0;i<this.size;++i){const item=this.at(i);pathMap.set(item.path,i);if(!newPathMap.has(item.path)){removals.push(i)}}removals.reverse();removals.forEach(idx=>this.remove(idx));const insertions=newItems.filter(item=>!pathMap.has(item.path));insertions.forEach(item=>{this.insertOrdered(item,(a,b)=>this.comparator(a,b))})}update(reset){const priv=d.get(this);if(!priv.loading){priv.loading=true;this.loadingChanged()}this.defer(()=>{this.doUpdate(reset)},\"update\")}doUpdate(reset){const priv=d.get(this);if(!priv.fs){this.reset([]);return}const forPath=priv.path;if(priv.query!==\"\"){priv.fs.search(priv.path,priv.query).then(this.safeCallback(items=>{if(priv.path!==forPath){return}priv.items=items;this.processItems(items,reset);priv.loading=false;this.loadingChanged()}))}else{priv.fs.list(priv.path).then(this.safeCallback(items=>{if(priv.path!==forPath){return}priv.items=items;this.processItems(items,reset);priv.loading=false;this.loadingChanged()}))}}processItems(items,reset){const priv=d.get(this);const newItems=items.filter(priv.filter).sort((a,b)=>this.comparator(a,b));if(reset){this.reset(newItems)}else{this.mergeWithUpdate(newItems)}}}exports.FSModel=FSModel});",
    "core/inertialengine.js": "shRequire([__dirname+\"/object.js\"],obj=>{const d=new WeakMap;class InertialEngine extends obj.Object{constructor(){super();d.set(this,{friction:0.08,velocityX:0,velocityY:0,velocityZ:0,sampleX:0,sampleY:0,sampleZ:0,sampleTime:0,running:false,abortFlag:false});this.notifyable(\"friction\");this.notifyable(\"running\");this.registerEvent(\"motion\")}get running(){return d.get(this).running}get friction(){return d.get(this).friction}set friction(f){d.get(this).friction=f;this.frictionChanged()}reset(x,y,z){const priv=d.get(this);priv.running=false;this.runningChanged();priv.abortFlag=true;priv.sampleTime=Date.now();priv.sampleX=x;priv.sampleY=y||0;priv.sampleZ=z||0;priv.velocityX=0;priv.velocityY=0;priv.velocityZ=0}takeSample(x,y,z){const priv=d.get(this);const dx=priv.sampleX-x;const dy=priv.sampleY-(y||0);const dz=priv.sampleZ-(z||0);const now=Date.now();const dt=now-priv.sampleTime;if(dt>0){priv.velocityX=dx/dt;priv.velocityY=dy/dt;priv.velocityZ=dz/dt}priv.sampleTime=now;priv.sampleX=x;priv.sampleY=y||0;priv.sampleZ=z||0;this.motion(dx,dy,dz)}async start(){const priv=d.get(this);priv.running=true;this.runningChanged();priv.abortFlag=false;await this.wait(10);while(this.lifeCycleStatus!==\"destroyed\"&&!priv.abortFlag){const now=Date.now();const dt=now-priv.sampleTime;priv.sampleTime=now;const dx=priv.velocityX*dt;const dy=priv.velocityY*dt;const dz=priv.velocityZ*dt;if(dt<100){this.motion(dx,dy,dz);priv.velocityX=priv.velocityX*(1-priv.friction);priv.velocityY=priv.velocityY*(1-priv.friction);priv.velocityZ=priv.velocityZ*(1-priv.friction)}if(dt>=100||Math.abs(dx)<0.1&&Math.abs(dy)<0.1&&Math.abs(dz)<0.1){priv.running=false;this.runningChanged();break}await this.wait(10)}priv.abortFlag=false}stop(){this.reset(d.get(this).sampleX,d.get(this).sampleY,d.get(this).sampleZ)}}exports.InertialEngine=InertialEngine});",
    "core/listmodel.js": "\"use strict\";shRequire([__dirname+\"/object.js\"],function(obj){const d=new WeakMap;class ListModel extends obj.Object{constructor(){super();d.set(this,{data:[]});this.notifyable(\"data\");this.notifyable(\"size\");this.registerEvent(\"modelReset\");this.registerEvent(\"modelInsert\");this.registerEvent(\"modelRemove\");this.registerEvent(\"modelReplace\")}get data(){return d.get(this).data.slice()}set data(dat){this.reset(dat);this.dataChanged()}get size(){return d.get(this).data.length}sequence(from,n){const arr=[];for(let i=from;i<from+n;++i){arr.push(i)}return arr}reset(data){d.get(this).data=data;this.sizeChanged();this.modelReset()}insert(at,data){const priv=d.get(this);if(at>=0&&at<=priv.data.length){priv.data.splice(at,0,data);this.modelInsert(at,1);this.sizeChanged()}}bulkInsert(at,bulk){const priv=d.get(this);if(at>=0&&at<=priv.data.length){const data=priv.data;priv.data=data.slice(0,at).concat(bulk).concat(priv.data.slice(at));this.modelInsert(at,bulk.length);this.sizeChanged()}}insertOrdered(data,comparator){const that=this;function doInsert(begin,end){if(end-begin<1){if(that.size===0){that.insert(0,data);return 0}const comparison=comparator(data,that.at(begin));if(comparison<0){that.insert(begin,data);return begin}else{that.insert(begin+1,data);return begin+1}}const center=begin+Math.floor((end-begin)/2);const comparison=comparator(data,that.at(center));if(comparison<0){return doInsert(begin,center-1)}else if(comparison>0){return doInsert(center+1,end)}else{that.insert(center,data);return center}}return doInsert(0,this.size-1)}remove(at){if(at>=0&&at<d.get(this).data.length){d.get(this).data.splice(at,1);this.sizeChanged();this.modelRemove(at)}}replace(at,item){const prevItem=d.get(this).data[at];if(at>=0&&at<d.get(this).data.length){d.get(this).data[at]=item;this.modelReplace(at)}return prevItem}at(n){return d.get(this).data[n]}}exports.ListModel=ListModel});",
    "core/object.js": "\"use strict\";shRequire([__dirname+\"/util/color.js\",__dirname+\"/util/vec.js\"],(colUtil,vec)=>{class ConnectionsHub{constructor(){this.keyCounter=0;this.emittersOfReceiver=new Map;this.receiversOfEmitter=new Map;this.handlersOfEmitter=new Map;this.handlersOfReceiver=new Map;this.eventOfHandler=new Map;this.handlers=new Map;this.afterTriggerHandlers=[];this.depth=0}runAfterTrigger(f){this.afterTriggerHandlers.push(f);if(this.handlers.size===0){this.trigger(null,\"\",[])}}connect(emitter,event,receiver,handler){const handlerKey=\"handler-\"+this.keyCounter;++this.keyCounter;this.handlers.set(handlerKey,handler);if(!this.emittersOfReceiver.has(receiver)){this.emittersOfReceiver.set(receiver,new Set)}this.emittersOfReceiver.get(receiver).add(emitter);if(!this.receiversOfEmitter.has(emitter)){this.receiversOfEmitter.set(emitter,new Set)}this.receiversOfEmitter.get(emitter).add(receiver);if(!this.handlersOfReceiver.has(receiver)){this.handlersOfReceiver.set(receiver,new Set)}this.handlersOfReceiver.get(receiver).add(handlerKey);if(!this.handlersOfEmitter.has(emitter)){this.handlersOfEmitter.set(emitter,new Set)}this.handlersOfEmitter.get(emitter).add(handlerKey);this.eventOfHandler.set(handlerKey,event)}disconnect(emitter,event,receiver){if(this.emittersOfReceiver.has(receiver)){for(let handlerKey of this.handlersOfReceiver.get(receiver).keys()){if(this.eventOfHandler.get(handlerKey)===event&&this.handlersOfEmitter.get(emitter)===handlerKey){this.handlers.delete(handlerKey);this.eventOfHandler.delete(handlerKey);this.handlersOfEmitter.get(emitter).delete(handlerKey);this.handlersOfReceiver.get(receiver).delete(handlerKey)}}}if(this.handlersOfReceiver.has(receiver)){let hasConnections=false;for(let handlerKey of this.handlersOfReceiver.get(receiver).keys()){if(this.handlersOfEmitter.get(emitter).has(handlerKey)){hasConnections=true;break}}if(!hasConnections){this.receiversOfEmitter.get(emitter).delete(receiver);this.emittersOfReceiver.get(receiver).delete(emitter)}}}removeEmitter(emitter){if(this.receiversOfEmitter.has(emitter)){for(let receiver of this.receiversOfEmitter.get(emitter).keys()){this.emittersOfReceiver.get(receiver).delete(emitter);for(let handlerKey of this.handlersOfEmitter.get(emitter).keys()){this.handlers.delete(handlerKey);this.eventOfHandler.delete(handlerKey);this.handlersOfReceiver.get(receiver).delete(handlerKey)}}}this.receiversOfEmitter.delete(emitter);this.handlersOfEmitter.delete(emitter)}removeReceiver(receiver){if(this.emittersOfReceiver.has(receiver)){for(let emitter of this.emittersOfReceiver.get(receiver).keys()){this.receiversOfEmitter.get(emitter).delete(receiver);for(let handlerKey of this.handlersOfReceiver.get(receiver).keys()){this.handlers.delete(handlerKey);this.eventOfHandler.delete(handlerKey);this.handlersOfEmitter.get(emitter).delete(handlerKey)}}}this.emittersOfReceiver.delete(receiver);this.handlersOfReceiver.delete(receiver)}trigger(emitter,event,args){if(this.handlersOfEmitter.has(emitter)){++this.depth;for(let handlerKey of this.handlersOfEmitter.get(emitter)){if(this.eventOfHandler.get(handlerKey)===event){try{this.handlers.get(handlerKey).apply(null,args||[])}catch(err){console.error(`[${exports.dbgctx}] Error triggering event '${emitter.constructor.name}.${event} (${emitter.objectLocation}): ${err}\\n${err.stack||\"<stacktrace not available>\"}`)}}}--this.depth}if(this.depth===0&&this.afterTriggerHandlers.length>0){++this.depth;let count=0;while(this.afterTriggerHandlers.length>0){const f=this.afterTriggerHandlers.shift();f();++count;if(count>10){setTimeout(()=>{this.trigger(null,\"\",[])},1);break}}--this.depth}}has(emitter,event){if(!this.handlersOfEmitter.has(emitter)){return false}for(let handlerKey of this.handlersOfEmitter.get(emitter)){if(this.eventOfHandler.get(handlerKey)===event){return true}}return false}events(emitter){if(this.handlersOfEmitter.has(emitter)){const events=[];for(let handlerKey of this.handlersOfEmitter.get(emitter)){let recv=null;for(let receiver of this.receiversOfEmitter.get(emitter)){for(let rh of this.handlersOfReceiver.get(receiver)){if(rh===handlerKey){recv=receiver}}}if(this.eventOfHandler.has(handlerKey)){events.push([this.eventOfHandler.get(handlerKey),recv])}}return events}else{return[]}}}const connHub=new ConnectionsHub;class SparseMatrix{constructor(zero){this.data=new Map;this.zero=zero;this.edgeLength=n=>n+1;this.c=n=>this.edgeLength(n)*this.edgeLength(n)-1;this.indexAt=(y,x)=>{if(x>y)return this.c(x-1)+1+y*2;if(x<y)return this.c(y-1)+2+x*2;return this.c(x)}}valueAt(y,x){const idx=this.indexAt(x,y);const v=this.data.get(idx);return v!==undefined?v:this.zero}setValue(y,x,v){const idx=this.indexAt(x,y);if(v===this.zero){this.data.delete(idx)}else{this.data.set(idx,v)}}cellOperation(y,x,op){this.setValue(y,x,op(this.valueAt(y,x)))}rowOperation(a,b,rowsSet,op){let i=0;for(i of rowsSet){this.setValue(a,i,op(this.valueAt(a,i),this.valueAt(b,i)))}}columnOperation(a,b,columnsSet,op){let i=0;for(i of columnsSet){this.setValue(i,a,op(this.valueAt(i,a),this.valueAt(i,b)))}}}class RefsTracker{constructor(){this.matrix=new SparseMatrix(0);this.cyclesMatrix=new SparseMatrix(0);this.cyclesMap=new Map;this.participantsMap=new Map;this.indexSet=new Set;this.incrementF=v=>v+1;this.sumF=(a,b)=>a+b}dump(){let y=0;let x=0;for(y of this.indexSet){const row=[];for(x of this.indexSet){row.push(this.matrix.valueAt(y,x))}console.log(y+\" \"+JSON.stringify(row))}}cycleAdd(closer,target){console.log(\"Reference cycle detected between objects \"+closer+\" <-> \"+target);this.cyclesMatrix.cellOperation(closer,target,v=>v+1);const aRefs=[];const bRefedBy=[];let i=0;for(i of this.indexSet){if(this.matrix.valueAt(closer,i)>0){aRefs.push(i)}if(this.matrix.valueAt(i,target)>0){bRefedBy.push(i)}}const participants=aRefs.filter(i=>bRefedBy.includes(i));participants.push(closer);participants.push(target);const cycleInfo={closer:closer,target:target,participants:participants};if(!this.cyclesMap.has(target)){this.cyclesMap.set(target,[])}this.cyclesMap.get(target).push(cycleInfo);participants.forEach(i=>{if(!this.participantsMap.has(i)){this.participantsMap.set(i,[])}this.participantsMap.get(i).push(cycleInfo)})}cycleRemove(closer,target){console.log(\"Reference cycle removed between objects \"+closer+\" <-> \"+target);this.cyclesMatrix.cellOperation(closer,target,v=>Math.max(0,v-1));const cycleInfos=this.cyclesMap.get(target);const idx=cycleInfos.findIndex(info=>info.closer===closer);const info=cycleInfos.splice(idx)[0];if(cycleInfos.length===0){this.cyclesMap.delete(target)}info.participants.forEach(i=>{const infos=this.participantsMap.get(i);const infoIdx=infos.findIndex(finfo=>finfo===info);infos.splice(infoIdx);if(infos.length===0){this.participantsMap.delete(i)}})}checkCycles(participant){if(!this.participantsMap.has(participant)){return}const cycles=this.participantsMap.get(participant);cycles.forEach(info=>{if(this.matrix.valueAt(info.target,info.closer)>0){return}this.cycleRemove(info.closer,info.target);this.refAdd(info.closer,info.target)})}refAdd(objA,objB){if(this.matrix.valueAt(objB,objA)>0){this.cycleAdd(objA,objB);return}this.matrix.cellOperation(objA,objB,this.incrementF);this.matrix.rowOperation(objA,objB,this.indexSet,this.sumF);let i=0;for(i of this.indexSet){const n=this.matrix.valueAt(i,objA);if(n>0){this.matrix.cellOperation(i,objB,v=>v+n);this.matrix.rowOperation(i,objB,this.indexSet,(a,b)=>a+n*b)}}}refRemove(objA,objB){if(this.cyclesMatrix.valueAt(objA,objB)>0){this.cycleRemove(objA,objB);return}let i=0;for(i of this.indexSet){const n=this.matrix.valueAt(i,objA);if(n>0){this.matrix.cellOperation(i,objB,v=>Math.max(0,v-n));this.matrix.rowOperation(i,objB,this.indexSet,(a,b)=>a-n*b)}}this.matrix.cellOperation(objA,objB,v=>Math.max(0,v-1));this.matrix.rowOperation(objA,objB,this.indexSet,(a,b)=>a-b);this.checkCycles(objB)}refsCount(obj){let count=0;let y=0;for(y of this.indexSet){count+=this.matrix.valueAt(y,obj)}if(this.cyclesMap.has(obj)){count+=this.cyclesMap.get(obj).length}return count}refHolders(obj){const holders=[];let y=0;for(y of this.indexSet){if(this.matrix.valueAt(y,obj)!==0){holders.push([y,this.matrix.valueAt(y,obj)])}}if(this.cyclesMap.has(obj)){this.cyclesMap.get(obj).forEach(info=>holders.push([info.closer,1]))}return holders}cycles(){const objs=[];this.cyclesMap.forEach(entry=>{entry.forEach(info=>{info.participants.forEach(i=>objs.push(i))})});return objs}}const refsTracker=new RefsTracker;class TaskQueues{constructor(){this.queues=new Map;this.queuesBusy=new Map}clear(qName){if(this.queues.has(qName)){this.queues.set(qName,[])}}enqueue(qName){if(!this.queues.has(qName)){this.queues.set(qName,[]);this.queuesBusy.set(qName,false)}const next=()=>{this.queuesBusy.set(qName,false);const queue=this.queues.get(qName);if(queue.length>0){const cb=queue.shift();this.queuesBusy.set(qName,true);cb()}};return new Promise((resolve,reject)=>{const queue=this.queues.get(qName);queue.push(()=>{resolve(next)});if(!this.queuesBusy.get(qName)){next()}})}}const taskQueues=new TaskQueues;const namedCallbacks=new Map;const waitAborters=new Map;class CustomPropertiesManager{constructor(){this.map=new Map}addProperty(obj,name,getter,setter){let item=this.map.get(obj);if(!item){item=new Map;this.map.set(obj,item)}item.set(name,[getter,setter]);const pm=this;if(!ProtoObject.prototype.hasOwnProperty(name)){Object.defineProperty(ProtoObject.prototype,name,{set(v){return pm.set(this,name,v)},get(){return pm.get(this,name)},enumerable:false})}}removeProperty(obj,name){const item=this.map.get(obj);if(item){item.delete(name);if(item.size===0){this.map.delete(obj)}}}hasProperty(obj,name){const item=this.map.get(obj);if(item){return item.has(name)}return false}hasGetter(obj,name){const item=this.map.get(obj);if(item){const item2=item.get(name);if(item2){return item2[0]!==null}}return false}hasSetter(obj,name){const item=this.map.get(obj);if(item){const item2=item.get(name);if(item2){return item2[1]!==null}}return false}removeObject(obj){this.map.delete(obj)}get(obj,name){const item=this.map.get(obj);if(item){const item2=item.get(name);if(item2&&item2[0]!==null){const res=item2[0]();return res}else{return undefined}}return undefined}set(obj,name,v){const item=this.map.get(obj);if(item){const item2=item.get(name);if(item2&&item2[1]!==null){return item2[1](v)}else{throw\"Object \"+obj.objectType+\"@\"+obj.objectLocation+\" has no writable property '\"+name+\"'.\"}}return undefined}properties(obj){const item=this.map.get(obj);if(item){return Array.from(item.keys())}return[]}}const propsManager=new CustomPropertiesManager;let objCounter=0;let idCounter=0;const allInstances=new Set;const generatedUids=new Set;const d=new WeakMap;class ProtoObject{customProperties(){return propsManager.properties(this)}}const sharedResources=new Map;class Obj extends ProtoObject{constructor(){super();d.set(this,{lifeCycleStatus:\"new\",customProperties:[],parent:null,children:[],interpolators:{},objectId:idCounter++,objectLocation:\"<?>\",objectType:this.constructor.name,typeCache:{},connectionMonitors:{}});this.notifyable(\"children\");this.notifyable(\"parent\");this.registerEvent(\"initialization\");this.registerEvent(\"destruction\");this.registerEvent(\"termination\");++objCounter;allInstances.add(this);refsTracker.indexSet.add(this.objectId)}get lifeCycleStatus(){return d.get(this).lifeCycleStatus}get objectId(){return d.get(this).objectId}get objectLocation(){return d.get(this).objectLocation}set objectLocation(l){d.get(this).objectLocation=l}get objectType(){return d.get(this).objectType}set objectType(t){d.get(this).objectType=t}get parent(){return d.get(this).parent}set parent(p){if(d.get(this).parent===p){return}if(d.get(this).parent){if(p!==null){this.log(\"\",\"warning\",\"The object \"+this.constructor.name+\" at \"+this.objectLocation+\" \"+\"has already a parent \"+d.get(this).parent.constructor.name+\" at \"+d.get(this).parent.objectLocation+\".\")}d.get(this).parent.detachChild(this);this.referenceRemove(d.get(this).parent)}d.get(this).parent=p;if(p!==null){p.attachChild(this);this.referenceAdd(p)}if(this.lifeCycleStatus!==\"destroyed\"){this.parentChanged()}}get children(){return d.get(this).children}rgba(r,g,b,a){return colUtil.rgba(r,g,b,a)}rgb(r,g,b){return colUtil.rgb(r,g,b)}colorName(name){return colUtil.color(name)}vec3(x,y,z){return vec.vec3(x,y,z)}init(){if(d.get(this).lifeCycleStatus===\"initialized\"){console.error(`Attempted to initialize an already initialized object: ${this.constructor.name} (${this.objectLocation})`);return}d.get(this).lifeCycleStatus=\"initialized\";d.get(this).typeCache={};this.trigger(\"initialization\")}destroy(){if(d.get(this).lifeCycleStatus===\"destroyed\"){console.error(`Attempted to destroy an already destroyed object: #${this.objectId} ${this.constructor.name} (${this.objectLocation})`);return}d.get(this).lifeCycleStatus=\"destroyed\";this.trigger(\"destruction\");this.trigger(\"termination\");connHub.removeReceiver(this);connHub.removeEmitter(this);if(d.get(this).parent){d.get(this).parent.detachChild(this)}d.get(this).parent=null;propsManager.removeObject(this);d.get(this).interpolators={};if(this.get){this.get().remove()}d.get(this).refCountMap={};d.get(this).customProperties=[];d.get(this).connectionMonitors={};d.get(this).children=[];for(const key of namedCallbacks.keys()){if(key.startsWith(this.objectId+\"#\")){namedCallbacks.delete(key)}}--objCounter;allInstances.delete(this);refsTracker.indexSet.delete(this.objectId)}releaseLater(){this.wait(0).then(()=>{this.parent=null})}safeCallback(callback,condition){if(!condition){condition=()=>{return d.get(this).lifeCycleStatus!==\"destroyed\"}}return(...args)=>{if(condition()){return callback(...args)}}}namedCallback(callback,name){const cbName=this.objectId+\"#\"+name;namedCallbacks.set(cbName,callback);return(...args)=>{if(namedCallbacks.has(cbName)){const cb=namedCallbacks.get(cbName);namedCallbacks.delete(cbName);return cb(...args)}}}namedCallbackPending(name){const cbName=this.objectId+\"#\"+name;return namedCallbacks.has(cbName)}cancelNamedCallback(name){const cbName=this.objectId+\"#\"+name;if(namedCallbacks.has(cbName)){namedCallbacks.delete(cbName)}}referenceAdd(which){if(which===this){return}refsTracker.refAdd(which.objectId,this.objectId);if(d.get(this).lifeCycleStatus===\"new\"){if(which.lifeCycleStatus===\"initialized\"){this.init()}else{which.connect(\"initialization\",this,()=>{if(this.lifeCycleStatus===\"new\"){this.init()}which.disconnect(\"initialization\",this)})}}which.connect(\"destruction\",this,this.safeCallback(()=>{this.referenceRemove(which)}))}referenceRemove(which){if(which===this){return}refsTracker.refRemove(which.objectId,this.objectId);which.disconnect(\"destruction\",this);if(refsTracker.refsCount(this.objectId)===0&&this.objectId>0){this.destroy()}}attachChild(child){d.get(this).children.push(child);this.childrenChanged()}detachChild(child){if(d.get(this).lifeCycleStatus!==\"destroyed\"){d.get(this).children=d.get(this).children.filter(c=>c!==child);this.childrenChanged()}}isAncestorOf(obj){let p=obj.parent;while(p){if(p===this){return true}p=p.parent}return false}visit(f){if(f(this)){d.get(this).children.forEach(c=>c.visit(f))}}notifyable(name){if(!propsManager.hasProperty(this,name+\"Changed\")){this.registerEvent(name+\"Changed\")}}typeOf(name){const priv=d.get(this);const result=priv.typeCache[name];if(result){return result}if(priv.customProperties.find(c=>c===name)){priv.typeCache[name]=\"property\";return\"property\"}else if(propsManager.hasProperty(this,name)){if(propsManager.hasSetter(this,name)){priv.typeCache[name]=\"eventhandler\";return\"eventhandler\"}else{priv.typeCache[name]=\"event\";return\"event\"}}let proto=Object.getPrototypeOf(this);while(proto){const descr=Object.getOwnPropertyDescriptor(proto,name);if(descr){if(descr.get||descr.set){priv.typeCache[name]=\"property\";return\"property\"}else{priv.typeCache[name]=\"method\";return\"method\"}}proto=Object.getPrototypeOf(proto)}return\"undefined\"}addProperty(name,getter,setter,innate){this.notifyable(name);const s=v=>{const prevV=getter();if(v===prevV){return}if(prevV instanceof Obj&&!prevV.isAncestorOf(this)){prevV.referenceRemove(this)}if(v instanceof Obj&&!v.isAncestorOf(this)){v.referenceAdd(this)}setter(v);this[name+\"Changed\"]()};propsManager.addProperty(this,name,getter,s);d.get(this).customProperties.push(name)}transitionable(name,interpolate){let transition=null;this.addProperty(name+\"Transition\",()=>transition,t=>{transition=t});if(interpolate){d.get(this).interpolators[name]=interpolate}}change(name,newValue){const type=typeof newValue;if((type===\"string\"||type===\"number\")&&newValue===this[name]){return}const f=newValue=>{const transitionProp=name+\"Transition\";if(this[transitionProp]&&this[transitionProp].enabled&&d.get(this).lifeCycleStatus===\"initialized\"){const transition=this[transitionProp];transition.from=this[name];transition.to=newValue;const interpolate=d.get(this).interpolators[name];if(interpolate){transition.interpolate=interpolate}transition.start(value=>{this[name]=value})}else{this[name]=newValue}};if(type===\"object\"&&newValue!==null&&newValue.constructor.name===\"Promise\"){newValue.then(f).catch(err=>{console.error(err)})}else{f(newValue)}}registerEvent(name,connectionMonitor){if(propsManager.hasProperty(this,name)){throw\"The name \"+name+\" is already in use.\"}const uname=name[0].toUpperCase()+name.substr(1);const onEvent=\"on\"+uname;if(propsManager.hasProperty(this,onEvent)){throw\"The name \"+onEvent+\" is already in use.\"}const s=cb=>{this.connect(name,this,cb)};const g=()=>true;propsManager.addProperty(this,onEvent,g,s);const priv=d.get(this);let localRecursionDepth=0;const getter=(...args)=>{if(localRecursionDepth>3){this.log(\"\",\"warning\",`Binding loop in ${this.constructor.name}.${name} (${this.objectLocation})`);return}++localRecursionDepth;this.trigger(name,...args);--localRecursionDepth};propsManager.addProperty(this,name,()=>getter,null);if(connectionMonitor){priv.connectionMonitors[name]=connectionMonitor}}connect(event,receiver,handler){connHub.connect(this,event,receiver,handler);const mon=d.get(this).connectionMonitors[event];if(mon){mon()}}disconnect(event,receiver){connHub.disconnect(this,event,receiver)}trigger(event,...args){connHub.trigger(this,event,args)}hasConnections(event){return connHub.has(this,event)}sharedResource(key,factory){if(sharedResources.has(key)){const share=sharedResources.get(key);share.users.add(this);return share.res}if(factory){const res=factory();const share={users:new Set,res};share.users.add(this);sharedResources.set(key,share);const monitors=this.sharedResource(key+\"-pending\")||[];monitors.forEach(mon=>mon());return res}return null}freeSharedResource(key,deleter){if(sharedResources.has(key)){const share=sharedResources.get(key);share.users.delete(this);if(share.users.size===0){sharedResources.delete(key);if(deleter){deleter(share.res)}}}}awaitSharedResource(key,callback){if(this.sharedResource(key)){callback();return false}const pendingKey=key+\"-pending\";const monitors=this.sharedResource(pendingKey,()=>[]);if(monitors.length>0){monitors.push(()=>{this.freeSharedResource(pendingKey);callback()});return false}monitors.push(()=>{this.freeSharedResource(pendingKey);callback()});return true}accumulateCallback(f,name){this.wait(0).then(this.namedCallback(this.safeCallback(f),name))}defer(f,name){this.wait(0).then(this.namedCallback(f,name))}wait(ms,name){return new Promise((resolve,reject)=>{if(ms===0){let aborted=false;connHub.runAfterTrigger(this.safeCallback(()=>{if(name){waitAborters.delete(this.objectId+\"#\"+name)}resolve(true)},()=>!aborted&&this.lifeCycleStatus!==\"destroyed\"));if(name){waitAborters.set(this.objectId+\"#\"+name,()=>{aborted=true;waitAborters.delete(this.objectId+\"#\"+name);resolve(false)})}}else{const handle=setTimeout(this.safeCallback(()=>{if(name){waitAborters.delete(this.objectId+\"#\"+name)}resolve(true)}),ms);if(name){waitAborters.set(this.objectId+\"#\"+name,()=>{clearTimeout(handle);waitAborters.delete(this.objectId+\"#\"+name);resolve(false)})}}})}abortWait(name){const f=waitAborters.get(this.objectId+\"#\"+name);if(f){f()}}waitQueued(qName){return taskQueues.enqueue(this.objectId+qName)}clearQueue(qName){taskQueues.clear(this.objectId+qName)}import(url,callback){return new Promise((resolve,reject)=>{shRequire([url],mod=>{if(mod){resolve(mod);if(callback)callback(mod)}else{reject(\"Failed to load module: \"+url);if(callback)callback(null)}})})}log(domain,level,message){const priv=d.get(this);if(priv.parent&&priv.parent.log){priv.parent.log(domain,level,message)}}add(child){child.parent=this}}exports.Object=Obj;function generateUid(){let uid=\"\";do{uid=Math.floor(Math.random()*16777216).toString(16)+\"-\"+Math.floor(Math.random()*16777216).toString(16)+\"-\"+Math.floor(Math.random()*16777216).toString(16)}while(generatedUids.has(uid));generatedUids.add(uid);return uid}exports.generateUid=generateUid;function formatBytes(bytes){let size=Math.ceil(bytes/1024);const units=[\"K\",\"M\",\"G\",\"T\"];let sizeText=\"\";for(let i=0;i<units.length;++i){const unit=units[i];if(size<1024){sizeText=(i===0?size:size.toFixed(1))+unit;break}size/=1024}return sizeText}exports.formatBytes=formatBytes;function formatSeconds(seconds,detailed){let centis=\"\"+Math.floor((seconds-Math.floor(seconds))*100);let t=seconds;const secs=Math.floor(t)%60;t/=60;const minutes=Math.floor(t)%60;t/=60;const hours=Math.floor(t);let h=hours.toFixed(0);let m=minutes.toFixed(0);let s=secs.toFixed(0);if(h.length===1)h=\"0\"+h;if(m.length===1)m=\"0\"+m;if(s.length===1)s=\"0\"+s;if(centis.length===1)centis=\"0\"+centis;if(detailed){return(hours>0?h+\":\":\"\")+m+\":\"+s+\".\"+centis}else{return(hours>0?h+\":\":\"\")+m+\":\"+s}}exports.formatSeconds=formatSeconds;function objectCount(){return objCounter}exports.objectCount=objectCount;function dumpStatus(){function dumpObject(obj){return{id:obj.objectId,type:obj.objectType,location:obj.objectLocation,lifeCycleStatus:obj.lifeCycleStatus,domNode:obj.get?obj.get():null,references:refsTracker.refsCount(obj.objectId),referenceHolders:refsTracker.refHolders(obj.objectId),events:connHub.events(obj).map(item=>[item[0],item[1].objectType+\"@\"+item[1].objectLocation]),children:d.get(obj).children.map(dumpObject),parent:d.get(obj).parent?d.get(obj).parent.objectType+\"@\"+d.get(obj).parent.objectLocation:\"\",itemStatus:!!obj.get?{ancestorsEnabled:obj.ancestorsEnabled,enabled:obj.enabled,ancestorsVisible:obj.ancestorsVisible,visible:obj.visible,focus:obj.focus}:null}}const idMap={};const locationMap={};const typeMap={};const statusMap={};const refCountMap={};for(let obj of allInstances){const loc=obj.objectType+\"@\"+obj.objectLocation;const dObj=dumpObject(obj);idMap[obj.objectId]=dObj;if(!locationMap[loc]){locationMap[loc]=[]}locationMap[loc].push(dObj);if(!typeMap[obj.objectType]){typeMap[obj.objectType]=[]}typeMap[obj.objectType].push(dObj);if(!statusMap[obj.lifeCycleStatus]){statusMap[obj.lifeCycleStatus]=[]}statusMap[obj.lifeCycleStatus].push(dObj);if(!refCountMap[dObj.references]){refCountMap[dObj.references]=[]}refCountMap[dObj.references].push(dObj)}return{objectCount:objCounter,byId:idMap,byLocation:locationMap,byType:typeMap,byLifeCycleStatus:statusMap,byReferences:refCountMap,focusedNode:document.activeElement,namedCallbacks,cycles:refsTracker.cycles().map(id=>idMap[id])}}exports.dumpStatus=dumpStatus});exports.dbgctx=\"<no information>\";",
    "core/parallelaction.js": "shRequire([__dirname+\"/action.js\"],act=>{const d=new WeakMap;class ParallelAction extends act.Action{constructor(){super();d.set(this,{actions:[]});this.onStatusChanged=()=>{if(this.status===\"stopping\"){d.get(this).actions.forEach(action=>action.stop())}}}start(){this.wait(0).then(async()=>{if(this.enabled){const promises=d.get(this).actions.filter(action=>action.enabled).map(action=>action.start());await Promise.all(promises)}if(this.lifeCycleStatus!==\"destroyed\"){this.finish()}});return super.start()}add(child){if(child._sh_action){child.parent=this;d.get(this).actions.push(child)}else{console.error(\"Only actions may be added to a ParallelAction.\")}}}exports.ParallelAction=ParallelAction});",
    "core/registryfile.js": "const[obj,fs]=await shRequire([__dirname+\"/object.js\",__dirname+\"/filesystem.js\"]);function dirname(path){const pos=path.lastIndexOf(\"/\");if(pos!==-1){return path.substring(0,pos)||\"/\"}else{return\"/\"}}function filename(path){const pos=path.lastIndexOf(\"/\");if(pos!==-1){return path.substring(pos+1)}else{return path}}const d=new WeakMap;class RegistryFile extends obj.Object{constructor(){super();d.set(this,{fs:null,path:\"\",ready:false,modified:false,resolvers:[],registry:{\"version\":1,\"/\":{\"type\":\"folder\",\"items\":[]}}});this.notifyable(\"filesystem\");this.notifyable(\"modified\");this.notifyable(\"path\");this.notifyable(\"ready\");this.registerEvent(\"changeValue\");this.onModifiedChanged=()=>{if(d.get(this).modified){this.defer(()=>{this.writeRegistry()},\"writeRegistry\")}};this.onDestruction=()=>{if(d.get(this).modified){this.writeRegistry()}}}get filesystem(){return d.get(this).filesystem}set filesystem(fs){d.get(this).fs=fs;this.filesystemChanged();this.defer(()=>{this.readRegistry()},\"readRegistry\")}get path(){return d.get(this).path}set path(p){d.get(this).path=p;this.pathChanged();this.defer(()=>{this.readRegistry()},\"readRegistry\")}get ready(){return d.get(this).ready}get modified(){return d.get(this).modified}readRegistry(){const priv=d.get(this);if(priv.fs!==null&&priv.path!==\"\"){priv.fs.read(priv.path).then(async fileData=>{const data=await fileData.text();console.log(\"READ \"+fileData.sourceType+\" \"+priv.path);console.log(data);const reg=JSON.parse(data);if(reg.version===1){priv.registry=reg}priv.ready=true;this.readyChanged();priv.resolvers.forEach(resolver=>resolver());priv.resolvers=[]}).catch(err=>{priv.ready=true;this.readyChanged()})}}writeRegistry(){const priv=d.get(this);if(!priv.ready){return}if(priv.fs!==null&&priv.path!==\"\"){let blob=null;console.log(\"Saving Registry File: \"+priv.path);console.log(JSON.stringify(priv.registry));if(shRequire.environment===\"web\"){blob=new Blob([JSON.stringify(priv.registry,null,2)],{type:\"application/json\"})}else{blob=JSON.stringify(priv.registry,null,2)}priv.fs.write(priv.path,new fs.FileData(blob)).then(()=>{priv.modified=false;this.modifiedChanged()}).catch(err=>{console.error(this.objectType+\"@\"+this.objectLocation+\": Failed to save file '\"+priv.path+\"'\")})}}async read(key,defaultValue){const priv=d.get(this);if(!priv.ready){const p=new Promise(resolve=>{priv.resolvers.push(resolve)});await p}return this.readSync(key,defaultValue)}readSync(key,defaultValue){const priv=d.get(this);const reg=priv.registry;const obj=reg[key];if(obj){if(obj.type===\"folder\"){return obj.items}else{return obj.value}}else{return defaultValue}}async write(key,value,description){const priv=d.get(this);if(!priv.ready){const p=new Promise(resolve=>{priv.resolvers.push(resolve)});await p;return await this.write(key,value,description)}const reg=priv.registry;if(!reg[key]){this.create(key,value,description)}else{const obj=reg[key];if(obj&&obj.type!==\"folder\"){obj.value=value;if(description){obj.description=description}this.changeValue(key)}}if(!priv.modified){priv.modified=true;this.modifiedChanged()}}async remove(key){const priv=d.get(this);if(!priv.ready){const p=new Promise(resolve=>{priv.resolvers.push(resolve)});await p;return await this.remove(key)}const reg=priv.registry;if(reg[key]){const obj=reg[key];if(obj.type===\"folder\"){obj.items.forEach(childKey=>{this.remove(key+\"/\"+childKey)})}delete reg[key];const parentKey=dirname(key);const name=filename(key);reg[parentKey].items=reg[parentKey].items.filter(n=>n!==name);this.changeValue(key);if(!priv.modified){priv.modified=true;this.modifiedChanged()}}}create(key,value,description){const priv=d.get(this);const reg=priv.registry;const folderKey=dirname(key);const name=filename(key);if(!reg[folderKey]){this.mkdir(folderKey)}const obj=reg[folderKey];if(obj.type===\"folder\"){obj.items.push(name);const newObj={\"type\":typeof value,\"description\":description||\"\",\"value\":value};if(folderKey!==\"/\"){reg[folderKey+\"/\"+name]=newObj}else{reg[\"/\"+name]=newObj}if(!priv.modified){priv.modified=true;this.modifiedChanged()}}}mkdir(key){const priv=d.get(this);const reg=priv.registry;const folderKey=dirname(key);const name=filename(key);if(!reg[folderKey]){this.mkdir(folderKey)}const obj=reg[folderKey];if(obj.type===\"folder\"){obj.items.push(name);const newObj={\"type\":\"folder\",\"description\":\"\",\"items\":[]};if(folderKey!==\"/\"){reg[folderKey+\"/\"+name]=newObj}else{reg[\"/\"+name]=newObj}if(!priv.modified){priv.modified=true;this.modifiedChanged()}}}async info(key){const priv=d.get(this);if(!priv.ready){const p=new Promise(resolve=>{priv.resolvers.push(resolve)});await p;return await this.info(key)}const reg=priv.registry;const obj=reg[key];if(!obj){return null}else{return{type:obj.type,description:obj.description||\"\"}}}async list(folderKey){const priv=d.get(this);if(!priv.ready){const p=new Promise(resolve=>{priv.resolvers.push(resolve)});await p;return await this.list(folderKey)}const reg=priv.registry;const obj=reg[folderKey];if(obj&&obj.type===\"folder\"){return obj.items.slice()}else{return[]}}}exports.RegistryFile=RegistryFile;",
    "core/registryoverlay.js": "const[obj]=await shRequire([__dirname+\"/object.js\"]);function dirname(path){const pos=path.lastIndexOf(\"/\");if(pos!==-1){return path.substring(0,pos)||\"/\"}else{return\"/\"}}function filename(path){const pos=path.lastIndexOf(\"/\");if(pos!==-1){return path.substring(pos+1)}else{return path}}const d=new WeakMap;class RegistryOverlay extends obj.Object{constructor(){super();d.set(this,{registry:null,overlay:{},removals:new Set,modified:false});this.notifyable(\"modified\");this.notifyable(\"registry\");this.registerEvent(\"changeValue\")}get registry(){return d.get(this).registry}set registry(r){d.get(this).registry=r;this.registryChanged()}get modified(){return d.get(this).modified}async info(key){const priv=d.get(this);const overlay=priv.overlay[key];if(overlay){return overlay}else{return await priv.registry.info(key)}}async list(folderKey){const priv=d.get(this);for(let remKey of priv.removals){if(folderKey.startsWith(remKey)){return[]}}const contents=await priv.registry.list(folderKey);for(let key in priv.overlay){if(dirname(key)===folderKey){const name=filename(key);if(contents.indexOf(name)===-1){contents.push(name)}}}return contents}async read(key,defaultValue){const priv=d.get(this);for(let remKey of priv.removals){if(key.startsWith(remKey)){return defaultValue}}const overlay=priv.overlay[key];if(overlay){return overlay.value}else{return await priv.registry.read(key,defaultValue)}}async write(key,value,description){const priv=d.get(this);priv.overlay[key]={type:typeof value,description,value};this.changeValue(key);if(!priv.modified){priv.modified=true;this.modifiedChanged()}}async remove(key){const priv=d.get(this);priv.removals.add(key);for(let ovKey in priv.overlay){if(ovKey.startsWith(key)){priv.overlay.delete(ovKey)}}if(!priv.modified){priv.modified=true;this.modifiedChanged()}}async apply(){const priv=d.get(this);for(let key in priv.overlay){const item=priv.overlay[key];await priv.registry.write(key,item.value,item.description)}for(let key of priv.removals){await priv.registry.remove(key)}if(priv.modified){priv.modified=false;this.modifiedChanged()}}async cancel(){const priv=d.get(this);priv.overlay={};priv.removals.clear();if(priv.modified){priv.modified=false;this.modifiedChanged()}}}exports.RegistryOverlay=RegistryOverlay;",
    "core/repeater.js": "\"use strict\";shRequire([__dirname+\"/object.js\",__dirname+\"/listmodel.js\"],function(obj,listModel){let d=new WeakMap;class Repeater extends obj.Object{constructor(){super();d.set(this,{model:null,delegate:()=>null,items:[],recycleBin:[]});this.notifyable(\"count\");this.notifyable(\"model\");this.onInitialization=()=>{this.clear();this.renderAll()};this.onDestruction=()=>{this.clear()}}get count(){return!!d.get(this).model?d.get(this).model.size:0}get model(){return d.get(this).model}set model(m){const priv=d.get(this);let mObj=null;if(typeof m===\"number\"){if(priv.model){while(priv.model.size>m){priv.model.remove(priv.model.size-1)}if(m>priv.model.size){const arr=[];for(let i=priv.model.size;i<m;++i)arr.push({});priv.model.bulkInsert(priv.model.size,arr)}return}else{mObj=new listModel.ListModel;const arr=[];for(let i=0;i<m;++i)arr.push({});mObj.reset(arr)}}else{mObj=m}this.clear();if(priv.model){priv.model.disconnect(\"modelReset\",this);priv.model.disconnect(\"modelInsert\",this);priv.model.disconnect(\"modelRemove\",this);priv.model.disconnect(\"modelReplace\",this);priv.model.referenceRemove(this)}priv.model=mObj;if(mObj){mObj.referenceAdd(this);mObj.connect(\"modelReset\",this,()=>{const toDestroy=[];priv.items.forEach((item,idx)=>{toDestroy.push(idx)});toDestroy.sort((a,b)=>b<a?-1:1).forEach(idx=>{this.destroyItem(idx)});priv.items=[];for(let i=0;i<mObj.size;++i){priv.items.push(undefined)}this.dumpRecycleBin();this.renderAll();this.countChanged()});mObj.connect(\"modelInsert\",this,(at,size)=>{for(let i=0;i<size;++i){priv.items=priv.items.slice(0,at).concat([undefined]).concat(priv.items.slice(at))}for(let i=at+size;i<priv.items.length;++i){this.updateItem(i)}this.renderAll();this.countChanged()});mObj.connect(\"modelRemove\",this,at=>{this.destroyItem(at);priv.items.splice(at,1);priv.items.forEach((item,idx)=>{if(idx>=at){this.updateItem(idx)}});this.renderAll();this.countChanged()});mObj.connect(\"modelReplace\",this,at=>{this.updateItem(at);this.renderAll()})}this.renderAll();this.modelChanged();this.countChanged()}get delegate(){return d.get(this).delegate}set delegate(del){d.get(this).delegate=del;this.renderAll()}get items(){return d.get(this).items.slice()}dumpRecycleBin(){const priv=d.get(this);priv.recycleBin.forEach(item=>{item.referenceRemove(this)});priv.recycleBin=[]}createItem(idx){const priv=d.get(this);const modelData={index:idx,value:priv.model.at(idx)};let item=null;if(priv.recycleBin.length>0){item=priv.recycleBin.pop();item.modelData=modelData}else{item=priv.delegate({modelData:modelData});if(item){item.referenceAdd(this)}}return item}updateItem(idx){const priv=d.get(this);const modelData={index:idx,value:priv.model.at(idx)};if(modelData.value!==undefined){const item=this.getItem(idx);if(item){item.modelData=modelData}}}destroyItem(idx){const priv=d.get(this);const item=this.getItem(idx);if(item){priv.recycleBin.push(item);item.parent=null}}getItem(idx){return d.get(this).items[idx]}clear(){d.get(this).items.forEach(item=>{if(item!==undefined){item.parent=null;item.referenceRemove(this)}});d.get(this).items=[]}renderAll(){if(this.lifeCycleStatus!==\"initialized\"){return}const model=d.get(this).model;const delegate=d.get(this).delegate;const items=d.get(this).items;if(!model||!delegate||!this.parent){return}const f=()=>{const existingItems=items.filter(c=>c!==undefined);for(let i=0;i<model.size;++i){if(items[i]===undefined){const item=this.createItem(i);if(item){if(existingItems.length===0){this.parent.add(item)}else{this.parent.add(item,existingItems[0])}items[i]=item}}else{if(existingItems.length>0&&existingItems[0]===items[i]){existingItems.shift()}}}};if(this.parent.withoutSizing){this.parent.withoutSizing(f)}else{f()}}}exports.Repeater=Repeater});",
    "core/rpcproxy.js": "shRequire([__dirname+\"/object.js\"],obj=>{let idCounter=0;class MessageSocket{constructor(endpoint,handler){this.socketId=idCounter;this.reader=null;this.endpoint=endpoint;this.handler=handler;++idCounter}postMessage(sessionId,message,binaries){if(!binaries){binaries=[]}const binarySize=binaries.map(b=>b.length).reduce((a,b)=>a+b,0);const json=JSON.stringify(message);const jsonData=new TextEncoder().encode(json);const buffer=new Uint8Array(8+jsonData.length+binarySize);const view32=new Uint32Array(buffer.buffer,0,2);view32[0]=jsonData.length;view32[1]=binarySize;let offset=8;buffer.set(jsonData,offset);offset+=jsonData.length;binaries.forEach(b=>{buffer.set(b,offset);offset+=b.length});const headers=new Headers;headers.append(\"x-shellfish-rpc-session\",sessionId);fetch(this.endpoint,{method:\"POST\",headers,body:buffer}).then(response=>{if(!response.ok){console.error(response.statusText);this.handler({type:\"exit\"})}}).catch(err=>{console.error(JSON.stringify(message)+\" \"+err);this.handler({type:\"exit\"})})}connect(){fetch(this.endpoint).then(async response=>{if(response.ok){let buffer=null;let bufferOffset=0;let dataOffset=0;let jsonSize=0;this.reader=response.body.getReader();let done=false;let value=null;while(!done){if(value===null){const r=await this.reader.read();done=r.done;value=r.value;dataOffset=0;if(value===undefined){break}}if(buffer===null){jsonSize=value[dataOffset++]+(value[dataOffset++]<<8)+(value[dataOffset++]<<16)+(value[dataOffset++]<<24);const binarySize=value[dataOffset++]+(value[dataOffset++]<<8)+(value[dataOffset++]<<16)+(value[dataOffset++]<<24);buffer=new ArrayBuffer(jsonSize+binarySize);bufferOffset=0}const view8=new Uint8Array(value.buffer,dataOffset,Math.min(value.length-dataOffset,buffer.byteLength-bufferOffset));new Uint8Array(buffer,bufferOffset).set(view8);bufferOffset+=view8.length;dataOffset+=view8.length;if(bufferOffset===buffer.byteLength){const jsonData=buffer.slice(0,jsonSize);const binaryData=buffer.slice(jsonSize);const dec=new TextDecoder;const json=dec.decode(jsonData);try{const message=JSON.parse(json);this.handler(message,binaryData)}catch(err){console.error(err)}buffer=null}if(dataOffset===value.byteLength){value=null}if(done){break}}}else{console.error(\"RPC connection closed on error: \"+response.statusText);this.handler({type:\"exit\"})}}).catch(err=>{console.error(\"RPC connection closed on error: \"+err);this.handler({type:\"exit\"})})}close(){if(this.reader){this.reader.cancel()}}}class MessageSocketNode{constructor(endpoint,handler){this.modHttp=require(\"node:http\");this.socketId=idCounter;this.reader=null;this.endpoint=endpoint;this.handler=handler}postMessage(sessionId,message,binaries){if(!binaries){binaries=[]}const binarySize=binaries.map(b=>b.length).reduce((a,b)=>a+b,0);const json=JSON.stringify(message);const jsonData=new TextEncoder().encode(json);const buffer=new Uint8Array(8+jsonData.length+binarySize);const view32=new Uint32Array(buffer.buffer,0,2);view32[0]=jsonData.length;view32[1]=binarySize;let offset=8;buffer.set(jsonData,offset);offset+=jsonData.length;binaries.forEach(b=>{buffer.set(b,offset);offset+=b.length});const req=this.modHttp.request(this.endpoint,{method:\"POST\",headers:{\"x-shellfish-rpc-session\":sessionId}});req.write(buffer);req.end()}async connect(){let done=false;let value=null;const req=this.modHttp.request(this.endpoint);let dataResolver=null;req.on(\"response\",res=>{this.reader=res;res.on(\"data\",chunk=>{if(dataResolver){const f=dataResolver;dataResolver=null;f({done:false,value:new Uint8Array(chunk)})}});res.on(\"end\",()=>{if(dataResolver){const f=dataResolver;dataResolver=null;f({done:true,value:null})}});res.on(\"error\",err=>{})});req.on(\"close\",()=>{this.handler({type:\"exit\"});done=true});req.on(\"error\",err=>{console.error(\"Connection error: \"+err.code)});req.end();function readData(){return new Promise((resolve,reject)=>{dataResolver=resolve})}let buffer=null;let bufferOffset=0;let dataOffset=0;let jsonSize=0;while(!done){if(value===null){const r=await readData();done=r.done;value=r.value;dataOffset=0}if(buffer===null){jsonSize=value[dataOffset++]+(value[dataOffset++]<<8)+(value[dataOffset++]<<16)+(value[dataOffset++]<<24);const binarySize=value[dataOffset++]+(value[dataOffset++]<<8)+(value[dataOffset++]<<16)+(value[dataOffset++]<<24);buffer=new ArrayBuffer(jsonSize+binarySize);bufferOffset=0}const view8=new Uint8Array(value.buffer,dataOffset,Math.min(value.length-dataOffset,buffer.byteLength-bufferOffset));new Uint8Array(buffer,bufferOffset).set(view8);bufferOffset+=view8.length;dataOffset+=view8.length;if(bufferOffset===buffer.byteLength){const jsonData=buffer.slice(0,jsonSize);const binaryData=buffer.slice(jsonSize);const dec=new TextDecoder;const json=dec.decode(jsonData);try{const message=JSON.parse(json);this.handler(message,binaryData)}catch(err){console.error(err)}buffer=null}if(dataOffset===value.byteLength){value=null}if(done){break}}}close(){if(this.reader){this.reader.destroy()}}}const d=new WeakMap;class RpcProxy extends obj.Object{constructor(){super();d.set(this,{endpoint:\"/\",socket:null,task:{},callbacks:[],callMap:new Map,callbackMap:new Map,sessionId:\"\",clientId:\"\",messageQueue:[],status:\"disconnected\"});this.notifyable(\"endpoint\");this.notifyable(\"status\");this.onDestruction=()=>{const priv=d.get(this);if(priv.socket){priv.socket.postMessage(priv.sessionId,{type:\"exit\",clientId:priv.clientId});priv.socket.close()}priv.callMap.clear();priv.callbackMap.clear()}}get status(){return d.get(this).status}get endpoint(){return d.get(this).endpoint}set endpoint(e){d.get(this).endpoint=e;this.endpointChanged();this.connectRpc()}connectRpc(){const priv=d.get(this);if(priv.socket){priv.socket.close()}priv.status=\"connecting\";this.statusChanged();const MSock=shRequire.environment===\"node\"?MessageSocketNode:MessageSocket;priv.socket=new MSock(priv.endpoint,this.safeCallback((msg,binaryData)=>{if(msg.type===\"ready\"){priv.clientId=msg.clientId;priv.sessionId=msg.sessionId;priv.status=\"connected\";this.statusChanged();priv.messageQueue.forEach(callId=>this.call(callId));priv.messageQueue=[]}else if(msg.type===\"heartbeat\"){this.log(\"\",\"debug\",\"Got heartbeat from RPC endpoint\");priv.socket.postMessage(priv.sessionId,{type:\"heartbeat\",clientId:priv.clientId})}else if(msg.type===\"exit\"){this.log(\"\",\"debug\",\"RPC connection closed\");priv.status=\"disconnected\";this.statusChanged();priv.callbacks.forEach(cbId=>{priv.callbackMap.delete(cbId)});priv.callbacks=[];priv.sessionId=\"\";priv.clientId=\"\";priv.socket=null}else if(msg.type===\"result\"){priv.callMap.get(msg.callId).resolve(this.processReceiveParameters([msg.value],binaryData)[0]);priv.callMap.delete(msg.callId)}else if(msg.type===\"error\"){priv.callMap.get(msg.callId).reject(msg.value);priv.callMap.delete(msg.callId)}else if(msg.type===\"callback\"){const params=this.processReceiveParameters(msg.parameters,binaryData);const remove=priv.callbackMap.get(msg.callbackId)(...params);if(remove){priv.callbackMap.delete(msg.callbackId)}}}));priv.socket.connect()}call(callId){const priv=d.get(this);const callItem=priv.callMap.get(callId);if(!priv.socket){this.connectRpc()}if(priv.clientId!==\"\"){this.log(\"\",\"debug\",\"Calling RPC method: \"+callItem.name);priv.socket.postMessage(priv.sessionId,{type:\"call\",clientId:priv.clientId,name:callItem.name,callId,parameters:callItem.parameters},callItem.binaries)}else{priv.messageQueue.push(callId)}}processSendParameters(parameters){const priv=d.get(this);const binaries=[];const convertedParameters=parameters.map(p=>{if(typeof p===\"function\"){const callbackId=idCounter;++idCounter;priv.callbackMap.set(callbackId,p);priv.callbacks.push(callbackId);return{type:\"callback\",clientId:priv.clientId,callbackId:callbackId}}else if(typeof p===\"object\"&&p.constructor.name===\"Uint8Array\"){binaries.push(p);return{type:\"binary\",size:p.length}}else{return p}});return[convertedParameters,binaries]}processReceiveParameters(results,binaryData){const priv=d.get(this);let binaryOffset=0;return results.map(r=>{if(!!r&&typeof r===\"object\"&&r.type===\"proxy\"){const proxy={};r.methods.forEach(method=>{proxy[method]=(...parameters)=>{return new Promise((resolve,reject)=>{const[params,binaries]=this.processSendParameters(parameters);const callId=idCounter;++idCounter;priv.callMap.set(callId,{name:r.instanceId+\".\"+method,parameters:params,binaries,resolve,reject});this.call(callId)})}});return proxy}else if(!!r&&typeof r===\"object\"&&r.type===\"binary\"){const data=binaryData.slice(binaryOffset,binaryOffset+r.size);binaryOffset+=r.size;return new Uint8Array(data)}else{return r}})}invoke(name,...parameters){const priv=d.get(this);return new Promise((resolve,reject)=>{const[params,binaries]=this.processSendParameters(parameters);const callId=idCounter;++idCounter;priv.callMap.set(callId,{name,parameters:params,binaries,resolve,reject});this.call(callId)})}}exports.RpcProxy=RpcProxy});",
    "core/scalemodel.js": "shRequire([__dirname+\"/listmodel.js\"],lm=>{function symmetricFloor(v){return v<0?Math.ceil(v):Math.floor(v)}function symmetricCeil(v){return v<0?Math.floor(v):Math.ceil(v)}function roundValue(v){if(!Math.abs(v)>0){return 0}let testValue=v;let count=0;let factor=1;if(Math.abs(testValue)>1){while(Math.abs(testValue)>1){testValue/=10;++count;if(count>=10)break}factor=10}else if(Math.abs(testValue)>0){while(Math.abs(testValue)<1){testValue*=10;++count;if(count>=10)break}--count;factor=0.1}for(let i=0;i<count;++i){v/=factor}v=symmetricCeil(v);for(let i=0;i<count;++i){v*=factor}return v}function findPrecision(distance){let count=0;while(Math.abs(distance)>0&&Math.abs(distance)<1){distance*=10;++count}return count}const d=new WeakMap;class ScaleModel extends lm.ListModel{constructor(){super();d.set(this,{begin:0,end:100,maxTicks:10,precision:0});this.notifyable(\"begin\");this.notifyable(\"end\");this.notifyable(\"maxTicks\");this.notifyable(\"precision\")}get begin(){return d.get(this).begin}set begin(b){d.get(this).begin=b;this.beginChanged();this.updateModel()}get end(){return d.get(this).end}set end(e){d.get(this).end=e;this.endChanged();this.updateModel()}get maxTicks(){return d.get(this).maxTicks}set maxTicks(m){d.get(this).maxTicks=m;this.maxTicksChanged();this.updateModel()}get precision(){return d.get(this).precision}valueToPosition(v){const priv=d.get(this);const scale=(priv.end-priv.begin)/1;return scale!==0?(v-priv.begin)/scale:0}updateModel(){const priv=d.get(this);const rangeSize=priv.end-priv.begin;const tickDistance=roundValue(rangeSize/priv.maxTicks);let tickAmount=0;if(tickDistance!==0){tickAmount=Math.floor(Math.abs(rangeSize/tickDistance))+1}const offset=priv.begin<priv.end?symmetricCeil(priv.begin/tickDistance)*tickDistance-priv.begin:symmetricFloor(priv.begin/tickDistance)*tickDistance-priv.begin;const newTicks=[];for(let i=0;i<tickAmount;++i){const value=priv.begin+offset+i*tickDistance;const pos=this.valueToPosition(value);if(pos<0||pos>1){continue}newTicks.push({position:pos,value})}newTicks.sort((a,b)=>a.position-b.position);priv.precision=findPrecision(tickDistance);this.precisionChanged();if(Math.abs(newTicks.length-this.size)<this.size/2){while(this.size>newTicks.length){this.remove(this.size-1)}for(let idx=0;idx<newTicks.length;++idx){const tick=newTicks[idx];if(idx<this.size){this.replace(idx,tick)}else{this.bulkInsert(this.size,newTicks.slice(idx));break}}}else{this.reset(newTicks)}}}exports.ScaleModel=ScaleModel});",
    "core/scriptaction.js": "shRequire([__dirname+\"/action.js\"],act=>{const d=new WeakMap;class ScriptAction extends act.Action{constructor(){super();d.set(this,{script:()=>{}})}get script(){return d.get(this).script}set script(f){d.get(this).script=f}start(){this.wait(0).then(async()=>{if(this.enabled){try{const r=d.get(this).script();if(r.constructor&&r.constructor.name===\"Promise\"){await r}}catch(err){}}this.finish()});return super.start()}}exports.ScriptAction=ScriptAction});",
    "core/sequentialaction.js": "shRequire([__dirname+\"/action.js\"],act=>{const d=new WeakMap;class SequentialAction extends act.Action{constructor(){super();d.set(this,{actions:[],repeat:false});this.notifyable(\"repeat\");this.onStatusChanged=()=>{if(this.status===\"stopping\"){d.get(this).actions.forEach(action=>action.stop())}}}get repeat(){return d.get(this).repeat}set repeat(r){d.get(this).repeat=r;this.repeatChanged()}start(){this.wait(0).then(async()=>{if(this.enabled){do{const actions=d.get(this).actions.filter(action=>action.enabled);for(let i=0;i<actions.length&&this.enabled&&this.status===\"running\";++i){const action=actions[i];await action.start()}}while(d.get(this).repeat&&this.enabled&&this.status===\"running\")}if(this.lifeCycleStatus!==\"destroyed\"){this.finish()}});return super.start()}add(child){if(child._sh_action){child.parent=this;d.get(this).actions.push(child)}else{console.error(\"Only actions may be added to a SequentialAction.\")}}}exports.SequentialAction=SequentialAction});",
    "core/threadpool.js": "\"use strict\";shRequire([__dirname+\"/object.js\",__dirname+\"/util/compat.js\"],(obj,compat)=>{const WORKER_CODE=`\n        \"use strict\";\n\n        //console.log(\"Starting new worker thread.\");\n\n        let idCounter = 0;\n        \n        // map of code -> task ID\n        const taskCache = new Map();\n        let taskIdCounter = 0;\n\n        // map of URL -> Module\n        const moduleCache = new Map();\n\n        let currentUrl = \"\";\n\n        const methods = new Map();\n        let transferList = [];\n\n\n        //\n\n        const isWeb = (typeof self !== \"undefined\");\n        const isNode = (typeof process !== \"undefined\" && typeof process.versions.node !== \"undefined\");\n\n        const modWorkerThreads = isNode ? require(\"worker_threads\") : null;\n        const modVm = isNode ? require(\"vm\") : null;\n        const worker = isWeb ? self : this;\n\n        //console.log(\"isWeb: \" + isWeb + \", isNode: \" + isNode);\n\n        function importCodeCompat(code)\n        {\n            //console.log(\"import code \" + code.length);\n            if (isWeb)\n            {\n                const codeBlob = new Blob([code], { type: \"application/type\" });\n                const url = URL.createObjectURL(codeBlob);\n                importScripts(url);\n                URL.revokeObjectURL(url);\n            }\n            else if (isNode)\n            {\n                modVm.runInThisContext(code, { filename: \"<task>\" });\n            }\n        }\n\n        function addEventListenerCompat(event, callback)\n        {\n            if (isWeb)\n            {\n                worker.addEventListener(event, callback);\n            }\n            else if (isNode)\n            {\n                modWorkerThreads.parentPort.on(event, callback);\n            }\n        }\n\n        function postMessageCompat(...args)\n        {\n            if (isWeb)\n            {\n                worker.postMessage(...args);\n            }\n            else if (isNode)\n            {\n                modWorkerThreads.parentPort.postMessage(...args);\n            }\n        }\n\n        function extractMessageDataCompat(obj)\n        {\n            if (isWeb)\n            {\n                return obj.data;\n            }\n            else\n            {\n                return obj;\n            }\n        }\n\n        //\n\n\n\n        worker.AtomicInt32 = class AtomicInt32\n        {\n            constructor(buffer)\n            {\n                this.view = new Int32Array(buffer);\n            }\n    \n            get value() { return Atomics.load(this.view, 0); }\n            set value(v) { return Atomics.store(this.view, 0, v); }\n    \n            add(v) { return Atomics.add(this.view, 0, v); }\n            and(v) { return Atomics.and(this.view, 0, v); }\n            or(v) { return Atomics.or(this.view, 0, v); }\n            sub(v) { return Atomics.sub(this.view, 0, v); }\n            wait(forValue, timeout)\n            {\n                while (true)\n                {\n                    const status = Atomics.wait(this.view, 0, forValue, timeout);\n                    if (status === \"timed-out\")\n                    {\n                        return false;\n                    }\n                    else if (status === \"ok\")\n                    {\n                        return true;\n                    }\n                }\n            }\n        };\n\n        /**\n         * Imports (Emscripten) WASM code from the given URL.\n         */\n        worker.importWasm = (wasmUrl) =>\n        {\n            return new Promise(async (resolve, reject) =>\n            {\n                const runtimeUrl = wasmUrl.replace(/\\.wasm$/i, \".js\");\n                const pos = wasmUrl.lastIndexOf(\"/\");\n                const wasmDirectory = pos > 0 ? wasmUrl.substr(0, pos) : wasmUrl;\n\n                function processor(u, code)\n                {\n                    return \"exports.init = (Module) => \" +\n                           \"{ \" + code + \"\\\\nreturn Module; };\"\n                }\n\n                const mod = await shRequire(runtimeUrl, null, processor);\n\n                let runTime = null;\n\n                const Module = {\n                    mainScriptUrlOrBlob: runtimeUrl,\n                    locateFile: (path, scriptDirectory) =>\n                    {\n                        return wasmDirectory + \"/\" + path;\n                    },\n                    onRuntimeInitialized: () =>\n                    {\n                        resolve(runTime);\n                    }\n                };\n                runTime = mod.init(Module);\n            });\n        };\n\n        /**\n         * Puts the thread to sleep for the given amount of milliseconds.\n         */\n        worker.sleep = (ms) =>\n        {\n            if (typeof SharedArrayBuffer !== \"undefined\")\n            {\n                const buf = new SharedArrayBuffer(4);\n                const view = new Int32Array(buf);\n                Atomics.wait(view, 0, 0, ms);\n            }\n            else\n            {\n                // this platform only allows a busy wait\n                const now = Date.now();\n                const later = now + ms;\n                while (Date.now() < later);\n            }\n        };\n\n        /**\n         * Marks the given object for transfer.\n         */\n        worker.transfer = (v) =>\n        {\n            transferList.push(v);\n            return v;\n        };\n\n        /**\n         * Creates a proxy for calling methods of the given object by\n         * another thread.\n         */\n        worker.proxyObject = (obj) =>\n        {\n            const proxyId = idCounter;\n            ++idCounter;\n\n            const methods = [];\n\n            function allKeys(obj)\n            {\n                let keys = Object.getOwnPropertyNames(obj)\n                .filter(n => n !== \"constructor\")\n                .filter(n => typeof obj[n] === \"function\")\n                const proto = Object.getPrototypeOf(obj);\n                if (! proto.hasOwnProperty(\"hasOwnProperty\"))\n                {\n                    keys = keys.concat(allKeys(proto));\n                }\n                return keys;\n            }\n\n            allKeys(obj)\n            .forEach(key =>\n            {\n                registerWorkerMethod(proxyId + \".\" + key, obj[key].bind(obj));\n                methods.push(key);\n            });\n\n            return { type: \"proxy\", instance: proxyId, methods: methods };\n        };\n\n        /**\n         * Registers the given module (used internally).\n         */\n        worker.registerModule = (mod) =>\n        {\n            moduleCache.set(taskIdCounter, mod);\n            for (let key in mod)\n            {\n                if (key === \"__run__\")\n                {\n                    continue;\n                }\n                else if (typeof mod[key] === \"function\")\n                {\n                    registerWorkerMethod(key, mod[key]);\n                }\n            }\n        };\n\n        /**\n         * Registers the given worker method (used internally).\n         */\n        worker.registerWorkerMethod = (name, f) =>\n        {\n            //console.log(\"Registering worker method: \" + name);\n            methods.set(name, f);\n        };\n\n        /**\n         * Exits the task manually.\n         */\n        worker.exit = () =>\n        {\n            postMessageCompat({ type: \"exit\" });\n        };\n\n        function loadTask(code)\n        {\n            let taskId = \"\";\n            if (taskCache.has(code))\n            {\n                taskId = taskCache.get(code);\n                //console.log(\"from cache \" + taskId);\n                //console.log(moduleCache);\n            }\n            else\n            {\n                const js = \"(function () { \" +\n                           \"const exports = { }; \" +\n                           code + \"\\\\n\" +\n                           \"if (typeof run !== 'undefined') { exports.__run__ = run; }\\\\n\\\\n\" +\n                           \"worker.registerModule(exports); \" +\n                           \"})();\"\n               \n                importCodeCompat(js);\n                taskId = taskIdCounter;\n                taskCache.set(code, taskId);\n                ++taskIdCounter;\n            }\n            return moduleCache.get(taskId);\n        }\n\n        function processInParameters(parameters)\n        {\n            return parameters.map(p =>\n            {\n                if (!! p && typeof p === \"object\")\n                {\n                    if (p.type === \"callback\")\n                    {\n                        // create callback function\n                        const callbackId = p.safeCallback;\n                        return (...parameters) =>\n                        {\n                            postMessageCompat({ type: \"callback\", callback: callbackId, parameters }, transferList);\n                            transferList = [];\n                        };\n                    }\n                    else if (p.type === \"atomicInt32\")\n                    {\n                        return new AtomicInt32(p.buffer);\n                    }\n                    else\n                    {\n                        return p;\n                    }\n                }\n                else\n                {\n                    return p;\n                }\n            });\n        }\n\n        function handleResult(r, onResult, onError)\n        {\n            if (typeof r === \"object\" && r.constructor.name === \"Promise\")\n            {\n                r\n                .then(v => onResult(v))\n                .catch(err => onError(err));\n            }\n            else\n            {\n                onResult(r);\n            }\n        }\n\n        addEventListenerCompat(\"message\", ev =>\n        {\n            const msg = extractMessageDataCompat(ev);\n            if (msg.type === \"import\")\n            {\n                // import worker-global code (e.g. require.js)\n\n                importCodeCompat(msg.code);\n                postMessageCompat({ type: \"ready\" });\n            }\n            else if (msg.type === \"task\")\n            {\n                // start a new task\n\n                methods.clear();\n                transferList = [];\n\n                const task = loadTask(msg.code);\n                if (task.__run__)\n                {\n                    const parameters = processInParameters(msg.parameters);\n                    const taskResult = task.__run__(...parameters);\n                    handleResult(taskResult, r =>\n                    {\n                        postMessageCompat({ type: \"result\", value: r }, transferList);\n                        transferList = [];\n                    },\n                    err =>\n                    {\n                        postMessageCompat({ type: \"error\", value: \"\" + err });\n                        transferList = [];\n                        postMessageCompat({ type: \"exit\" });\n                    });\n                }\n\n                if (methods.size === 0)\n                {\n                    postMessageCompat({ type: \"exit\" });\n                }\n            }\n            else if (msg.type === \"call\")\n            {\n                // call a registered method\n\n                if (methods.has(msg.name))\n                {\n                    const parameters = processInParameters(msg.parameters);\n                    try\n                    {\n                        const result = methods.get(msg.name)(...parameters);\n                        handleResult(result, r =>\n                        {\n                            postMessageCompat({ type: \"methodResult\", callId: msg.callId, value: r }, transferList);\n                            transferList = [];        \n                        },\n                        err =>\n                        {\n                            postMessageCompat({ type: \"methodError\", callId: msg.callId, value: \"\" + err });\n                            transferList = [];        \n                        });\n                    }\n                    catch (err)\n                    {\n                        postMessageCompat({ type: \"methodError\", callId: msg.callId, value: \"\" + err });\n                        transferList = [];\n                    }\n                }\n                else\n                {\n                    const err = \"No such method to call: \" + msg.name;\n                    postMessageCompat({ type: \"methodError\", callId: msg.callId, value: err });\n                    transferList = [];\n                }\n            }\n        });\n    `;class AtomicInt32{constructor(v){this.buffer=new SharedArrayBuffer(4);this.view=new Int32Array(this.buffer);this.view[0]=v}get value(){return Atomics.load(this.view,0)}set value(v){return Atomics.store(this.view,0,v)}add(v){return Atomics.add(this.view,0,v)}and(v){return Atomics.and(this.view,0,v)}or(v){return Atomics.or(this.view,0,v)}sub(v){return Atomics.sub(this.view,0,v)}}let idCounter=0;const d=new WeakMap;class ThreadPool extends obj.Object{constructor(){super();d.set(this,{size:1,workers:[],queue:[],transferList:[],taskMap:new Map,callMap:new Map,callbackMap:new Map});this.notifyable(\"free\");this.notifyable(\"pending\");this.notifyable(\"size\");this.notifyable(\"waiting\");this.scale(1);this.onDestruction=()=>{const priv=d.get(this);priv.queue=[];priv.workers.forEach(item=>{item.worker.terminate()});priv.workers=[];priv.transferList=[];priv.taskMap.clear();priv.callMap.clear();priv.callbackMap.clear()}}get hardwareConcurrency(){return compat.hardwareConcurrency()}get free(){return d.get(this).workers.filter(item=>item.free).length}get waiting(){return d.get(this).queue.length}get pending(){return d.get(this).workers.filter(item=>!item.free).length}get size(){return d.get(this).size}set size(s){if(s!==d.get(this).size){d.get(this).size=s;this.scale(s);this.sizeChanged()}}transfer(obj){d.get(this).transferList.push(obj);return obj}atomicInt32(v){return new AtomicInt32(v)}scale(n){const priv=d.get(this);priv.workers=priv.workers.sort((a,b)=>!a.free&&b.free?-1:1);while(n<priv.workers.length){const item=priv.workers.pop();item.worker.terminate()}while(n>priv.workers.length){const w=compat.createWorkerThread(WORKER_CODE);const workerItem={worker:w,free:true,ready:false,taskId:-1};compat.addEventListener(w,\"message\",this.safeCallback(ev=>{const msg=compat.extractMessageData(ev);if(msg.type===\"ready\"){workerItem.ready=true;this.checkQueue()}else if(msg.type===\"exit\"){priv.taskMap.get(workerItem.taskId).callbacks.forEach(cbId=>{priv.callbackMap.delete(cbId)});priv.taskMap.delete(workerItem.taskId);workerItem.free=true;workerItem.taskId=-1;this.freeChanged();this.pendingChanged();this.checkQueue()}else if(msg.type===\"methodResult\"){priv.callMap.get(msg.callId).resolve(this.processOutParameters(workerItem.taskId,[msg.value])[0]);priv.callMap.delete(msg.callId)}else if(msg.type===\"methodError\"){priv.callMap.get(msg.callId).reject(msg.value);priv.callMap.delete(msg.callId)}else if(msg.type===\"result\"){priv.taskMap.get(workerItem.taskId).resolve(this.processOutParameters(workerItem.taskId,[msg.value])[0])}else if(msg.type===\"error\"){priv.taskMap.get(workerItem.taskId).reject(msg.value)}else if(msg.type===\"callback\"){const params=this.processOutParameters(workerItem.taskId,msg.parameters);const remove=priv.callbackMap.get(msg.callback)(...params);if(remove){priv.callbackMap.delete(msg.callback)}}}));priv.workers.push(workerItem);shRequire.selfUrl().then(url=>{return compat.fetch(url)}).then(code=>{w.postMessage({type:\"import\",code})}).catch(err=>{console.error(\"Failed to initialize worker: \"+err)})}this.freeChanged()}checkQueue(){const priv=d.get(this);const freeWorkers=priv.workers.filter(item=>item.free);let freeCount=freeWorkers.length;while(freeCount>0&&priv.queue.length>0){const taskId=priv.queue.shift();this.run(taskId);--freeCount;this.waitingChanged()}}run(taskId){const priv=d.get(this);const freeWorkers=priv.workers.filter(item=>item.free&&item.ready);if(freeWorkers.length>0){const taskItem=priv.taskMap.get(taskId);const workerItem=freeWorkers[0];workerItem.taskId=taskId;workerItem.free=false;workerItem.worker.postMessage({type:\"task\",code:taskItem.code,parameters:taskItem.parameters},taskItem.transferList);this.freeChanged();this.pendingChanged()}else{priv.queue.push(taskId);this.waitingChanged()}}call(callId){const priv=d.get(this);const callItem=priv.callMap.get(callId);const workerItem=priv.workers.find(item=>item.taskId===callItem.taskId);if(workerItem){workerItem.worker.postMessage({type:\"call\",name:callItem.name,callId,parameters:callItem.parameters},callItem.transferList)}else{console.error(\"Failed to call \"+callItem.name+\": task \"+callItem.taskId+\" is not available\")}}processInParameters(taskId,parameters){const priv=d.get(this);return parameters.map(p=>{if(typeof p===\"function\"){const callbackId=idCounter;++idCounter;priv.callbackMap.set(callbackId,p);priv.taskMap.get(taskId).callbacks.push(callbackId);return{type:\"callback\",safeCallback:callbackId}}else if(typeof p===\"object\"&&p.constructor.name===\"AtomicInt32\"){return{type:\"atomicInt32\",buffer:p.buffer}}else{return p}})}processOutParameters(taskId,results){const priv=d.get(this);return results.map(r=>{if(!!r&&typeof r===\"object\"&&r.type===\"proxy\"){const proxy={};r.methods.forEach(method=>{proxy[method]=(...parameters)=>{return new Promise((resolve,reject)=>{const params=this.processInParameters(taskId,parameters);const callId=idCounter;++idCounter;priv.callMap.set(callId,{taskId,name:r.instance+\".\"+method,parameters:params,transferList:priv.transferList.slice(),resolve,reject});priv.transferList=[];this.call(callId)})}});return proxy}else{return r}})}createTaskHandle(taskId,promise){const priv=d.get(this);const p={};p.then=cb=>{promise.then(cb);return p};p.catch=cb=>{promise.catch(cb);return p};p.transfer=v=>{return this.transfer(v)};p.atomicInt32=v=>{return this.atomicInt32(v)};p.call=(name,...parameters)=>{return new Promise((resolve,reject)=>{const params=this.processInParameters(taskId,parameters);const callId=idCounter;++idCounter;priv.callMap.set(callId,{taskId,name,parameters:params,transferList:priv.transferList.slice(),resolve,reject});priv.transferList=[];this.call(callId)})};return p}postTask(code,...parameters){const priv=d.get(this);const taskId=idCounter;++idCounter;let resolveCall=null;const callbacks=[];const promise=new Promise((resolve,reject)=>{priv.taskMap.set(taskId,{code,parameters:[],transferList:priv.transferList.slice(),resolve,reject,resolveCall,callbacks});priv.transferList=[];priv.taskMap.get(taskId).parameters=this.processInParameters(taskId,parameters);this.run(taskId)});return this.createTaskHandle(taskId,promise)}postTaskFromSource(url,...parameters){const priv=d.get(this);const taskId=idCounter;++idCounter;let resolveCall=null;const callbacks=[];const promise=new Promise((resolve,reject)=>{compat.fetch(url).then(code=>{priv.taskMap.set(taskId,{code,parameters:[],transferList:priv.transferList.slice(),resolve,reject,resolveCall,callbacks});priv.transferList=[];priv.taskMap.get(taskId).parameters=this.processInParameters(taskId,parameters);this.run(taskId)})});return this.createTaskHandle(taskId,promise)}}exports.ThreadPool=ThreadPool});",
    "core/timer.js": "\"use strict\";shRequire([__dirname+\"/object.js\"],function(obj){const d=new WeakMap;class Timer extends obj.Object{constructor(){super();d.set(this,{running:false,repeat:false,interval:0,currentTimer:null});this.notifyable(\"running\");this.notifyable(\"repeat\");this.notifyable(\"interval\");this.registerEvent(\"timeout\");this.onInitialization=()=>{if(d.get(this).running){this.start()}};this.onDestruction=()=>{this.stop()}}get running(){return d.get(this).running}set running(v){d.get(this).running=v;this.runningChanged();if(v){if(this.lifeCycleStatus===\"initialized\"){this.start()}}else{this.stop()}}get repeat(){return d.get(this).repeat}set repeat(v){d.get(this).repeat=v;this.repeatChanged()}get interval(){return d.get(this).interval}set interval(v){d.get(this).interval=v;this.intervalChanged()}start(){this.stop();const priv=d.get(this);const cb=this.safeCallback(()=>{this.timeout();if(priv.repeat&&priv.running){priv.currentTimer=setTimeout(cb,priv.interval)}else{priv.currentTimer=null}});priv.currentTimer=setTimeout(cb,priv.interval)}stop(){const priv=d.get(this);if(priv.currentTimer){clearTimeout(priv.currentTimer);priv.currentTimer=null}}}exports.Timer=Timer});",
    "core/treemodeladapter.js": "shRequire([__dirname+\"/listmodel.js\"],lm=>{const d=new WeakMap;class TreeModelAdapter extends lm.ListModel{constructor(){super();d.set(this,{levelRole:\"level\",statusRole:\"nodeStatus\",model:null,dynamicContentProvider:null,skipTrees:[],collapseMap:new Map,toListIndexCache:new Map,toTreeIndexCache:new Map,nodesOfInfluence:[]});this.notifyable(\"dynamicContentProvider\");this.notifyable(\"levelRole\");this.notifyable(\"statusRole\");this.notifyable(\"model\");this.onDestruction=()=>{if(d.get(this).model){d.get(this).model.referenceRemove(this)}}}get levelRole(){return d.get(this).levelRole}set levelRole(r){d.get(this).levelRole=r;this.levelRoleChanged()}get dynamicContentProvider(){return d.get(this).dynamicContentProvider}set dynamicContentProvider(p){d.get(this).dynamicContentProvider=p;this.dynamicContentProviderChanged()}get statusRole(){return d.get(this).statusRole}set statusRole(r){d.get(this).statusRole=r;this.statusRoleChanged()}get model(){return d.get(this).model}set model(m){const priv=d.get(this);if(priv.model){priv.model.disconnect(\"modelReset\",this);priv.model.disconnect(\"modelInsert\",this);priv.model.disconnect(\"modelRemove\",this);priv.model.disconnect(\"modelReplace\",this);priv.model.referenceRemove(this)}priv.model=m;if(m){m.referenceAdd(this);m.connect(\"modelReset\",this,()=>{priv.collapseMap.clear();this.updateNodeMaps();this.modelReset();this.sizeChanged()});m.connect(\"modelInsert\",this,(at,size)=>{const collapseKeys=[...priv.collapseMap.keys()].filter(idx=>idx>=at).sort((a,b)=>b-a);collapseKeys.forEach(idx=>{const collapsed=priv.collapseMap.get(idx);priv.collapseMap.set(idx+size,collapsed);priv.collapseMap.delete(idx)});this.updateNodeMaps();const insertionRanges=[];let rangeBegin=-1;let rangeEnd=-1;for(let i=at;i<at+size;++i){const treeIndex=this.toTreeIndex(i);if(treeIndex!==-1){if(rangeBegin===-1){rangeBegin=i}rangeEnd=i}else{if(rangeEnd!==-1){insertionRanges.push([rangeBegin,rangeEnd]);rangeBegin=-1;rangeEnd=-1}}}insertionRanges.forEach(range=>{const[rangeBegin,rangeEnd]=range;this.modelInsert(rangeBegin,rangeEnd-rangeBegin+1)});this.sizeChanged()});m.connect(\"modelRemove\",this,at=>{priv.collapseMap.delete(at);const collapseKeys=[...priv.collapseMap.keys()].filter(idx=>idx>at).sort((a,b)=>a-b);collapseKeys.forEach(idx=>{const collapsed=priv.collapseMap.get(idx);priv.collapseMap.set(idx-1,collapsed);priv.collapseMap.delete(idx)});const treeIdx=this.toTreeIndex(at);this.updateNodeMaps();if(treeIdx!==-1){if(at>0){const prevTreeIdx=this.toTreeIndex(at-1);if(prevTreeIdx!==-1){const prevLevel=priv.model.at(at-1)[priv.levelRole];const level=at>=priv.model.size?prevLevel:priv.model.at(at)[priv.levelRole];if(prevLevel>=level){this.modelReplace(this.toTreeIndex(at-1))}}}this.modelRemove(treeIdx);this.sizeChanged()}});m.connect(\"modelReplace\",this,at=>{const treeIdx=this.toTreeIndex(at);if(treeIdx===-1){return}const isCollapsed=this.isCollapsed(at);const wasCollapsed=at<m.size-1&&m.at(at+1)[priv.levelRole]>m.at(at)[priv.levelRole]?this.toTreeIndex(at+1)===-1:true;if(!isCollapsed&&wasCollapsed){const treeIdx=this.toTreeIndex(at);const nextListIdx=this.toListIndex(treeIdx+1);this.updateNodeMaps();const newNextTreeIdx=this.toTreeIndex(nextListIdx);this.modelReplace(treeIdx);this.modelInsert(treeIdx+1,newNextTreeIdx-(treeIdx+1));this.sizeChanged()}else if(isCollapsed&&!wasCollapsed){const treeIdx=this.toTreeIndex(at);this.updateNodeMaps();const nextListIdx=this.toListIndex(treeIdx+1);this.modelReplace(treeIdx);for(let i=nextListIdx;i>at;--i){this.modelRemove(treeIdx+1)}this.sizeChanged()}else{this.modelReplace(this.toTreeIndex(at))}});this.updateNodeMaps()}}get size(){const priv=d.get(this);let skippedAmount=0;priv.skipTrees.forEach(skipTree=>{const skipWidth=skipTree[1]-skipTree[0]+1;skippedAmount+=skipWidth});return priv.model.size-skippedAmount}setCollapsed(n,value){const priv=d.get(this);const listIdx=this.toListIndex(n);const item=this.model.at(listIdx);if(priv.dynamicContentProvider){if(value){const s=priv.model.size;for(let i=n+1;i<s;++i){if(this.at(n+1).level<=item.level){break}this.remove(n+1)}}else{priv.dynamicContentProvider(n).then(nodes=>{if(nodes.length===0){return}this.bulkInsert(n+1,nodes);priv.collapseMap.set(listIdx,false);priv.model.replace(listIdx,item)}).catch(err=>console.error(err));return}}priv.collapseMap.set(listIdx,value);priv.model.replace(listIdx,item)}isCollapsed(listIdx){const collapsed=d.get(this).collapseMap.get(listIdx);return collapsed!==undefined?collapsed:true}visibleNodes(){const priv=d.get(this);const visibles=[];let pos=0;priv.skipTrees.forEach(item=>{for(let i=pos;i<item[0];++i){visibles.push(i)}pos=item[1]+1});for(let i=pos;i<priv.model.size;++i){visibles.push(i)}return visibles}hasMoreOnLevel(n,level){const priv=d.get(this);const noi=priv.nodesOfInfluence.filter(idx=>idx>n);for(let i=0;i<noi.length;++i){const nodeLevel=priv.model.at(noi[i])[priv.levelRole];if(nodeLevel<level){return false}else if(nodeLevel===level){return true}}return false}updateNodeMaps(){const priv=d.get(this);priv.toListIndexCache.clear();priv.toTreeIndexCache.clear();priv.skipTrees=this.makeSkipTrees(0,priv.model.size-1);priv.nodesOfInfluence=this.makeNodesOfInfluence()}makeSkipTrees(from,to){const priv=d.get(this);const newTrees=[];let collapseLevel=0;let inCollapse=false;let skipBegin=0;let skipEnd=0;for(let i=from;i<=to;++i){const item=priv.model.at(i);const level=item[priv.levelRole];const collapsed=this.isCollapsed(i);if(inCollapse&&level>=collapseLevel){}else if(inCollapse){skipEnd=i-1;if(skipEnd>=skipBegin){newTrees.push([skipBegin,skipEnd,this.makeSkipTrees(skipBegin,skipEnd)])}inCollapse=false}if(!inCollapse&&collapsed){skipBegin=i+1;collapseLevel=level+1;inCollapse=true}else if(!inCollapse){}}if(inCollapse){skipEnd=to;if(skipEnd>=skipBegin){newTrees.push([skipBegin,skipEnd,this.makeSkipTrees(skipBegin,skipEnd)])}}return newTrees}makeNodesOfInfluence(){const priv=d.get(this);const nodesOfInfluence=[];let prevLevel=-1;let prevIdx=-1;let prevNodeOfInfluence=-1;const visibleNodes=this.visibleNodes();visibleNodes.forEach(idx=>{const item=priv.model.at(idx);const level=item[priv.levelRole];if(level!==prevLevel){if(prevIdx!==-1&&prevIdx!==prevNodeOfInfluence){nodesOfInfluence.push(prevIdx)}nodesOfInfluence.push(idx);prevNodeOfInfluence=idx}prevLevel=level;prevIdx=idx});if(prevNodeOfInfluence!==visibleNodes[visibleNodes.length-1]){nodesOfInfluence.push(visibleNodes[visibleNodes.length-1])}return nodesOfInfluence}toListIndex(n){const priv=d.get(this);const fromCache=priv.toListIndexCache.get(n);if(fromCache!==undefined){return fromCache}let pointAt=0;let remaining=n;for(let i=0;i<priv.skipTrees.length;++i){const skipTree=priv.skipTrees[i];const skipBegin=skipTree[0];const skipEnd=skipTree[1];if(pointAt+remaining<skipBegin){priv.toListIndexCache.set(n,pointAt+remaining);return pointAt+remaining}else{remaining-=skipBegin-pointAt;pointAt=skipEnd+1}}priv.toListIndexCache.set(n,pointAt+remaining);return pointAt+remaining}toTreeIndex(n){const priv=d.get(this);const fromCache=priv.toTreeIndexCache.get(n);if(fromCache!==undefined){return fromCache}let skipAmount=0;for(let i=0;i<priv.skipTrees.length;++i){const skipTree=priv.skipTrees[i];const skipBegin=skipTree[0];const skipEnd=skipTree[1];if(n<skipBegin){priv.toTreeIndexCache.set(n,n-skipAmount);return n-skipAmount}else if(n<=skipEnd){priv.toTreeIndexCache.set(n,-1);return-1}else{skipAmount+=skipEnd-skipBegin+1}}priv.toTreeIndexCache.set(n,n-skipAmount);return n-skipAmount}replace(at,item){const listIndex=this.toListIndex(at);d.get(this).model.replace(listIndex,item)}insert(at,data){const priv=d.get(this);let listIdx=0;if(at<this.size){listIdx=this.toListIndex(at)}else{listIdx=priv.model.size}priv.model.insert(listIdx,data)}bulkInsert(at,bulk){const listIdx=this.toListIndex(at);d.get(this).model.bulkInsert(listIdx,bulk)}remove(at){const priv=d.get(this);const listIdx=this.toListIndex(at);const item=priv.model.at(listIdx);const level=item[priv.levelRole];if(this.hasMoreOnLevel(listIdx,level)){priv.model.remove(listIdx)}else{priv.model.remove(listIdx);for(let i=at-1;i>=0;--i){const prevItem=this.at(i);this.modelReplace(i);if(prevItem[priv.levelRole]<=level){break}}}}at(n){const priv=d.get(this);const listIdx=this.toListIndex(n);const item=priv.model.at(listIdx);if(!item){return null}const obj=Object.create(item);const verticals=[];const level=item[priv.levelRole];for(let i=1;i<=level;++i){if(i===level){verticals.push(this.hasMoreOnLevel(listIdx,i)?2:1)}else{verticals.push(this.hasMoreOnLevel(listIdx,i)?2:0)}}obj[priv.statusRole]={collapsed:this.isCollapsed(listIdx),verticals};return obj}}exports.TreeModelAdapter=TreeModelAdapter});",
    "core/util/bezier-easing.js": "exports.__id=\"shellfish/core/bezier\";var NEWTON_ITERATIONS=4;var NEWTON_MIN_SLOPE=0.001;var SUBDIVISION_PRECISION=1e-7;var SUBDIVISION_MAX_ITERATIONS=10;var kSplineTableSize=11;var kSampleStepSize=1/(kSplineTableSize-1);var float32ArraySupported=typeof Float32Array===\"function\";function A(aA1,aA2){return 1-3*aA2+3*aA1}function B(aA1,aA2){return 3*aA2-6*aA1}function C(aA1){return 3*aA1}function calcBezier(aT,aA1,aA2){return((A(aA1,aA2)*aT+B(aA1,aA2))*aT+C(aA1))*aT}function getSlope(aT,aA1,aA2){return 3*A(aA1,aA2)*aT*aT+2*B(aA1,aA2)*aT+C(aA1)}function binarySubdivide(aX,aA,aB,mX1,mX2){var currentX,currentT,i=0;do{currentT=aA+(aB-aA)/2;currentX=calcBezier(currentT,mX1,mX2)-aX;if(currentX>0){aB=currentT}else{aA=currentT}}while(Math.abs(currentX)>SUBDIVISION_PRECISION&&++i<SUBDIVISION_MAX_ITERATIONS);return currentT}function newtonRaphsonIterate(aX,aGuessT,mX1,mX2){for(var i=0;i<NEWTON_ITERATIONS;++i){var currentSlope=getSlope(aGuessT,mX1,mX2);if(currentSlope===0){return aGuessT}var currentX=calcBezier(aGuessT,mX1,mX2)-aX;aGuessT-=currentX/currentSlope}return aGuessT}function LinearEasing(x){return x}exports.bezier=function bezier(mX1,mY1,mX2,mY2){if(!(0<=mX1&&mX1<=1&&0<=mX2&&mX2<=1)){throw new Error(\"bezier x values must be in [0, 1] range\")}if(mX1===mY1&&mX2===mY2){return LinearEasing}var sampleValues=float32ArraySupported?new Float32Array(kSplineTableSize):new Array(kSplineTableSize);for(var i=0;i<kSplineTableSize;++i){sampleValues[i]=calcBezier(i*kSampleStepSize,mX1,mX2)}function getTForX(aX){var intervalStart=0;var currentSample=1;var lastSample=kSplineTableSize-1;for(;currentSample!==lastSample&&sampleValues[currentSample]<=aX;++currentSample){intervalStart+=kSampleStepSize}--currentSample;var dist=(aX-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample]);var guessForT=intervalStart+dist*kSampleStepSize;var initialSlope=getSlope(guessForT,mX1,mX2);if(initialSlope>=NEWTON_MIN_SLOPE){return newtonRaphsonIterate(aX,guessForT,mX1,mX2)}else if(initialSlope===0){return guessForT}else{return binarySubdivide(aX,intervalStart,intervalStart+kSampleStepSize,mX1,mX2)}}return function BezierEasing(x){if(x===0||x===1){return x}return calcBezier(getTForX(x),mY1,mY2)}};",
    "core/util/color.js": "\"use strict\";const COLORS={\"aliceblue\":[240,248,255,1],\"antiquewhite\":[250,235,215,1],\"aqua\":[0,255,255,1],\"aquamarine\":[127,255,212,1],\"azure\":[240,255,255,1],\"beige\":[245,245,220,1],\"bisque\":[255,228,196,1],\"black\":[0,0,0,1],\"blanchedalmond\":[255,235,205,1],\"blue\":[0,0,255,1],\"blueviolet\":[138,43,226,1],\"brown\":[165,42,42,1],\"burlywood\":[222,184,135,1],\"cadetblue\":[95,158,160,1],\"chartreuse\":[127,255,0,1],\"chocolate\":[210,105,30,1],\"coral\":[255,127,80,1],\"cornflowerblue\":[100,149,237,1],\"cornsilk\":[255,248,220,1],\"crimson\":[220,20,60,1],\"cyan\":[0,255,255,1],\"darkblue\":[0,0,139,1],\"darkcyan\":[0,139,139,1],\"darkgoldenrod\":[184,134,11,1],\"darkgray\":[169,169,169,1],\"darkgreen\":[0,100,0,1],\"darkgrey\":[169,169,169,1],\"darkkhaki\":[189,183,107,1],\"darkmagenta\":[139,0,139,1],\"darkolivegreen\":[85,107,47,1],\"darkorange\":[255,140,0,1],\"darkorchid\":[153,50,204,1],\"darkred\":[139,0,0,1],\"darksalmon\":[233,150,122,1],\"darkseagreen\":[143,188,143,1],\"darkslateblue\":[72,61,139,1],\"darkslategray\":[47,79,79,1],\"darkslategrey\":[47,79,79,1],\"darkturquoise\":[0,206,209,1],\"darkviolet\":[148,0,211,1],\"deeppink\":[255,20,147,1],\"deepskyblue\":[0,191,255,1],\"dimgray\":[105,105,105,1],\"dimgrey\":[105,105,105,1],\"dodgerblue\":[30,144,255,1],\"firebrick\":[178,34,34,1],\"floralwhite\":[255,250,240,1],\"forestgreen\":[34,139,34,1],\"fuchsia\":[255,0,255,1],\"gainsboro\":[220,220,220,1],\"ghostwhite\":[248,248,255,1],\"gold\":[255,215,0,1],\"goldenrod\":[218,165,32,1],\"gray\":[128,128,128,1],\"green\":[0,128,0,1],\"greenyellow\":[173,255,47,1],\"grey\":[128,128,128,1],\"honeydew\":[240,255,240,1],\"hotpink\":[255,105,180,1],\"indianred\":[205,92,92,1],\"indigo\":[75,0,130,1],\"ivory\":[255,255,240,1],\"khaki\":[240,230,140,1],\"lavender\":[230,230,250,1],\"lavenderblush\":[255,240,245,1],\"lawngreen\":[124,252,0,1],\"lemonchiffon\":[255,250,205,1],\"lightblue\":[173,216,230,1],\"lightcoral\":[240,128,128,1],\"lightcyan\":[224,255,255,1],\"lightgoldenrodyellow\":[250,250,210,1],\"lightgray\":[211,211,211,1],\"lightgreen\":[144,238,144,1],\"lightgrey\":[211,211,211,1],\"lightpink\":[255,182,193,1],\"lightsalmon\":[255,160,122,1],\"lightseagreen\":[32,178,170,1],\"lightskyblue\":[135,206,250,1],\"lightslategray\":[119,136,153,1],\"lightslategrey\":[119,136,153,1],\"lightsteelblue\":[176,196,222,1],\"lightyellow\":[255,255,224,1],\"lime\":[0,255,0,1],\"limegreen\":[50,205,50,1],\"linen\":[250,240,230,1],\"magenta\":[255,0,255,1],\"maroon\":[128,0,0,1],\"mediumaquamarine\":[102,205,170,1],\"mediumblue\":[0,0,205,1],\"mediumorchid\":[186,85,211,1],\"mediumpurple\":[147,112,219,1],\"mediumseagreen\":[60,179,113,1],\"mediumslateblue\":[123,104,238,1],\"mediumspringgreen\":[0,250,154,1],\"mediumturquoise\":[72,209,204,1],\"mediumvioletred\":[199,21,133,1],\"midnightblue\":[25,25,112,1],\"mintcream\":[245,255,250,1],\"mistyrose\":[255,228,225,1],\"moccasin\":[255,228,181,1],\"navajowhite\":[255,222,173,1],\"navy\":[0,0,128,1],\"oldlace\":[253,245,230,1],\"olive\":[128,128,0,1],\"olivedrab\":[107,142,35,1],\"orange\":[255,165,0,1],\"orangered\":[255,69,0,1],\"orchid\":[218,112,214,1],\"palegoldenrod\":[238,232,170,1],\"palegreen\":[152,251,152,1],\"paleturquoise\":[175,238,238,1],\"palevioletred\":[219,112,147,1],\"papayawhip\":[255,239,213,1],\"peachpuff\":[255,218,185,1],\"peru\":[205,133,63,1],\"pink\":[255,192,203,1],\"plum\":[221,160,221,1],\"powderblue\":[176,224,230,1],\"purple\":[128,0,128,1],\"red\":[255,0,0,1],\"rosybrown\":[188,143,143,1],\"royalblue\":[65,105,225,1],\"saddlebrown\":[139,69,19,1],\"salmon\":[250,128,114,1],\"sandybrown\":[244,164,96,1],\"seagreen\":[46,139,87,1],\"seashell\":[255,245,238,1],\"sienna\":[160,82,45,1],\"silver\":[192,192,192,1],\"skyblue\":[135,206,235,1],\"slateblue\":[106,90,205,1],\"slategray\":[112,128,144,1],\"slategrey\":[112,128,144,1],\"snow\":[255,250,250,1],\"springgreen\":[0,255,127,1],\"steelblue\":[70,130,180,1],\"tan\":[210,180,140,1],\"teal\":[0,128,128,1],\"thistle\":[216,191,216,1],\"tomato\":[255,99,71,1],\"transparent\":[0,0,0,0],\"turquoise\":[64,224,208,1],\"violet\":[238,130,238,1],\"wheat\":[245,222,179,1],\"white\":[255,255,255,1],\"whitesmoke\":[245,245,245,1],\"yellow\":[255,255,0,1],\"yellowgreen\":[154,205,50,1],\"rebeccapurple\":[102,51,153,1]};function saturate(r,g,b,a,factor){const y=0.299*r+0.587*g+0.114*b;const rs=y+(r-y)*factor;const gs=y+(g-y)*factor;const bs=y+(b-y)*factor;return exports.rgba(rs,gs,bs,a)}exports.rgba=function(r,g,b,a){return{r:Math.max(0,Math.min(1,r)),g:Math.max(0,Math.min(1,g)),b:Math.max(0,Math.min(1,b)),a:Math.max(0,Math.min(1,a)),toArray:()=>[r,g,b,a],toCss:()=>`rgba(${r*255|0}, ${g*255|0}, ${b*255|0}, ${a})`,alpha:value=>exports.rgba(r,g,b,value),brightness:factor=>exports.rgba(r*factor,g*factor,b*factor,a),saturation:factor=>saturate(r,g,b,a,factor)}};exports.rgb=function(r,g,b){return exports.rgba(r,g,b,1)};exports.color=function(name){if(name.startsWith(\"#\")){let r=255;let g=255;let b=255;let a=255;if(name.length===9){a=Number.parseInt(name.substr(7,2),16)}else if(name.length===5){a=Number.parseInt(name.substr(4,1)+name.substr(4,1),16)}if(name.length>=7){r=Number.parseInt(name.substr(1,2),16);g=Number.parseInt(name.substr(3,2),16);b=Number.parseInt(name.substr(5,2),16)}else{r=Number.parseInt(name.substr(1,1)+name.substr(1,1),16);g=Number.parseInt(name.substr(2,1)+name.substr(2,1),16);b=Number.parseInt(name.substr(3,1)+name.substr(3,1),16)}return exports.rgba(r/255,g/255,b/255,a/255)}else{const col=COLORS[name.toLowerCase()];if(col){const result=exports.rgba(col[0]/255,col[1]/255,col[2]/255,col[3]);result.toCss=()=>name;return result}else{return exports.rgba(0,0,0,1)}}};exports.colorInterpolate=function(c1,c2,x){return exports.rgba(c1.r+(c2.r-c1.r)*x,c1.g+(c2.g-c1.g)*x,c1.b+(c2.b-c1.b)*x,c1.a+(c2.a-c1.a)*x)};",
    "core/util/compat.js": "\"use strict\";const isWeb=typeof window!==\"undefined\"&&typeof navigator!==\"undefined\";const isNode=typeof process!==\"undefined\"&&typeof process.versions.node!==\"undefined\";const modWorkerThreads=isNode?require(\"worker_threads\"):null;const modFs=isNode?require(\"fs\"):null;const modOs=isNode?require(\"os\"):null;function addEventListener(target,event,callback,options){if(isWeb){target.addEventListener(event,callback,options)}else{target.on(event,callback)}}exports.addEventListener=addEventListener;function fetchCompat(url){if(isWeb){return fetch(url,{cache:\"no-cache\"}).then(response=>{if(response.ok){return response.text()}else{throw\"Failed to read from \"+url}})}else if(isNode){return new Promise((resolve,reject)=>{modFs.readFile(url,(err,data)=>{if(err){reject(err)}else{resolve(data.toString())}})})}}exports.fetch=fetchCompat;function createWorkerThread(code){if(isWeb){const blob=new Blob([code],{type:\"application/javascript\"});const url=URL.createObjectURL(blob);const w=new Worker(url);URL.revokeObjectURL(url);return w}else if(isNode){const w=new modWorkerThreads.Worker(code,{eval:true});return w}}exports.createWorkerThread=createWorkerThread;function extractMessageData(obj){if(isWeb){return obj.data}else{return obj}}exports.extractMessageData=extractMessageData;function hardwareConcurrency(){if(isWeb){return navigator.hardwareConcurrency||1}else if(isNode){return modOs.cpus().length}}exports.hardwareConcurrency=hardwareConcurrency;",
    "core/util/compression.js": "function condense(s){const phrases=[\"                \",\"            \",\"        \",\"    \",\"shellfish/core\",\"shellfish/declarative\",\"shellfish/low\",\"shellfish/ui\",\"shellfish/fengshui\",\"\\\"use strict\\\";\",\"fengshui_Internal.compile\",\"fengshui_Internal.tools.rslv\",\"fengshui_Internal.tools\",\"fengshui_Internal\",\"__xsdv__\",\"__rslv__\",\"__rslvCache__\",\"__pRslv__\",\"__FakeDV__\",\"functor\",\"...args\",\"theme.\",\"alias\",\"modelData\",\"__filename\",\"__dirname\",\"__namespace\",\"declarative.binding\",\"declarative.chainRef\",\"declarative\",\"core.dbgctx=\",\"addProperty\",\"add\",\"disconnect\",\"connect\",\"elementLookup\",\"objectLocation\",\"objectType\",\"objectId\",\"async\",\"await\",\"break\",\"catch\",\"Changed\",\"class\",\"constructor\",\"const\",\"continue\",\"d.get(this).\",\"do\",\"else\",\"exports.\",\"extends\",\"false\",\"filter\",\"finally\",\"forEach\",\"for\",\"function\",\"get\",\"has\",\"let\",\"log\",\"Math\",\"map\",\"new\",\"notifyable\",\"if\",\"null\",\"push\",\"parent\",\"priv\",\"Promise\",\"property\",\"registerEvent\",\"reject\",\"resolve\",\"return\",\"root\",\"shRequire\",\"self\",\"set\",\"status\",\"substring\",\"super\",\"switch\",\"this\",\"throw\",\"true\",\"try\",\"typeof\",\"undefined\",\"until\",\"use\",\"val\",\"var\",\"WeakMap\",\"while\",\"console.log\",\"console.error\",\"onInitialization\",\"onDestruction\",\"low.createElementTree\",\"Object\",\"Box\",\"MouseBox\",\"Timer\",\"Label\",\"fqElementName\",\"isDynamicValue\",\"primaryColor\",\"secondaryColor\",\"primaryBackgroundColor\",\"secondaryBackgroundColor\",\"highlightColor\",\"highlightBackgroundColor\",\"contentBackgroundColor\",\"contentAltBackgroundColor\",\"itemWidthSmall\",\"itemWidthMedium\",\"itemWidthLarge\",\"itemHeightSmall\",\"itemHeightMedium\",\"itemHeightLarge\",\"paddingSmall\",\"paddingMedium\",\"paddingLarge\",\"fontSizeSmall\",\"fontSizeMedium\",\"fontSizeLarge\",\"marginTop\",\"marginLeft\",\"marginRight\",\"marginBottom\",\"fillWidth\",\"fillHeight\",\"width\",\"height\"].sort((a,b)=>a<b?-1:1).sort((a,b)=>b.length-a.length);console.log(\"PHRASES: \"+phrases.length);[\"@\"].concat(phrases).forEach((kw,idx)=>{const hex=idx.toString(16);const token=\"@\"+(hex.length===1?\"0\"+hex:hex);s=s.replace(new RegExp(kw.replace(/\\./g,\"\\\\.\"),\"g\"),token)});return s}function uncondense(s){const phrases=[\"                \",\"            \",\"        \",\"    \",\"shellfish/core\",\"shellfish/declarative\",\"shellfish/low\",\"shellfish/ui\",\"shellfish/fengshui\",\"\\\"use strict\\\";\",\"fengshui_Internal.compile\",\"fengshui_Internal.tools.rslv\",\"fengshui_Internal.tools\",\"fengshui_Internal\",\"__xsdv__\",\"__rslv__\",\"__rslvCache__\",\"__pRslv__\",\"__FakeDV__\",\"functor\",\"...args\",\"theme.\",\"alias\",\"modelData\",\"__filename\",\"__dirname\",\"__namespace\",\"declarative.binding\",\"declarative.chainRef\",\"declarative\",\"core.dbgctx=\",\"addProperty\",\"add\",\"disconnect\",\"connect\",\"elementLookup\",\"objectLocation\",\"objectType\",\"objectId\",\"async\",\"await\",\"break\",\"catch\",\"Changed\",\"class\",\"constructor\",\"const\",\"continue\",\"d.get(this).\",\"do\",\"else\",\"exports.\",\"extends\",\"false\",\"filter\",\"finally\",\"forEach\",\"for\",\"function\",\"get\",\"has\",\"let\",\"log\",\"Math\",\"map\",\"new\",\"notifyable\",\"if\",\"null\",\"push\",\"parent\",\"priv\",\"Promise\",\"property\",\"registerEvent\",\"reject\",\"resolve\",\"return\",\"root\",\"shRequire\",\"self\",\"set\",\"status\",\"substring\",\"super\",\"switch\",\"this\",\"throw\",\"true\",\"try\",\"typeof\",\"undefined\",\"until\",\"use\",\"val\",\"var\",\"WeakMap\",\"while\",\"console.log\",\"console.error\",\"onInitialization\",\"onDestruction\",\"low.createElementTree\",\"Object\",\"Box\",\"MouseBox\",\"Timer\",\"Label\",\"fqElementName\",\"isDynamicValue\",\"primaryColor\",\"secondaryColor\",\"primaryBackgroundColor\",\"secondaryBackgroundColor\",\"highlightColor\",\"highlightBackgroundColor\",\"contentBackgroundColor\",\"contentAltBackgroundColor\",\"itemWidthSmall\",\"itemWidthMedium\",\"itemWidthLarge\",\"itemHeightSmall\",\"itemHeightMedium\",\"itemHeightLarge\",\"paddingSmall\",\"paddingMedium\",\"paddingLarge\",\"fontSizeSmall\",\"fontSizeMedium\",\"fontSizeLarge\",\"marginTop\",\"marginLeft\",\"marginRight\",\"marginBottom\",\"fillWidth\",\"fillHeight\",\"width\",\"height\"].sort((a,b)=>b<a?-1:1).sort((a,b)=>a.length-b.length);phrases.concat([\"@\"]).forEach((kw,idx)=>{const hex=(phrases.length-idx).toString(16);const token=\"@\"+(hex.length===1?\"0\"+hex:hex);s=s.replace(new RegExp(token,\"g\"),kw)});return s}function gzipCompress(s){const modChildProcess=require(\"node:child_process\");const buffer=modChildProcess.spawnSync(\"gzip\",[],{input:s});return Buffer.from(buffer.stdout).toString(\"base64\")}function gzipUncompress(s){const buffer=new Uint8Array(Buffer.from(s,\"base64\"));const modChildProcess=require(\"node:child_process\");const result=modChildProcess.spawnSync(\"gzip\",[\"-d\"],{input:buffer});return new TextDecoder().decode(result.stdout)}function huffmanCompress(s){const buffer=new TextEncoder().encode(s);const frequencies=new Map;for(let i=0;i<buffer.length;++i){const byte=buffer[i];const count=frequencies.get(byte);if(!count){frequencies.set(byte,1)}else{frequencies.set(byte,count+1)}}const queue=[...frequencies];while(queue.length>1){queue.sort((a,b)=>a[1]-b[1]);const node1=queue.shift();const node2=queue.shift();const node=[[node1,node2],node1[1]+node2[1]];queue.push(node)}const table=new Map;const descend=(node,path)=>{if(Array.isArray(node[0])){descend(node[0][0],path.concat(0));descend(node[0][1],path.concat(1))}else{table.set(node[0],path)}};descend(queue[0],[]);const bitSize=[...table].reduce((size,entry)=>size+frequencies.get(entry[0])*entry[1].length,0);const bits=new Uint8Array(Math.ceil(bitSize/8));const setBit=(n,v)=>{const pos=Math.floor(n/8);const byte=bits[pos];const offset=n%8;if(v===0){bits[pos]&=~(1<<offset)}else{bits[pos]|=1<<offset}};let offset=0;for(let i=0;i<buffer.length;++i){const code=table.get(buffer[i]);code.forEach(bit=>{setBit(offset,bit);++offset})}const lookupTable=new TextEncoder().encode(JSON.stringify(queue[0]));const resultBuffer=new Uint8Array(4+4+4+lookupTable.length+bits.length);const view32=new Uint32Array(resultBuffer.buffer,0,3);view32[0]=lookupTable.length;view32[1]=buffer.length;view32[2]=bitSize;resultBuffer.set(lookupTable,12);resultBuffer.set(bits,12+lookupTable.length);return Buffer.from(resultBuffer).toString(\"base64\")}function huffmanUncompress(s){const buffer=new Uint8Array(Buffer.from(s,\"base64\"));const view32=new Uint32Array(buffer.buffer,0,3);console.log(view32);const lookupTableLength=view32[0];const originalSize=view32[1];const bitSize=view32[2];console.log(\"compressed \"+Math.ceil(bitSize/8)+\" -> \"+originalSize+\" bytes\");const lookupTableData=buffer.slice(12,12+lookupTableLength);const tree=JSON.parse(new TextDecoder().decode(lookupTableData));const bits=buffer.slice(12+lookupTableLength);const getBit=n=>{const pos=Math.floor(n/8);const offset=n%8;return(bits[pos]&1<<offset)!==0};let result=new Uint8Array(originalSize);let offset=0;let node=tree;console.log(node);for(let i=0;i<bitSize;++i){if(Array.isArray(node[0])){if(getBit(i)){node=node[0][1]}else{node=node[0][0]}}if(!Array.isArray(node[0])){result[offset]=node[0];node=tree;++offset}}return new TextDecoder().decode(result)}",
    "core/util/matrix.js": "\"use strict\";exports.__id=\"shellfish/core/matrix\";const DEG_TO_RAD=Math.PI/180;exports.PLUS=(a,b)=>a+b;exports.MINUS=(a,b)=>a-b;exports.MULTIPLY=(a,b)=>a*b;function shape(m){const rows=m.length;const cols=m[0].length;return{rows,cols}}exports.shape=shape;function elementWise(m,n,op){const s=exports.shape(m);const result=exports.mat(s.rows,s.cols);for(let r=0;r<s.rows;++r){for(let c=0;c<s.cols;++c){result[r][c]=op(m[r][c],n)}}return result}exports.elementWise=elementWise;function vec(...values){return values.map(a=>[a])}exports.vec=vec;function mat(rows,cols){const m=[];for(let r=0;r<rows;++r){const mRow=[];m.push(mRow);for(let c=0;c<cols;++c){mRow.push(0)}}return m}exports.mat=mat;function fromArray(arr,cols){const m=[];let row=[];m.push(row);for(let i=0;i<arr.length;++i){row.push(arr[i]);if(row.length===cols&&i<arr.length-1){row=[];m.push(row)}}return m}exports.fromArray=fromArray;function flat(m){const result=[];const s=exports.shape(m);for(let row=0;row<s.rows;++row){for(let col=0;col<s.cols;++col){result.push(m[row][col])}}return result}exports.flat=flat;function length(v){const s=exports.shape(v);if(s.cols!==1){throw\"Error: length is only defined for vectors\"}return Math.sqrt(v.reduce((a,b)=>a+b[0]*b[0],0))}exports.length=length;function t(m){const s=exports.shape(m);const t=exports.mat(s.cols,s.rows);for(let row=0;row<s.rows;++row){for(let col=0;col<s.cols;++col){t[col][row]=m[row][col]}}return t}exports.t=t;function add(a,b){if(typeof b===\"number\"){return exports.elementWise(a,b,exports.PLUS)}const s1=exports.shape(a);const s2=exports.shape(b);const m=exports.mat(s1.rows,s1.cols);if(s1.rows!==s2.rows||s1.cols!==s2.cols){throw\"Error: m1 and m2 must have the same dimension for addition/subtraction\"}for(let row=0;row<s1.rows;++row){for(let col=0;col<s1.cols;++col){m[row][col]=a[row][col]+b[row][col]}}return m}exports.add=add;function sub(a,b){return exports.add(a,exports.mul(b,-1))}exports.sub=sub;function dot(u,v){const s1=exports.shape(u);const s2=exports.shape(v);if(s1.cols!==1||s2.cols!==1||s1.rows!==s2.rows){throw\"Error: u and v must be column-vectors with the same dimensions for the dot product\"}let result=0;for(let i=0;i<s1.rows;++i){result+=u[i][0]*v[i][0]}return result}exports.dot=dot;function mul(a,b){if(typeof b===\"number\"){return exports.elementWise(a,b,exports.MULTIPLY)}const s1=exports.shape(a);const s2=exports.shape(b);const m=exports.mat(s1.rows,s2.cols);if(s1.cols!==s2.rows){throw\"Error: amount of m1's columns must match m2's amount of rows for multiplication\"}for(let row=0;row<s1.rows;++row){for(let col=0;col<s2.cols;++col){m[row][col]=0;for(let i=0;i<s1.cols;++i){m[row][col]+=a[row][i]*b[i][col]}}}return m}exports.mul=mul;function minor(m,row,col){const s=exports.shape(m);const result=exports.mat(s.rows-1,s.cols-1);for(let r=0;r<s.rows-1;++r){for(let c=0;c<s.cols-1;++c){result[r][c]=m[r<row?r:r+1][c<col?c:c+1]}}return result}exports.minor=minor;function det(m){const s=exports.shape(m);if(s.cols!==s.rows){throw\"Error: the determinant is only defined for square matrices\"}if(s.rows===2){return m[0][0]*m[1][1]-m[0][1]*m[1][0]}let result=0;for(let i=0;i<s.rows;++i){result+=Math.pow(-1,i)*m[0][i]*exports.det(exports.minor(m,0,i))}return result}exports.det=det;function inv(m){const mDet=exports.det(m);if(mDet===0){throw\"Error: the matrix \"+JSON.stringify(m)+\" has no inverse\"}const s=exports.shape(m);if(s.cols!==s.rows){throw\"Error: only square matrices may be inverted\"}if(s.rows===2){return[[m[1][1]/mDet,-m[0][1]/mDet],[-m[1][0]/mDet,m[0][0]/mDet]]}let result=exports.mat(s.rows,s.cols);for(let r=0;r<s.rows;++r){for(let c=0;c<s.cols;++c){const minor=exports.minor(m,r,c);result[r][c]=Math.pow(-1,r+c)*exports.det(minor)}}result=exports.t(result);for(let r=0;r<s.rows;++r){for(let c=0;c<s.cols;++c){result[r][c]/=mDet}}return result}exports.inv=inv;function identityM(dim){const m=[];for(let r=0;r<dim;++r){const mRow=[];m.push(mRow);for(let c=0;c<dim;++c){mRow.push(r===c?1:0)}}return m}exports.identityM=identityM;function translationM(vec){const dim=exports.shape(vec).rows;const m=exports.identityM(dim+1);for(let r=0;r<dim;++r){m[r][dim]=vec[r][0]}return m}exports.translationM=translationM;function rotationM(u,v,angle){const dim=exports.shape(u).rows;const rad=angle*DEG_TO_RAD;const c=Math.cos(rad);const s=Math.sin(rad);const ut=exports.t(u);const vt=exports.t(v);const a=exports.mul(exports.add(exports.mul(v,ut),exports.mul(exports.mul(u,vt),-1)),s);const b=exports.mul(exports.add(exports.mul(u,ut),exports.mul(v,vt)),c-1);const m=exports.add(exports.identityM(dim),exports.add(a,b));return m}exports.rotationM=rotationM;function scalingM(vec){const dim=exports.shape(vec).rows;const m=exports.identityM(dim);for(let r=0;r<dim;++r){m[r][r]=vec[r][0]}return m}exports.scalingM=scalingM;function rotationMByQuaternion(q){const qw=q[0];const qx=q[1];const qy=q[2];const qz=q[3];const qx2=qx*qx;const qy2=qy*qy;const qz2=qz*qz;return[[1-2*qy2-2*qz2,2*qx*qy-2*qz*qw,2*qx*qz+2*qy*qw,0],[2*qx*qy+2*qz*qw,1-2*qx2-2*qz2,2*qy*qz-2*qx*qw,0],[2*qx*qz-2*qy*qw,2*qy*qz+2*qx*qw,1-2*qx2-2*qy2,0],[0,0,0,1]]}exports.rotationMByQuaternion=rotationMByQuaternion;function perspectiveM(distance){return[[1,0,0,0],[0,1,0,0],[0,0,1,distance>0?-1/distance:0],[0,0,0,1]]}exports.perspectiveM=perspectiveM;",
    "core/util/mime.js": "\"use strict\";exports.__id=\"shellfish/core/mime\";const EXTENSIONS={\".7z\":\"application/x-7z-compressed\",\".apk\":\"application/java-archive\",\".avi\":\"video/x-msvideo\",\".bat\":\"application/x-batch\",\".c\":\"text/plain\",\".cbr\":\"application/x-rar-compressed\",\".cbz\":\"application/zip\",\".cc\":\"text/plain\",\".cpp\":\"text/plain\",\".css\":\"text/css\",\".exe\":\"application/x-executable\",\".flac\":\"audio/flac\",\".flv\":\"video/x-flv\",\".gif\":\"image/gif\",\".gz\":\"application/gzip\",\".h\":\"text/plain\",\".hpp\":\"text/plain\",\".htm\":\"text/html\",\".html\":\"text/html\",\".ini\":\"text/plain\",\".iso\":\"application/x-iso9660-image\",\".jar\":\"application/java-archive\",\".jpeg\":\"image/jpeg\",\".jpg\":\"image/jpeg\",\".js\":\"text/javascript\",\".json\":\"application/x-json\",\".m4v\":\"video/mp4\",\".md\":\"text/x-markdown\",\".mkv\":\"video/x-matroska\",\".mp3\":\"audio/mp3\",\".mp4\":\"video/mp4\",\".mpeg\":\"video/mpeg\",\".mpg\":\"video/mpeg\",\".odt\":\"application/vnd.oasis.opendocument.text\",\".ogg\":\"audio/ogg\",\".pdf\":\"application/pdf\",\".png\":\"image/png\",\".pro\":\"text/plain\",\".py\":\"application/x-python\",\".qml\":\"application/x-qml\",\".rar\":\"application/x-rar-compressed\",\".rtf\":\"text/rtf\",\".sh\":\"application/x-shellscript\",\".shui\":\"text/plain\",\".svg\":\"image/svg+xml\",\".txt\":\"text/plain\",\".tgz\":\"application/gzip\",\".vcf\":\"text/vcard\",\".vtt\":\"text/vtt\",\".wasm\":\"application/wasm\",\".webm\":\"video/webm\",\".webp\":\"image/webp\",\".xml\":\"text/xml\",\".zip\":\"application/zip\"};const NAMES={\"ChangeLog\":\"text/plain\",\"INSTALL\":\"text/plain\",\"LICENSE\":\"text/plain\",\"Makefile\":\"text/plain\",\"NEWS\":\"text/plain\",\"README\":\"text/plain\"};exports.mimeType=function(path){var idx=path.lastIndexOf(\"/\");var name=idx!==-1?path.substr(idx+1):path;idx=path.lastIndexOf(\".\");var ext=idx!==-1?path.substr(idx):\"\";return EXTENSIONS[ext.toLowerCase()]||NAMES[name]||\"application/octet-stream\"};",
    "core/util/vec.js": "\"use strict\";exports.__id=\"shellfish/core/vector\";exports.vec2=function(x,y){return{x,y,length:function(){return vec2Length(this)},scale:function(s){return vec2Scale(this,s)},add:function(other){return vec2Add(this,other)},subtract:function(other){return vec2Subtract(this,other)}}};function vec2Length(v){return Math.sqrt(v.x*v.x+v.y*v.y)}function vec2Scale(v,s){return exports.vec2(v.x*s,v.y*s)}function vec2Add(v1,v2){return exports.vec2(v1.x+v2.x,v1.y+v2.y)}function vec2Subtract(v1,v2){return exports.vec2(v1.x-v2.x,v1.y-v2.y)}exports.vec2Interpolate=function(v1,v2,x){return v1.add(v2.subtract(v1).scale(x))};exports.vec3=function(x,y,z){return{x,y,z,length:function(){return vec3Length(this)},scale:function(s){return vec3Scale(this,s)},add:function(other){return vec3Add(this,other)},subtract:function(other){return vec3Subtract(this,other)}}};function vec3Length(v){return Math.sqrt(v.x*v.x+v.y*v.y+v.z*v.z)}function vec3Scale(v,s){return exports.vec3(v.x*s,v.y*s,v.z*s)}function vec3Add(v1,v2){return exports.vec3(v1.x+v2.x,v1.y+v2.y,v1.z+v2.z)}function vec3Subtract(v1,v2){return exports.vec3(v1.x-v2.x,v1.y-v2.y,v1.z-v2.z)}exports.vec3Interpolate=function(v1,v2,x){return v1.add(v2.subtract(v1).scale(x))};",
    "core/util/warehouse.js": "\"use strict\";exports.__id=\"shellfish/core/warehouse\";class Warehouse{constructor(factoryFunction,capacity){this.factoryFunction=factoryFunction;this.capacity=capacity;this.storage=new Map;this.inProduction=new Map}clear(type){this.storage.set(type,[])}retrieve(type){if(!this.storage.has(type)){this.storage.set(type,[]);this.inProduction.set(type,false)}const stock=this.storage.get(type);if(stock.length===0){this.produce(type)}if(stock.length<this.capacity&&!this.inProduction.get(type)){this.inProduction.set(type,true);setTimeout(()=>{this.fillStock(type)},30)}return stock.pop()}produce(type){const item=this.factoryFunction(type);this.storage.get(type).push(item)}fillStock(type){const stock=this.storage.get(type);if(stock.length<this.capacity){this.produce(type);setTimeout(()=>{this.fillStock(type)},30)}else{this.inProduction.set(type,false)}}}exports.Warehouse=Warehouse;",
    "core/util/xmlsax.js": "\"use strict\";exports.__id=\"shellfish/core/xmlsax\";class Parser{constructor(handler){this.handler=handler}throwError(pos,description){throw{\"pos\":pos,\"description\":description}}parseString(data){try{this.parseDocument(data,0)}catch(err){this.handler.error(err.pos,err.description)}}eatWhitespace(data,pos){while(pos<data.length&&\" \\n\\r\\t\".indexOf(data[pos])!==-1){++pos}return pos}accept(data,pos,s){if(pos>=data.length||data.substring(pos,pos+s.length)!==s){this.throwError(pos,s+\" expected: \"+data.substring(pos,pos+16))}return pos+s.length}parseDocument(data,pos){pos=this.eatWhitespace(data,pos);if(pos<data.length&&data.substring(pos,pos+2)===\"<?\"){pos=this.parseHeader(data,pos)}pos=this.eatWhitespace(data,pos);while(pos<data.length){if(data.substring(pos,pos+4)===\"<!--\"){pos=this.parseComment(data,pos)}else if(data.substring(pos,pos+8)===\"<![CDATA[\"){pos=this.parseCData(data,pos)}else if(data[pos]===\"<\"){pos=this.parseTag(data,pos)}else{pos=this.parsePCData(data,pos)}pos=this.eatWhitespace(data,pos)}this.handler.end()}parseHeader(data,pos){pos=this.accept(data,pos,\"<?\");pos=this.eatWhitespace(data,pos);let res=this.parseName(data,pos);const name=res.name;pos=res.pos;pos=this.eatWhitespace(data,pos);while(pos<data.length&&data.substring(pos,pos+2)!==\"?>\"){res=this.parseAttribute(data,pos);const attrName=res.name;const attrValue=res.value;pos=res.pos;pos=this.eatWhitespace(data,pos)}pos=this.accept(data,pos,\"?>\");return pos}parseTag(data,pos){let isOpening=true;let isClosing=false;pos=this.accept(data,pos,\"<\");if(pos<data.length&&data[pos]===\"/\"){pos=this.accept(data,pos,\"/\");isOpening=false;isClosing=true}pos=this.eatWhitespace(data,pos);let res=this.parseName(data,pos);const name=res.name;pos=res.pos;pos=this.eatWhitespace(data,pos);const attrs={};while(pos<data.length&&data[pos]!==\"/\"&&data[pos]!==\">\"){res=this.parseAttribute(data,pos);const attrName=res.name;const attrValue=res.value;attrs[attrName]=attrValue;pos=res.pos;pos=this.eatWhitespace(data,pos)}if(data[pos]===\"/\"){pos=this.accept(data,pos,\"/\");isClosing=true}pos=this.eatWhitespace(data,pos);pos=this.accept(data,pos,\">\");this.handler.tag(name,attrs,isOpening,isClosing);return pos}parseComment(data,pos){pos=this.accept(data,pos,\"<!--\");let comment=\"\";while(pos<data.length&&data.substring(pos,pos+3)!==\"-->\"){comment+=data[pos];++pos}pos=this.accept(data,pos,\"-->\");this.handler.comment(comment);return pos}parseCData(data,pos){pos=this.accept(data,pos,\"<![CDATA[\");let cdata=\"\";while(pos<data.length&&data.substring(pos,pos+3)!==\"]]>\"){cdata+=data[pos];++pos}pos=this.accept(data,pos,\"]]>\");this.handler.cdata(cdata);return pos}parsePCData(data,pos){let pcdata=\"\";while(pos<data.length&&data[pos]!==\"<\"){pcdata+=data[pos];++pos}this.handler.pcdata(pcdata);return pos}parseName(data,pos){let name=\"\";while(pos<data.length&&data[pos].match(/[a-zA-Z0-9:]/)){name+=data[pos];++pos}if(name===\"\"){this.throwError(pos,\"unexpected character\")}return{\"name\":name,\"pos\":pos}}parseAttribute(data,pos){let res=this.parseName(data,pos);const name=res.name;let value=null;pos=res.pos;pos=this.eatWhitespace(data,pos);if(pos<data.length&&data[pos]===\"=\"){pos=this.accept(data,pos,\"=\");pos=this.eatWhitespace(data,pos);res=this.parseValue(data,pos);value=res.value;pos=res.pos}return{\"name\":name,\"value\":value,\"pos\":pos}}parseValue(data,pos){let value=\"\";if(data[pos]===\"'\"){pos=this.accept(data,pos,\"'\");while(pos<data.length&&data[pos]!==\"'\"){value+=data[pos];++pos}pos=this.accept(data,pos,\"'\")}else if(data[pos]===\"\\\"\"){pos=this.accept(data,pos,\"\\\"\");while(pos<data.length&&data[pos]!==\"\\\"\"){value+=data[pos];++pos}pos=this.accept(data,pos,\"\\\"\")}else{while(pos<data.length&&data[pos].match(/^[ \\r\\n\\t/>]/)){value+=data[pos];++pos}}return{\"value\":value,\"pos\":pos}}}exports.Parser=Parser;class Handler{constructor(){this.xmlDocument=null;this.stack=[]}resolveNamespace(name,attrs){let ns=\"\";if(name.indexOf(\":\")!==-1){const parts=name.split(\":\");ns=parts[0];name=parts[1]}if(ns===\"\"&&attrs[\"xmlns\"]){return attrs[\"xmlns\"]+\":\"+name}else if(attrs[\"xmlns:\"+ns]){return attrs[\"xmlns:\"+ns]+\":\"+name}for(let i=this.stack.length-1;i>=0;--i){if(ns===\"\"&&this.stack[i].attributes[\"xmlns\"]){return this.stack[i].attributes[\"xmlns\"]+\":\"+name}else if(this.stack[i].attributes[\"xmlns:\"+ns]){return this.stack[i].attributes[\"xmlns:\"+ns]+\":\"+name}}return name}tag(name,attrs,isOpening,isClosing){const resolvedAttrs={};for(let key in attrs){if(attrs.hasOwnProperty(key)){if(key.indexOf(\"xmlns\")===0){resolvedAttrs[key]=attrs[key]}else{resolvedAttrs[this.resolveNamespace(key,attrs)]=attrs[key]}}}const tagObj={\"type\":\"tag\",\"name\":this.resolveNamespace(name,attrs),\"attributes\":resolvedAttrs,\"children\":[]};if(this.xmlDocument===null){this.xmlDocument=tagObj;this.stack.push(tagObj)}else{if(isOpening){const parent=this.stack[this.stack.length-1];parent.children.push(tagObj);this.stack.push(tagObj)}if(isClosing){const current=this.stack[this.stack.length-1];if(tagObj.name===current.name){this.stack.pop()}else{console.error(\"nesting error: \"+tagObj.name)}}}}pcdata(pcdata){const obj={\"type\":\"pcdata\",\"data\":pcdata};const parent=this.stack[this.stack.length-1];parent.children.push(obj)}cdata(cdata){const obj={\"type\":\"cdata\",\"data\":cdata};const parent=this.stack[this.stack.length-1];parent.children.push(obj)}comment(comment){}end(){}error(pos,description){console.error(\"Parse error at position \"+pos+\": \"+description);this.xmlDocument=null}document(){return this.xmlDocument}}exports.Handler=Handler;",
    "core/waitaction.js": "shRequire([__dirname+\"/action.js\"],act=>{const d=new WeakMap;class WaitAction extends act.Action{constructor(){super();d.set(this,{until:null});this.notifyable(\"until\");this.onStatusChanged=()=>{if(this.status===\"stopping\"){this.abortWait(\"wait\")}};this.onEnabledChanged=()=>{if(!this.enabled){this.stop()}}}get until(){return d.get(this).until}set until(f){d.get(this).until=f;this.untilChanged()}seconds(n){return now=>now+n*1000}atSecond(n){return now=>{const base=now-now%(60*1000);let target=base+n*1000;if(target<now){target+=60*1000}return target}}atMinute(n){return now=>{const base=now-now%(3600*1000);let target=base+n*60*1000;if(target<now){target+=3600*1000}return target}}atUtcHour(n){return now=>{const base=now-now%(24*3600*1000);let target=base+n*3600*1000;if(target<now){target+=24*3600*1000}return target}}start(){this.wait(0).then(async()=>{if(this.enabled){if(d.get(this).until){const now=Date.now();const waitUntil=d.get(this).until(now);const diff=Math.max(0,waitUntil-now);await this.wait(diff,\"wait\")}else{while(this.status===\"running\"){await this.wait(1000*3600*24*365*100,\"wait\")}}}if(this.lifeCycleStatus!==\"destroyed\"){this.finish()}});return super.start()}}exports.WaitAction=WaitAction});",
    "core/wasm.js": "\"use strict\";shRequire([__dirname+\"/object.js\"],obj=>{const d=new WeakMap;class Wasm extends obj.Object{constructor(){super();d.set(this,{canvas:null,source:\"\",instance:null});this.notifyable(\"canvas\");this.notifyable(\"source\");this.notifyable(\"instance\");this.registerEvent(\"ready\")}get canvas(){return d.get(this).canvas}set canvas(cnv){d.get(this).canvas=cnv;cnv.get().id=\"canvas\";this.canvasChanged()}get source(){return d.get(this).source}set source(s){d.get(this).source=s;this.sourceChanged()}get instance(){return d.get(this).instance}vectorToArrayBuffer(vec,del){const priv=d.get(this);const buffer=new ArrayBuffer(vec.size());new Uint8Array(buffer).set(new Uint8Array(priv.instance.HEAP8.buffer,vec.data(),vec.size()));if(del){vec.delete()}return buffer}load(){const priv=d.get(this);const wasmUrl=priv.source;const runtimeUrl=wasmUrl.replace(/\\.wasm$/i,\".js\");const pos=wasmUrl.lastIndexOf(\"/\");const wasmDirectory=pos>0?wasmUrl.substr(0,pos):wasmUrl;function processor(u,code){return`\n                    exports.init = (Module) =>\n                    {\n                        ${code}\n                        return Module;\n                    };\n                `}shRequire([shRequire.resource(runtimeUrl)],mod=>{let runTime=null;const Module={mainScriptUrlOrBlob:runtimeUrl,canvas:priv.canvas?priv.canvas.get():null,locateFile:(path,scriptDirectory)=>{return wasmDirectory+\"/\"+path},onRuntimeInitialized:()=>{priv.instance=runTime;this.instanceChanged();this.ready()}};runTime=mod.init(Module)},processor)}}exports.Wasm=Wasm});",
    "core.js": "\"use strict\";exports.__id=\"shellfish/core\";exports.SHELLFISH_BUILD=\"76f0db5-2024-01-04T09:54:54.290Z\";const mods=[\"fengshui\",\"declarative\",\"core/util/compat\",\"core/util/matrix\",\"core/util/mime\",\"core/util/vec\",\"core/util/warehouse\",\"core/util/xmlsax\"];const includes=[\"action\",\"filefs\",\"filestorage\",\"filesystem\",\"fsmodel\",\"inertialengine\",\"listmodel\",\"object\",\"parallelaction\",\"registryfile\",\"registryoverlay\",\"repeater\",\"rpcproxy\",\"scalemodel\",\"scriptaction\",\"sequentialaction\",\"threadpool\",\"timer\",\"treemodeladapter\",\"waitaction\"];shRequire(mods.map(m=>__dirname+\"/\"+m+\".js\"),()=>{shRequire(includes.map(m=>__dirname+\"/core/\"+m+\".js\"),(...args)=>{args.forEach(a=>exports.include(a))})});",
    "declarative.js": "\"use strict\";exports.__id=\"shellfish/declarative\";shRequire([\"shellfish/core\",\"shellfish/core/warehouse\"],function(core,warehouse){let dvCounter=0;let totalWatchCount=0;const elementRegistry=new Map;const elementWarehouse=new warehouse.Warehouse(type=>{return new Element(type)},0);function isDynamicValue(v){return v instanceof DynamicValue}exports.isDynamicValue=isDynamicValue;let d=new WeakMap;const propertiesCache=new Map;function allKeys(obj){let keys=Object.getOwnPropertyNames(obj).filter(n=>n!==\"constructor\");keys=keys.concat(obj.customProperties());const proto=Object.getPrototypeOf(obj);if(!proto.hasOwnProperty(\"customProperties\")){keys=keys.concat(allKeys(proto))}return keys}class Element{constructor(type){this._sh_element=true;d.set(this,{element:null,id:{},elementType:{},changeWatchers:[],propertySupplyHandles:{},dormantProperties:{},customProperties:{},childrenCache:null,findCache:{}});const el=new type;d.get(this).element=el;elementRegistry.set(el,this);if(!propertiesCache.has(type)){propertiesCache.set(type,allKeys(el))}propertiesCache.get(type).forEach(prop=>{this.bindProperty(prop)});this.property(\"profiles\",[],true);el.onChildrenChanged=()=>{d.get(this).childrenCache=null;d.get(this).findCache={}};el.onTermination=()=>{for(let key in d.get(this).propertySupplyHandles){d.get(this).propertySupplyHandles[key].unwatch()}d.get(this).propertySupplyHandles={};d.get(this).changeWatchers.forEach(handle=>{handle.unwatch()});d.get(this).changeWatchers=[];d.get(this).childrenCache=null;d.get(this).findCache={};d.get(this).dormantProperties={};d.get(this).customProperties={};d.get(this).element=null;elementRegistry.delete(el)}}get(){return d.get(this).element}id(i,ns){ns=ns||\"\";if(i===undefined){return d.get(this).id[ns]||\"\"}else{d.get(this).id[ns]=i;return this}}elementType(type,ns){ns=ns||\"\";if(type===undefined){return d.get(this).elementType[ns]||\"\"}else{d.get(this).elementType[ns]=type;return this}}add(child){d.get(this).element.add(child.get());return this}call(name){let args=[];for(let i=1;i<arguments.length;++i){args.push(arguments[i])}const el=d.get(this).element;el[name].apply(el,args);return this}property(name,value,innate){const priv=d.get(this);const el=priv.element;let prop=undefined;el.addProperty(name,()=>prop,v=>{prop=v},innate);priv.customProperties[name]=true;this.bindProperty(name);this.setProperty(name,value);this.bindProperty(name+\"Changed\");if(typeof value===\"number\"){el.transitionable(name);this.bindProperty(name+\"Transition\")}if(name===\"profiles\"){el.onProfilesChanged=()=>{el.profiles.filter(obj=>obj).forEach(obj=>{Object.keys(d.get(obj).customProperties).filter(p=>p!=\"profiles\").forEach(profileProp=>{this[profileProp].val=obj[profileProp]})})}}return this}event(name){const uname=name[0].toUpperCase()+name.substr(1);const onEvent=\"on\"+uname;const priv=d.get(this);priv.element.registerEvent(name);this.bindProperty(name);this.bindProperty(onEvent);return this}use(el){return el}set(prop,value){const p=this[prop];if(p===undefined){console.error(\"Object \"+d.get(this).element.objectType+\"@\"+d.get(this).element.objectLocation+\" has no property '\"+prop+\"'.\");return this}if(prop.startsWith(\"on\")&&prop.endsWith(\"Changed\")){this[prop](value)}else{if(p instanceof DynamicValue){p.val=value}}return this}crossConnect(getEl,event){const setup=f=>{let el=getEl();if(el instanceof DynamicValue){el=el.val}if(!!el){el.get().connect(event,this.get(),f)}else{if(this.lifeCycleStatus.val===\"new\"){this.get().onInitialization=()=>{setup(f)}}else{console.error(\"Failed to establish cross-connection: \"+this.objectLocation.val+\" \"+event)}}};return f=>{setup(f);return this}}child(n){const cs=this.children();if(n>=0){return cs[n]}else{return cs[cs.length+n]}}children(type){const priv=d.get(this);if(priv.childrenCache===null){priv.childrenCache=d.get(this).element.children.filter(c=>elementRegistry.has(c)).filter(c=>type===undefined||c instanceof type).map(c=>elementRegistry.get(c))}return priv.childrenCache}find(id,ns){const priv=d.get(this);ns=ns||\"\";if(!priv.element){return undefined}else if(id===priv.id[ns]){return this}else{const child=priv.findCache[id];if(child){const obj=child.find(id,ns);if(obj){return obj}}else{const cs=this.children();for(let i=0;i<cs.length;++i){const obj=cs[i].find(id,ns);if(obj){priv.findCache[id]=cs[i];return obj}}}}return undefined}setProperty(prop,value){const priv=d.get(this);const unwrap=v=>{if(v instanceof Element){return v.get()}else if(typeof v===\"function\"){return(...args)=>{const r=v.apply(priv.element,args);return r instanceof Element?r.get():r}}else{return v}};const existingHandle=priv.propertySupplyHandles[prop];if(existingHandle){existingHandle.unwatch()}if(value instanceof DynamicValue){const handle=value.watch(()=>{const uv=unwrap(value.val);if(uv!==undefined){priv.element.change(prop,uv)}});priv.propertySupplyHandles[prop]=handle;const v=value.val;if(v!==undefined){priv.element[prop]=unwrap(v)}if(priv.customProperties[prop]&&priv.dormantProperties[prop]){handle.setEnabled(false)}}else{priv.element.change(prop,unwrap(value))}return this}getProperty(prop){const priv=d.get(this);if(!priv.element){return undefined}if(priv.dormantProperties[prop]){priv.dormantProperties[prop]=false;const handle=priv.propertySupplyHandles[prop];if(handle){handle.setEnabled(true)}}const obj=priv.element[prop];const objType=typeof obj;if(objType===\"function\"){return(...args)=>{const r=obj.apply(priv.element,args);if(r instanceof core.Object){return elementRegistry.has(r)?elementRegistry.get(r):r}else{return r}}}else if(obj&&obj instanceof core.Object){return elementRegistry.has(obj)?elementRegistry.get(obj):obj}else if(obj&&Array.isArray(obj)){let i=0;for(i=0;i<obj.length;++i){if(obj[i]instanceof core.Object&&elementRegistry.has(obj[i])){obj[i]=elementRegistry.get(obj[i])}}return obj}else{return obj}}bindProperty(prop){if(prop.startsWith(\"on\")&&prop.endsWith(\"Changed\")){return}const priv=d.get(this);const el=priv.element;let targetName=prop;if(this[targetName]!==undefined){targetName=prop+\"_\"}const propType=el.typeOf(prop);if(propType===\"method\"){this[targetName]=(...args)=>el[prop].apply(el,args);return}const isCustomProperty=priv.customProperties[prop];let p=new DynamicValue;p._sh_annotation=el.objectType+\"@\"+el.objectLocation+\".\"+prop;p.setter=v=>this.setProperty(prop,v);p.getter=()=>this.getProperty(prop);p.maybeUndefined=()=>false;if(prop!==\"profiles\"){priv.dormantProperties[prop]=true}p.watched(()=>{priv.dormantProperties[prop]=false;if(isCustomProperty){const handle=priv.propertySupplyHandles[prop];if(handle){handle.setEnabled(true)}}});p.unwatched(()=>{priv.dormantProperties[prop]=true;if(isCustomProperty){const handle=priv.propertySupplyHandles[prop];if(handle){handle.setEnabled(false)}}});let uprop=prop[0].toUpperCase()+prop.substr(1);if(el[\"on\"+uprop+\"Changed\"]!==undefined){el[\"on\"+uprop+\"Changed\"]=()=>{if(!priv.dormantProperties[prop]){p.update()}};this[\"on\"+uprop+\"Changed\"]=cb=>{const handle=p.watch(()=>{cb.apply(this,[p])});priv.changeWatchers.push(handle);return this}}this[targetName]=p}}function element(type){if(type.name===\"Box\"||type.name===\"MouseBox\"||type.name===\"Label\"||type.name===\"Ruler\"||type.name===\"Timer\"){return elementWarehouse.retrieve(type)}else{return new Element(type)}}exports.element=element;function routedElement(el,routeTo){if(routeTo){const proxy=Object.create(el);d.set(proxy,d.get(el));proxy.add=function(child){routeTo.add(child);return this};proxy.children=function(t){return routeTo.children(t)};proxy.id=function(i,ns){return el.id(i,ns)};return proxy}else{return el}}exports.routedElement=routedElement;class DynamicValue{constructor(value){this._sh_really_undefined=false;this._sh_annotation=\"\";this.idCounter=0;this.watchers={};this.watchersEnabled={};this.watchCount=0;this.activeWatchCount=0;this.onUnwatched=null;this.onWatched=null;this.storedValue=value;this.cachedValue=undefined;this.mayUseCache=false;this.setter=v=>{this.storedValue=v};this.getter=()=>{return this.storedValue};this.maybeUndefined=()=>true;++dvCounter}get val(){if(!this.mayUseCache){return this.getter()}if(!this.cachedValue){this.cachedValue=this.getter()}return this.cachedValue}set val(v){this.cachedValue=undefined;this.setter(v)}watch(watchCallback){let watchId=this.idCounter;++this.idCounter;++totalWatchCount;++this.watchCount;++this.activeWatchCount;this.watchers[watchId]=watchCallback;this.watchersEnabled[watchId]=true;if(this.watchCount===1&&this.onWatched){this.onWatched()}return{value:()=>{return this.getter()},setEnabled:enabled=>{if(enabled!==this.watchersEnabled[watchId]&&this.watchers[watchId]){this.watchersEnabled[watchId]=enabled;this.activeWatchCount+=enabled?1:-1;if(enabled&&this.watchers[watchId]){try{this.watchers[watchId]()}catch(err){console.error(`[${core.dbgctx}] DynamicValue.update (${this._sh_annotation}): ${err}`)}}}},unwatch:()=>{--totalWatchCount;--this.watchCount;--this.activeWatchCount;delete this.watchers[watchId];if(this.watchCount===0&&this.onUnwatched){this.onUnwatched()}}}}update(){if(this.activeWatchCount>0){this.cachedValue=undefined;this.mayUseCache=true;for(let watchId in this.watchers){if(!this.watchersEnabled[watchId]){continue}try{this.watchers[watchId]()}catch(err){console.error(`[${core.dbgctx}] DynamicValue.update (${this._sh_annotation}): ${err}`)}}this.cachedValue=undefined;this.mayUseCache=false}}unwatched(callback){this.onUnwatched=callback;this.cachedValue=undefined}watched(callback){this.onWatched=callback}}exports.DynamicValue=DynamicValue;function binding(deps,evaluator,annotation){let handles=[];function setup(b,newDeps){handles.forEach(h=>{h.unwatch()});handles=[];newDeps.forEach(dep=>{const handle=dep.watch(()=>{b.update()});handles.push(handle)})}const b=new DynamicValue(undefined);b._sh_annotation=\"binding \"+(annotation||\"\");b.getter=()=>{if(deps.filter(d=>d.maybeUndefined()&&d.val===undefined&&!d._sh_really_undefined).length!==0){return undefined}try{return evaluator(...deps)}catch(err){console.error(`[${core.dbgctx}] Could not evaluate binding: ${b._sh_annotation}\\n${deps.map(d=>\"- \"+d._sh_annotation+\" = \"+d.val).join(\"\\n\")}\\n${err}`);return undefined}};b.maybeUndefined=()=>{for(let i=0;i<deps.length;++i){if(deps[i].maybeUndefined()){return true}}return false};b.unwatched(()=>{handles.forEach(function(h){h.unwatch()});handles=[];b.getter=null});setup(b,deps);return b}exports.binding=binding;function chainRef(root,chain,resolver){let handles=[];let b=new DynamicValue(undefined);b._sh_annotation=chain.join(\".\");function resolveChain(obj,chain){let ch=chain.slice();if(obj===null){obj=resolver(ch.shift())}ch.forEach(c=>{const v=obj instanceof DynamicValue?obj.val:obj;const next=v!==undefined&&v!==null?v[c]:undefined;if(typeof next===\"function\"){obj=(...args)=>v[c](...args)}else{obj=next}});return obj}function setup(){if(!resolveChain){return}handles.forEach(h=>{h.unwatch()});handles=[];let obj=null;let dvs=[];chain.forEach((c,i)=>{obj=resolveChain(obj,[c]);if(obj instanceof DynamicValue){dvs.push(obj)}});if(obj===undefined){for(let i=0;i<dvs.length;++i){const handle=dvs[i].watch(()=>{setup()});handles.push(handle)}if(b._sh_annotation!==\"\"){}b._sh_really_undefined=true;b.update()}else if(dvs.length>0){for(let i=0;i<dvs.length-1;++i){const handle=dvs[i].watch(()=>{setup()});handles.push(handle)}const dv=dvs[dvs.length-1];const handle=dv.watch(()=>{b.update()});handles.push(handle);const items=chain.slice();if(obj instanceof DynamicValue){b.getter=()=>{return obj.val};b.maybeUndefined=()=>obj.maybeUndefined()}else{b.getter=()=>{return resolveChain(null,items)}}b.update()}else{b.getter=()=>{return obj};b.update()}}if(root.lifeCycleStatus.val===\"initialized\"){setup()}else{root.get().onInitialization=()=>{setup()}}b.unwatched(()=>{handles.forEach(h=>{h.unwatch()});handles=[];resolveChain=null});return b}exports.chainRef=chainRef});",
    "fengshui.js": "\"use strict\";exports.__id=\"shellfish/fengshui\";exports.tools={elementLookup:function(fqElementName,rslv,filename,modules,elementLookupCache,declarative){let explicitModule=\"\";let elementName=fqElementName;if(fqElementName.indexOf(\".\")!==-1){const parts=fqElementName.split(\".\");explicitModule=parts[0];elementName=parts[1]}const cacheItem=elementLookupCache.get(fqElementName);if(cacheItem){if(cacheItem.create){return cacheItem.create(rslv)}else{const el=declarative.element(cacheItem,null).property(\"defaultContainer\",\"\",true);const proto=Object.getPrototypeOf(el);[\"add\",\"property\",\"get\",\"find\",\"children\",\"call\",\"crossConnect\"].forEach(f=>{el[f]=(...args)=>{return proto[f].apply(el,args)}});return el}}for(let key in modules){if(explicitModule!==\"\"&&key!==explicitModule){continue}if(modules[key]&&modules[key][elementName]){elementLookupCache.set(fqElementName,modules[key][elementName]);if(modules[key][elementName].create){return modules[key][elementName].create(rslv)}else{const el=declarative.element(modules[key][elementName],null).property(\"defaultContainer\",\"\",true);const proto=Object.getPrototypeOf(el);[\"add\",\"property\",\"get\",\"find\",\"children\",\"call\",\"crossConnect\"].forEach(f=>{el[f]=(...args)=>{return proto[f].apply(el,args)}});return el}}}console.error(\"Element '\"+fqElementName+\"' is not defined in \"+filename+\".\");return null},rslv:function(name,cache,self,namespace,pRslv,modules){if(name===\"self\")return self;let result=cache.get(name);if(result){return result}result=self[name]||(name===\"this\"+self.elementType(undefined,namespace)?self:undefined)||(name===\"this\"+self.get()?.objectType?self:undefined)||self.find(name,namespace)||pRslv(name)||modules[name];if(result){cache.set(name,result)}return result},addProperties:function(obj,props){Object.keys(props).forEach(key=>{obj.property(key,props[key])})}};(function(){const JS_KEYWORDS=[\"async\",\"await\",\"break\",\"catch\",\"class\",\"const\",\"continue\",\"do\",\"false\",\"finally\",\"for\",\"function\",\"if\",\"let\",\"new\",\"return\",\"super\",\"switch\",\"throw\",\"true\",\"try\",\"until\",\"var\",\"while\"];const JS_GLOBALS=[\"__dirname\",\"__filename\",\"__namespace\",\"__rslv__\",\"alert\",\"arguments\",\"Array\",\"ArrayBuffer\",\"atob\",\"Blob\",\"btoa\",\"console\",\"Date\",\"decodeURI\",\"decodeURIComponent\",\"document\",\"encodeURI\",\"encodeURIComponent\",\"eval\",\"FileReader\",\"Float32Array\",\"Float64Array\",\"Function\",\"Image\",\"ImageData\",\"Infinity\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"isFinite\",\"isNaN\",\"JSON\",\"Map\",\"Math\",\"NaN\",\"navigator\",\"null\",\"Number\",\"Object\",\"parseFloat\",\"parseInt\",\"Promise\",\"Proxy\",\"RegExp\",\"Set\",\"SharedArrayBuffer\",\"TextDecoder\",\"TextEncoder\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"undefined\",\"URL\",\"WebAssembly\",\"WeakMap\",\"WeakSet\",\"window\",\"shRequire\"];const TOKEN_ELEMENT=/^([a-z][a-z0-9_]*\\.)?[A-Z_][a-zA-Z0-9_]* *{/;const TOKEN_NAME=/^[a-z_][a-z0-9_]*/i;const TOKEN_IDENTIFIER=/^[a-z_][a-z_0-9]*(\\.[a-z_0-9]+)*/i;const TOKEN_NUMBER=/^[0-9]+(\\.[0-9]+)?([eE]-?[0-9]+)?/;const TOKEN_HEXNUMBER=/^0x[0-9a-fA-F]+/;const TOKEN_OPERATOR=/^([+\\-*/%&|~!=<>]+|\\?\\?)/;const TOKEN_ARROW_FUNCTION=/^\\([a-z_0-9]* *(, *[a-z_0-9]*)* *\\) *=>/i;const TOKEN_ARROW_FUNCTION_COMPACT=/^[a-z_0-9]+ *=>/i;const TOKEN_REGEXP=/^\\/(\\\\\\/|[^\\/\\n])+?\\/[dgimsuy]*/;let thePreviousLine=-1;function compile(url,data){if(url.toLowerCase().endsWith(\".shui\")){const parts=url.split(\"/\");const name=parts[parts.length-1].replace(/\\.shui$/,\"\");const now=Date.now();let pos={value:0};thePreviousLine=-1;let obj=parseShui(url,name,data,pos);return obj}else{return data}}exports.compile=compile;function load(url,rslv){return new Promise((resolve,reject)=>{shRequire(url,shui=>{if(!shui){reject(\"Failed to load '\"+url+\"'.\");return}function waitForShuiReady(){if(shui.shuiReady===true){for(let key in shui){if(shui[key].create){const now=Date.now();try{let root=shui[key].create(rslv);root.set(\"objectType\",url);resolve(root)}catch(err){reject(err)}return}}}else if(shui.shuiReady===false){setTimeout(waitForShuiReady,100)}else{reject(\"'\"+url+\"' is not a Shui module.\")}}waitForShuiReady()},compile)})}exports.load=load;function lineOfPos(data,pos){const lines=data.split(\"\\n\");let sum=0;for(let line=0;line<lines.length;++line){sum+=lines[line].length+1;if(sum>pos.value){return line+1}}return-1}function skipWhitespace(data,pos,skipNewline,skipComments){function skip(data,pos,what){while(pos.value<data.length&&what.indexOf(data[pos.value])!==-1){++pos.value}}while(pos.value<data.length){skip(data,pos,skipNewline?\"\\t\\n\\r\\x0B \":\"\\t\\r\\x0B \");if(skipComments){if(next(data,pos,\"//\")){readUntilNewline(data,pos)}else if(next(data,pos,\"/*\")&&(!next(data,pos,\"/**\")||next(data,pos,\"/***\"))){skipCommentBlock(data,pos)}else{break}}else{break}}}function skipCommentBlock(data,pos){let idx=data.indexOf(\"*/\",pos.value);if(idx!==-1){pos.value=idx+2}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": end of comment block expected.\"}}function next(data,pos,what){return data.substring(pos.value,pos.value+what.length)===what}function nextIsUpperCase(data,pos){let c=data[pos.value];return c>=\"A\"&&c<=\"Z\"}function nextIsToken(data,pos,regExp){if(pos.value<data.length){return regExp.test(data.substring(pos.value))}else{return false}}function expect(data,pos,what){if(data.substring(pos.value,pos.value+what.length)===what){pos.value+=what.length;return what}else{if(pos.value>=data.length){throw\"Syntax error in line \"+lineOfPos(data,pos)+\": '\"+what+\"' expected, but end of file reached.\"}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": '\"+what+\"' expected, but '\"+data[pos.value]+\"' found.\"}}}function readUntil(data,pos,chars){let s=\"\";while(pos.value<data.length&&chars.indexOf(data[pos.value])===-1){s+=data[pos.value];++pos.value}return s}function readUntilNewline(data,pos){let s=readUntil(data,pos,\"\\r\\n\");return s}function readToken(data,pos,regExp){let s=\"\";if(pos.value<data.length){let matches=regExp.exec(data.substring(pos.value));if(matches){let result=matches[0];pos.value+=result.length;return result}}return\"\"}function readString(data,pos){if(pos.value>=data.length){return\"\"}let delimiter=\"\";if(data[pos.value]===\"'\"){delimiter=\"'\";++pos.value}else if(data[pos.value]===\"\\\"\"){delimiter=\"\\\"\";++pos.value}let result=\"\";while(pos.value<data.length){if(delimiter!==\"\"&&data[pos.value]===delimiter){++pos.value;break}else if(delimiter===\"\"&&\"\\t\\n\\r\\x0B \".indexOf(data[pos.value])!==-1){break}else if(next(data,pos,\"\\\\n\")){result+=\"\\\\n\";++pos.value}else if(next(data,pos,\"\\\\\\\"\")){result+=\"\\\"\";++pos.value}else{result+=data[pos.value]}++pos.value}return result.replace(/\"/g,\"\\\\\\\"\")}function readLiteralString(data,pos){if(pos.value>=data.length){return\"\"}const idx=data.indexOf(\"\\\"\\\"\\\"\",pos.value+1);if(idx===-1){throw\"Syntax error in line \"+lineOfPos(data,pos)+\": Literal string is not terminated with \\\"\\\"\\\".\"}const result=data.substring(pos.value+3,idx);pos.value=idx+3;return result.replace(/\"/g,\"\\\\\\\"\").replace(/\\r?\\n/g,\"\\\\n\")}function readRegExp(data,pos){if(pos.value>=data.length){return\"\"}let result=\"/\";++pos.value;let section=0;while(pos.value<data.length){if(section===0){if(data[pos.value]===\"/\"){result+=\"/\";++pos.value;++section}else if(next(data,pos,\"\\\\/\")){result+=\"\\\\/\";pos.value+=2}else{result+=data[pos.value];++pos.value}}else if(section===1){if(\"dgimsuy\".indexOf(data[pos.value])!==-1){result+=data[pos.value];++pos.value}else{break}}}return result}function parseShui(moduleLocation,name,data,pos){const requirements=[];const docBlocks=[];while(pos.value<data.length){skipWhitespace(data,pos,true,true);if(next(data,pos,\"/**\")){let idx=data.indexOf(\"*/\",pos.value);if(idx!==-1){docBlocks.push(data.substring(pos.value,idx+2));pos.value=idx+2}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": '*/' expected.\"}}else if(next(data,pos,\"require \")){const req=parseRequire(data,pos);requirements.push(req)}else{break}}requirements.push({module:\"shellfish/core\",alias:\"core\"});requirements.push({module:\"shellfish/declarative\",alias:\"declarative\"});if(requirements.find(r=>r.module===\"shellfish/ui\")){requirements.push({module:\"shellfish/html\",alias:\"html\"})}let moduleDir=\".\";if(moduleLocation.indexOf(\"/\")!==-1){moduleDir=moduleLocation.substring(0,moduleLocation.lastIndexOf(\"/\"))}const code=`/* Compiled from Shui by Feng Shui Code Processor */\n            exports.shuiReady = false;\n            shRequire([\"shellfish/fengshui\"], (fengshui_Internal) =>\n            {\n                shRequire([${requirements.map(req=>\"\\\"\"+req.module.replace(/^\\.\\//,moduleDir+\"/\")+\"\\\"\").join(\", \")}],\n                        (${requirements.map(req=>req.alias).join(\", \")}) =>\n                {\n                    const modules = { ${requirements.map(req=>req.alias+\": \"+req.alias).join(\", \")} };\n\n                    const __namespace = __filename;\n                    function __rslv__(name) { return undefined; }\n\n                    const elementLookupCache = new Map();\n                    function elementLookup(fqElementName, rslv)\n                    {\n                        return fengshui_Internal.tools.elementLookup(fqElementName, rslv, __filename, modules, elementLookupCache, declarative);\n                    }\n\n                    class __FakeDV__\n                    {\n                        constructor(a, setter)\n                        {\n                            this.a = a;\n                            this.setter = setter;\n                        }\n                        get val() { return this.a; }\n                        set val(v) { this.setter(v); }\n                    }\n\n                    function __xsdv__(a, setter, functor)\n                    {\n                        return declarative.isDynamicValue(a) ? a \n                                                             : typeof a === \"function\" && functor ? { val: functor } \n                                                                                                  : new __FakeDV__(a, setter);\n                    }\n\n                    exports.${name} = {\n                        ${docBlocks.join(\"\\n\")}\n                        create: (__pRslv__) =>\n                        {\n                            //console.log(__filename + \" __pRslv__ \" + __pRslv__);\n                            ${parseElement(data,pos,true,requirements)}\n                            return declarative.routedElement(\n                                root,\n                                root.find(root.defaultContainer.val, __namespace)\n                            );\n                        }\n                    };\n\n                    exports.shuiReady = true;\n                }, fengshui_Internal.compile);\n            });\n        `;return code}function parseRequire(data,pos){const result={module:\"\",alias:\"mod\"+pos.value};expect(data,pos,\"require\");skipWhitespace(data,pos,true,true);const moduleName=readString(data,pos);result.module=moduleName;skipWhitespace(data,pos,true,true);if(next(data,pos,\";\")){++pos.value}else{expect(data,pos,\"as\");skipWhitespace(data,pos,true,true);result.alias=readUntil(data,pos,\";\\t\\n\\r\\x0B \");skipWhitespace(data,pos,true,true);expect(data,pos,\";\")}return result}function parseElement(data,pos,isRoot,modules){let elementName=readToken(data,pos,TOKEN_IDENTIFIER);skipWhitespace(data,pos,true,true);expect(data,pos,\"{\");let code=\"\";const rslv=`\n            const __rslvCache__ = new Map();\n            function __rslv__(name)\n            {\n                return fengshui_Internal.tools.rslv(name, __rslvCache__, self, __namespace, __pRslv__, modules);\n            }\n        `;const addProperties=`\n            if (typeof addedProperties !== \"undefined\")\n            {\n                fengshui_Internal.tools.addProperties(self, addedProperties);\n                addedProperties = undefined;\n            }\n        `;const strippedElementName=elementName.substring(elementName.lastIndexOf(\".\")+1);if(isRoot){code+=`\n                const root = elementLookup(\"${elementName}\", __pRslv__);\n                const self = root;\n                \n                ${rslv}\n                ${addProperties}\n\n                self.set(\"objectType\", \"${strippedElementName}\").elementType(\"${strippedElementName}\", __namespace)\n                ${parseElementBlock(data,pos,modules)}\n            `}else{code+=`\n                ((__pRslv__) =>\n                {\n                    const self = elementLookup(\"${elementName}\", __pRslv__);\n\n                    ${rslv}\n                    ${addProperties}\n\n                    self.set(\"objectType\", \"${strippedElementName}\").elementType(\"${strippedElementName}\", __namespace)\n                    ${parseElementBlock(data,pos,modules)}\n                    return self;\n                })(__rslv__)\n            `}expect(data,pos,\"}\");code+=\"\\n\";return code.replace(/\\/\\*__new__\\*\\//g,\"\")}function parseElementBlock(data,pos,modules){let code=`.set(\"objectLocation\", __filename + \":\" + ${lineOfPos(data,pos)})`;while(pos.value<data.length){skipWhitespace(data,pos,true,true);if(next(data,pos,\"}\")){break}else if(next(data,pos,\";\")){expect(data,pos,\";\")}else if(next(data,pos,\"/**\")){let idx=data.indexOf(\"*/\",pos.value);if(idx!==-1){code+=data.substring(pos.value,idx+2);pos.value=idx+2}}else if(false&&next(data,pos,\"/*\")){skipCommentBlock(data,pos)}else if(nextIsUpperCase(data,pos)||nextIsToken(data,pos,TOKEN_ELEMENT)){let childCode=parseElement(data,pos,false,modules);code+=\"\\n.use(self).add(\"+childCode+\")\"}else if(next(data,pos,\"into \")){expect(data,pos,\"into\");skipWhitespace(data,pos,true,true);let container=readToken(data,pos,TOKEN_NAME);skipWhitespace(data,pos,true,true);let childCode=parseElement(data,pos,false,modules);code+=\"\\n.use(self).call(\\\"\"+container+\"Add\\\", \"+childCode+\")\"}else if(next(data,pos,\"property \")){code+=\"\\n\"+parseCustomProperty(data,pos,modules)}else if(next(data,pos,\"event \")){expect(data,pos,\"event\");skipWhitespace(data,pos,true,true);const evName=readToken(data,pos,TOKEN_NAME);code+=\"\\n.use(self).event(\\\"\"+evName+\"\\\")\"}else if(next(data,pos,\"container \")){code+=\"\\n\"+parseContainer(data,pos)}else if(next(data,pos,\"async \")){expect(data,pos,\"async\");skipWhitespace(data,pos,true,true);code+=\"\\n\"+parseFunctionProperty(data,pos,modules,true)}else if(next(data,pos,\"function \")){code+=\"\\n\"+parseFunctionProperty(data,pos,modules,false)}else{code+=\"\\n\"+parseProperty(data,pos,modules)}}return code}function parseElementTemplate(data,pos,modules){expect(data,pos,\"template\");skipWhitespace(data,pos,true,true);let code=\"\";if(nextIsToken(data,pos,TOKEN_ELEMENT)){code+=`{\n                create: ((__pRslv__) =>\n                {\n                    const __namespace = \"tmp.${pos.value}\";\n                    return () =>\n                    {\n                        ${parseElement(data,pos,true,modules)}\n                        return self;\n                    };\n                })(__rslv__)\n            }`}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": element expected.\"}return code}function parseCustomProperty(data,pos,modules){const scopes=[modules.map(m=>m.alias),[]];expect(data,pos,\"property\");skipWhitespace(data,pos,true,true);let propName=readUntil(data,pos,\":\\t\\n\\r\\x0B \");skipWhitespace(data,pos,true,true);expect(data,pos,\":\");skipWhitespace(data,pos,true,true);let code=\".use(self).property(\\\"\"+propName+\"\\\", \";if(next(data,pos,\"{\")){code+=\"function () \"+parseJsBlock(data,pos,modules,scopes,chainResolver)}else if(nextIsToken(data,pos,TOKEN_ARROW_FUNCTION)||nextIsToken(data,pos,TOKEN_ARROW_FUNCTION_COMPACT)){code+=parseJsArrowFunction(data,pos,modules,scopes,chainResolver)}else if(next(data,pos,\"template\")){code+=\"(addedProperties) => \"+\"{\"+\"  return \"+parseElementTemplate(data,pos,modules)+\".create(__rslv__);\"+\"}\"}else if(nextIsToken(data,pos,TOKEN_ELEMENT)){code+=parseElement(data,pos,false,modules)}else{code+=parseBindingExpression(data,pos,modules)}code+=\")\";return code}function parseFunctionProperty(data,pos,modules,isAsync){expect(data,pos,\"function\");skipWhitespace(data,pos,true,true);let propName=readUntil(data,pos,\"(\\t\\n\\r\\x0B \");skipWhitespace(data,pos,true,true);let code=\".use(self).property(\\\"\"+propName+\"\\\", \";if(isAsync){code+=\"async \"}let params=[];const scopes=[modules.map(m=>m.alias),[]];code+=parseJsParameters(data,pos,p=>{params.push(p)});skipWhitespace(data,pos,true,true);code+=\" => \";code+=parseJsBlock(data,pos,modules,scopes.concat([params]),chainResolver);code+=\")\";return code}function parseContainer(data,pos){expect(data,pos,\"container\");skipWhitespace(data,pos,true,true);let name=readToken(data,pos,TOKEN_NAME);skipWhitespace(data,pos,true,true);expect(data,pos,\":\");skipWhitespace(data,pos,true,true);let targetName=readToken(data,pos,TOKEN_NAME);let code=\".use(self)\";if(name===\"default\"){code+=\".set(\\\"defaultContainer\\\", \\\"\"+targetName+\"\\\")\"}else{code+=\".property(\\\"\"+name+\"Add\\\", \"+\"function (child)\"+\"{\"+\"  self.find(\\\"\"+targetName+\"\\\", __namespace).add(child);\"+\"  return self;\"+\"})\"}return code}function parseProperty(data,pos,modules){let propName=readUntil(data,pos,\":\\t\\n\\r\\x0B \");skipWhitespace(data,pos,true,true);expect(data,pos,\":\");skipWhitespace(data,pos,true,true);let code=\"\";if(propName.indexOf(\".\")!==-1){const parts=propName.split(\".\");const elName=parts[0];const slotName=parts[1];if(!slotName.startsWith(\"on\")){throw\"Syntax error in line \"+lineOfPos(data,pos)+\": '\"+slotName+\"' is not a valid event slot\"}const eventName=slotName[2].toLowerCase()+slotName.substring(3);code=`.use(self).crossConnect(() => { return __rslv__(\"${elName}\"); }, \"${eventName}\")(`}else if(propName===\"id\"){code=`.use(self).id(`}else{code=`.use(self).set(\"${propName}\", `}if(next(data,pos,\"{\")){const codeBlock=parseJsBlock(data,pos,modules,[[]],chainResolver);code+=\"function () \"+codeBlock}else if(nextIsToken(data,pos,TOKEN_ARROW_FUNCTION)||nextIsToken(data,pos,TOKEN_ARROW_FUNCTION_COMPACT)){const scopes=[modules.map(m=>m.alias),[]];code+=parseJsArrowFunction(data,pos,modules,scopes,chainResolver)}else if(next(data,pos,\"async\")){expect(data,pos,\"async\");skipWhitespace(data,pos,true,true);const scopes=[modules.map(m=>m.alias),[]];code+=\"async \";code+=parseJsArrowFunction(data,pos,modules,scopes,chainResolver)}else if(next(data,pos,\"template\")){code+=\"(addedProperties) => \"+\"{\"+\"  return \"+parseElementTemplate(data,pos,modules)+\".create(__rslv__);\"+\"}\"}else if(nextIsToken(data,pos,TOKEN_ELEMENT)){code+=parseElement(data,pos,false,modules)}else{if(propName===\"id\"){code+=\"\\\"\"+readToken(data,pos,TOKEN_IDENTIFIER)+\"\\\"\"}else{code+=parseBindingExpression(data,pos,modules)}}if(propName===\"id\"){code+=\", __namespace\"}code+=\")\";return code}function parseBindingExpression(data,pos,modules){let aliasMap=new Map;let aliasCounter=0;const aliasCache=new Map;function bindingResolver(parts,protectedOnes,scopes,line){let firstInChain=parts[0];if(JS_GLOBALS.indexOf(firstInChain)!==-1||inScope(scopes,firstInChain)){return chainResolver(parts,protectedOnes,scopes,line)}else{const splitResult=splitChain(parts);let alias=\"\";if(aliasCache.has(parts.join(\".\"))){alias=aliasCache.get(parts.join(\".\"))}else{alias=\"alias\"+aliasCounter;++aliasCounter;aliasMap.set(alias,makeChainRef(splitResult[0]));aliasCache.set(parts.join(\".\"),alias)}scopes[scopes.length-1].push(alias);const newParts=[alias].concat(splitResult[1]);while(protectedOnes.length>newParts.length){protectedOnes.shift()}return chainResolver(newParts,protectedOnes,scopes,line)}}const beginAt=pos.value;const line=lineOfPos(data,pos);const scopes=[modules.map(m=>m.alias),[]];let code=parseJsExpression(data,pos,modules,scopes,bindingResolver);const originalCode=data.substring(beginAt,pos.value);const debugAnnotation=`[l. ${line}] ${originalCode}`;if(next(data,pos,\";\")){expect(data,pos,\";\")}if(aliasMap.size>0){let depsList=[];let argsList=[];for(let entry of aliasMap){let alias=entry[0];let ref=entry[1];depsList.push(ref);argsList.push(alias)}return\"declarative.binding([\"+depsList.join(\",\")+\"], (\"+argsList.join(\",\")+\") => { return \"+code+\"; }, __filename + \"+JSON.stringify(debugAnnotation)+\")\"}else{return code}}function inScope(scopes,varName){return scopes.reduce((a,b)=>{return a||b.indexOf(varName)!==-1},false)}function parseJsStatement(data,pos,modules,scopes,resolver){let code=\"\";while(pos.value<data.length){skipWhitespace(data,pos,false,true);if(next(data,pos,\"\\n\")){code+=expect(data,pos,\"\\n\");break}else if(next(data,pos,\";\")){code+=expect(data,pos,\";\");break}else if(next(data,pos,\":\")){throw\"Syntax error in line \"+lineOfPos(data,pos)+\": invalid character '\"+data[pos.value]+\"'.\"}else if(next(data,pos,\"}\")){break}else if(next(data,pos,\"{\")){code+=parseJsBlock(data,pos,modules,scopes.concat([[]]),resolver);break}else if(next(data,pos,\"function\")){code+=parseJsFunction(data,pos,modules,scopes,resolver);break}else if(nextIsToken(data,pos,TOKEN_NAME)){let prevPos=pos.value;const identifier=readToken(data,pos,TOKEN_NAME);if(identifier===\"var\"){code+=identifier+\" \";skipWhitespace(data,pos,true,true);const varName=readToken(data,pos,TOKEN_NAME);code+=varName;skipWhitespace(data,pos,true,true);scopes[0].push(varName);if(next(data,pos,\"=\")){code+=parseJsExpression(data,pos,modules,scopes,resolver)}else{break}}else if(identifier===\"const\"||identifier===\"let\"){code+=identifier+\" \";skipWhitespace(data,pos,true,true);const varName=readToken(data,pos,TOKEN_NAME);code+=varName;skipWhitespace(data,pos,true,true);scopes[scopes.length-1].push(varName);if(next(data,pos,\"=\")){code+=expect(data,pos,\"=\");code+=parseJsExpression(data,pos,modules,scopes,resolver)}else{break}}else if(identifier===\"if\"||identifier===\"while\"){code+=identifier+\" \";skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);code+=parseJsStatement(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);if(next(data,pos,\"else\")){code+=expect(data,pos,\"else\")}break}else if(identifier===\"do\"){code+=identifier+\" \";code+=parseJsStatement(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"while\");skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"(\");code+=parseJsExpression(data,pos,modules,scopes,resolver);code+=expect(data,pos,\")\");break}else if(identifier===\"for\"){pos.value=prevPos;code+=parseJsForLoop(data,pos,modules,scopes.concat([[]]),resolver);break}else if(identifier===\"switch\"){pos.value=prevPos;code+=parseJsSwitch(data,pos,modules,scopes,resolver);break}else if(identifier===\"break\"||identifier===\"continue\"){code+=identifier;break}else if(identifier===\"throw\"){code+=identifier+\" \";skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver);break}else if(identifier===\"try\"){code+=identifier;skipWhitespace(data,pos,true,true);code+=parseJsBlock(data,pos,modules,scopes.concat([[]]),resolver);skipWhitespace(data,pos,true,true);if(next(data,pos,\"catch\")){code+=expect(data,pos,\"catch\");skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"(\");const errVar=readToken(data,pos,TOKEN_NAME);code+=errVar;code+=expect(data,pos,\")\");skipWhitespace(data,pos,true,true);code+=parseJsBlock(data,pos,modules,scopes.concat([[errVar]]),resolver);skipWhitespace(data,pos,true,true)}if(next(data,pos,\"finally\")){code+=expect(data,pos,\"finally\");skipWhitespace(data,pos,true,true);code+=parseJsBlock(data,pos,modules,scopes.concat([[]]),resolver);skipWhitespace(data,pos,true,true)}break}else if(identifier===\"return\"){code+=identifier;skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver);break}else if(JS_KEYWORDS.indexOf(identifier)!==-1){code+=identifier+\" \";break}else{if(next(data,pos,\":\")){code+=identifier+expect(data,pos,\":\")}else{pos.value=prevPos;code+=parseJsExpression(data,pos,modules,scopes,resolver)}}}else if(nextIsToken(data,pos,TOKEN_OPERATOR)){code+=parseJsExpression(data,pos,modules,scopes,resolver);break}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": invalid character '\"+data[pos.value]+\"'.\"}}return code}function parseJsExpression(data,pos,modules,scopes,resolver){let code=\"\";let mayTerminate=false;while(pos.value<data.length){skipWhitespace(data,pos,false,true);code+=\" \";if(next(data,pos,\";\")){break}else if(next(data,pos,\",\")||next(data,pos,\":\")||next(data,pos,\")\")||next(data,pos,\"]\")||next(data,pos,\"}\")){break}else if(next(data,pos,\"\\n\")){if(mayTerminate){break}else{code+=expect(data,pos,\"\\n\")}}else if(next(data,pos,\"\\\"\\\"\\\"\")){code+=\"\\\"\"+readLiteralString(data,pos)+\"\\\"\";mayTerminate=true}else if(next(data,pos,\"\\\"\")){code+=\"\\\"\"+readString(data,pos)+\"\\\"\";mayTerminate=true}else if(next(data,pos,\"'\")){code+=\"'\"+readString(data,pos)+\"'\";mayTerminate=true}else if(nextIsToken(data,pos,TOKEN_REGEXP)&&!mayTerminate){code+=readRegExp(data,pos);mayTerminate=true}else if(next(data,pos,\"[\")){code+=expect(data,pos,\"[\");code+=parseJsList(data,pos,modules,scopes,resolver);code+=expect(data,pos,\"]\");mayTerminate=true}else if(nextIsToken(data,pos,TOKEN_ARROW_FUNCTION)||nextIsToken(data,pos,TOKEN_ARROW_FUNCTION_COMPACT)){code+=parseJsArrowFunction(data,pos,modules,scopes,resolver);mayTerminate=true}else if(next(data,pos,\"...\")){code+=expect(data,pos,\"...\");mayTerminate=false}else if(next(data,pos,\"(\")){code+=expect(data,pos,\"(\");code+=parseJsExpression(data,pos,modules,scopes,resolver);code+=expect(data,pos,\")\");mayTerminate=true}else if(next(data,pos,\"{\")){if(mayTerminate){break}else{code+=parseJsObject(data,pos,modules,scopes,resolver);mayTerminate=true}}else if(nextIsToken(data,pos,TOKEN_OPERATOR)){const s=readToken(data,pos,TOKEN_OPERATOR);code+=s;mayTerminate=s===\"++\"||s===\"--\"}else if(next(data,pos,\"?\")){code+=expect(data,pos,\"?\");code+=parseJsExpression(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);code+=expect(data,pos,\":\");code+=parseJsExpression(data,pos,modules,scopes,resolver);mayTerminate=true}else if(next(data,pos,\"true\")||next(data,pos,\"false\")){code+=readToken(data,pos,TOKEN_NAME);mayTerminate=true}else if(next(data,pos,\"instanceof\")){code+=expect(data,pos,\"instanceof\");mayTerminate=false}else if(next(data,pos,\"typeof\")){code+=expect(data,pos,\"typeof\");mayTerminate=false}else if(nextIsToken(data,pos,TOKEN_HEXNUMBER)){code+=readToken(data,pos,TOKEN_HEXNUMBER);mayTerminate=true}else if(nextIsToken(data,pos,TOKEN_NUMBER)){code+=readToken(data,pos,TOKEN_NUMBER);mayTerminate=true}else if(nextIsToken(data,pos,TOKEN_NAME)){const prevPos=pos.value;const identifier=readToken(data,pos,TOKEN_NAME);if(identifier===\"new\"){skipWhitespace(data,pos,true,true);if(next(data,pos,\"direct \")){expect(data,pos,\"direct\");console.warn(`The \"direct\" keyword is not required anymore and is deprecated. Used in line ${lineOfPos(data,pos)}.`)}const c=parseJsExpression(data,pos,modules,scopes,resolver);if(c.trimStart()[0]===\"(\"){const idx=c.lastIndexOf(\"/*__new__*/\");if(idx!==-1){code+=c.substring(0,idx)+\"new\"+c.substring(idx+11)}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": 'new' requires a constructor function.\"}}else{code+=\"new \"+c}}else if(identifier===\"async\"){code+=identifier}else if(identifier===\"await\"){code+=identifier}else if(identifier===\"function\"){let params=[];code+=identifier;skipWhitespace(data,pos,true,true);code+=parseJsParameters(data,pos,p=>{params.push(p)});skipWhitespace(data,pos,true,true);code+=parseJsBlock(data,pos,modules,scopes.concat([params]),resolver)}else if(identifier===\"class\"){throw\"Keyword 'class' at \"+lineOfPos(data,pos)+\" is currently not supported.\"}else if(identifier===\"unresolved\"){skipWhitespace(data,pos,true,true);code+=parseJsBlock(data,pos,modules,scopes,nullResolver)}else if(identifier===\"direct\"){skipWhitespace(data,pos,true,true);code+=parseJsChain(data,pos,modules,scopes,nullResolver)}else{pos.value=prevPos;code+=parseJsChain(data,pos,modules,scopes,resolver)}mayTerminate=true}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": invalid character '\"+data[pos.value]+\"'.\"}}return code}function parseJsBlock(data,pos,modules,scopes,resolver){let code=\"\";code+=expect(data,pos,\"{\");while(pos.value<data.length){skipWhitespace(data,pos,true,true);code+=\" \";if(next(data,pos,\"}\")){code+=expect(data,pos,\"}\");break}else if(next(data,pos,\":\")){throw\"Syntax error in line \"+lineOfPos(data,pos)+\": invalid character '\"+data[pos.value]+\"'.\"}else{code+=parseJsStatement(data,pos,modules,scopes,resolver)}}return code}function parseJsObject(data,pos,modules,scopes,resolver){let code=\"\";code+=expect(data,pos,\"{\");while(pos.value<data.length){skipWhitespace(data,pos,true,true);if(next(data,pos,\"}\")){break}else if(next(data,pos,\"\\\"\")){code+=\"\\\"\"+readString(data,pos)+\"\\\"\"}else if(next(data,pos,\"'\")){code+=\"'\"+readString(data,pos)+\"'\"}else{code+=readToken(data,pos,TOKEN_NAME)}skipWhitespace(data,pos,true,true);code+=expect(data,pos,\":\");code+=parseJsExpression(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);if(!next(data,pos,\",\")){break}else{code+=expect(data,pos,\",\")}}code+=expect(data,pos,\"}\");return code}function parseJsParameters(data,pos,parameterCallback){let code=\"\";code+=expect(data,pos,\"(\");while(pos.value<data.length){skipWhitespace(data,pos,true,true);if(nextIsToken(data,pos,TOKEN_NAME)){const name=readToken(data,pos,TOKEN_NAME);parameterCallback(name);code+=name}skipWhitespace(data,pos,true,true);if(next(data,pos,\")\")){break}else{code+=expect(data,pos,\",\")}}code+=expect(data,pos,\")\");return code}function parseJsList(data,pos,modules,scopes,resolver){let code=\"\";while(pos.value<data.length){skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);if(next(data,pos,\"]\")||next(data,pos,\")\")){break}else{code+=expect(data,pos,\",\")}}return code}function parseJsChain(data,pos,modules,scopes,resolver){let parts=[];let protectedOnes=[];let isFirst=true;let nextIsProtected=false;while(pos.value<data.length){let part=\"\";if(!isFirst&&next(data,pos,\"(\")){part+=expect(data,pos,\"(\");part+=parseJsList(data,pos,modules,scopes,resolver);part+=expect(data,pos,\")\")}else if(!isFirst&&next(data,pos,\"[\")){part+=expect(data,pos,\"[\");part+=parseJsList(data,pos,modules,scopes,resolver);part+=expect(data,pos,\"]\")}else{const identifier=readToken(data,pos,TOKEN_NAME);part+=identifier}isFirst=false;parts.push(part);protectedOnes.push(nextIsProtected);const prevPos=pos.value;skipWhitespace(data,pos,true,true);if(next(data,pos,\".\")){expect(data,pos,\".\");nextIsProtected=false;continue}else if(next(data,pos,\"?.\")){expect(data,pos,\"?.\");nextIsProtected=true;continue}else if(next(data,pos,\"(\")||next(data,pos,\"[\")){continue}else{pos.value=prevPos;break}}return resolver(parts,protectedOnes,scopes,lineOfPos(data,pos))}function parseJsForLoop(data,pos,modules,scopes,resolver){let code=\"\";code+=expect(data,pos,\"for\");skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"(\");code+=parseJsStatement(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);if(next(data,pos,\"in\")){code+=\" \"+expect(data,pos,\"in\")+\" \";skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver)}else if(next(data,pos,\"of\")){code+=\" \"+expect(data,pos,\"of\")+\" \";skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver)}else if(!next(data,pos,\")\")){skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);code+=expect(data,pos,\";\");skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true)}code+=expect(data,pos,\")\");skipWhitespace(data,pos,true,true);code+=parseJsStatement(data,pos,modules,scopes,resolver);return code}function parseJsSwitch(data,pos,modules,scopes,resolver){let code=\"\";code+=expect(data,pos,\"switch\");skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"(\");code+=parseJsExpression(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,true,true);code+=expect(data,pos,\")\");skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"{\");while(pos.value<data.length){skipWhitespace(data,pos,true,true);code+=\"\\n\";const token=readToken(data,pos,TOKEN_NAME);if(token===\"case\"){code+=token;skipWhitespace(data,pos,true,true);code+=parseJsExpression(data,pos,modules,scopes,resolver)}else if(token===\"default\"){code+=token}else{throw\"Syntax error in line \"+lineOfPos(data,pos)+\": 'case' or 'default' expected.\"}skipWhitespace(data,pos,false,true);code+=expect(data,pos,\":\");while(pos.value<data.length){skipWhitespace(data,pos,false,true);code+=parseJsStatement(data,pos,modules,scopes,resolver);skipWhitespace(data,pos,false,true);if(next(data,pos,\"}\")||next(data,pos,\"case\")||next(data,pos,\"default\")){break}}if(next(data,pos,\"}\")){break}}skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"}\");return code}function parseJsFunction(data,pos,modules,scopes,resolver){let code=\"\";code+=expect(data,pos,\"function\");skipWhitespace(data,pos,true,true);const name=readToken(data,pos,TOKEN_NAME);code+=\" \"+name;scopes[0].push(name);let params=[];code+=parseJsParameters(data,pos,p=>{params.push(p)});skipWhitespace(data,pos,true,true);code+=parseJsBlock(data,pos,modules,scopes.concat([params]),resolver);return code}function parseJsArrowFunction(data,pos,modules,scopes,resolver){let code=\"\";let params=[];if(next(data,pos,\"(\")){code+=parseJsParameters(data,pos,p=>{params.push(p)})}else{const p=readToken(data,pos,TOKEN_NAME);params.push(p);code+=p}skipWhitespace(data,pos,true,true);code+=expect(data,pos,\"=>\");skipWhitespace(data,pos,true,true);if(next(data,pos,\"{\")){code+=parseJsBlock(data,pos,modules,scopes.concat([params]),resolver)}else{code+=parseJsExpression(data,pos,modules,scopes.concat([params]),resolver)}return code}function nullResolver(parts,protectedOnes,scopes){let code=parts[0];parts.shift();protectedOnes.shift();parts.forEach((p,idx)=>{code+=p[0]!==\"(\"&&p[0]!==\"[\"?(protectedOnes[idx+1]?\"?.\":\".\")+p:p});return code}function chainResolver(parts,protectedOnes,scopes,line){const names=parts.map((p,i)=>p.startsWith(\"(\")?\"CALL_\"+i:p.startsWith(\"[\")?\"ACCESS_\"+i:p+\"_\"+i);let counter=0;let accessed=\"\";let code=\"(() => {\";if(line!==thePreviousLine){code+=`core.dbgctx = __filename + \":${line}\";`;thePreviousLine=line}let firstInChain=parts[0];if(JS_GLOBALS.indexOf(firstInChain)!==-1){let code=firstInChain;parts.shift();protectedOnes.shift();parts.forEach((p,idx)=>{code+=p[0]!==\"(\"&&p[0]!==\"[\"?(protectedOnes[idx+1]?\"?.\":\".\")+p:p});return code}else if(inScope(scopes,firstInChain)){accessed=accessDv(firstInChain);code+=`const ${names[counter]} = ${accessed};`}else{accessed=accessDv(\"__rslv__(\\\"\"+firstInChain+\"\\\")\");code+=`const ${names[counter]} = ${accessed};`}if(protectedOnes[counter+1]){code+=`if (${names[counter]}.val === null || ${names[counter]}.val === undefined) return { val: undefined };`}parts.shift();parts.forEach(p=>{++counter;if(p[0]!==\"(\"&&p[0]!==\"[\"){accessed=accessDv(`${names[counter-1]}.val.${p}`)}else{accessed=accessDv(`${names[counter-1]}.val${p}`)}code+=`const ${names[counter]} = ${accessed};`;if(protectedOnes[counter+1]){code+=`if (${names[counter]}.val === null || ${names[counter]}.val === undefined) return { val: undefined };`}});code+=`return ${names[counter]};`;code+=\"})().val\";return code}function splitChain(parts){let head=[];let tail=[];let onHead=true;parts.forEach(function(p){if(p[0]===\"[\"||p[0]===\"(\"){onHead=false}if(onHead){head.push(p)}else{tail.push(p)}});return[head,tail]}function makeChainRef(chain){return\"declarative.chainRef(root, \"+JSON.stringify(chain)+\", __rslv__)\"}function accessDv(item){if(item.endsWith(\")\")){return`__xsdv__(${item}, () => { })`}else{const setter=item?`v => { ${item} = v; }`:`v => { }`;const placeNew=item.split(\".\").filter(c=>c[0]>=\"A\"&&c[0]<=\"Z\").length>0;const functor=item?`(...args) => { return ${placeNew?\"/*__new__*/\":\"\"} (${item})(...args); }`:\"undefined\";return`__xsdv__(${item}, ${setter}, ${functor})`}}if(typeof process!==\"undefined\"&&process.versions&&process.versions.node&&typeof require!==\"undefined\"&&typeof module!==\"undefined\"&&require.main===module){const modFs=require(\"fs\");if(process.argv.length!==3||process.argv[2]===\"-h\"){console.log(\"Compiles a Shui document and produces JavaScript code.\");console.log(\"\");console.log(\"Usage: node fengshui.js <shui-file>\");console.log(\"\");process.exit(1)}const shuiFile=process.argv[2];const outFile=shuiFile+\".js\";const js=compile(shuiFile,modFs.readFileSync(shuiFile).toString());modFs.writeFileSync(outFile,js)}})();",
    "shui-loader.js": "\"use strict\";shRequire([__dirname+\"/fengshui.js\"],fengshui=>{if(typeof document!==\"undefined\"){let haveShui=false;const resolver=name=>{return undefined};const scripts=document.getElementsByTagName(\"script\");for(let i=0;i<scripts.length;++i){const script=scripts[i];const shui=script.getAttribute(\"data-shui\");if(shui&&shui!==\"\"){fengshui.load(shui,resolver).then(o=>{o.get().init()});haveShui=true;break}}if(!haveShui){const s=window.location.search.substring(1);const parts=s.split(\"&\");parts.forEach(p=>{if(!haveShui){const item=p.split(\"=\");if(item[0]===\"shui\"){fengshui.load(item[1],resolver).then(o=>{o.get().init()});haveShui=true}}})}if(!haveShui){document.write(`\n                <h1>Failed to Load Shui Document</h1>\n                <p>\n                Please specify an entry point Shui document in the URL parameters, e.g.\n                <p>\n                <tt>https://example.com/index.html?shui=main.shui</tt>\n                <hr>\n                <i>Shellfish UI toolkit &copy; 2019 - 2023 Martin Grimme</i>\n            `)}}exports.load=url=>{const resolver=name=>{return undefined};fengshui.load(url,resolver).then(o=>{o.get().init()}).catch(err=>{console.error(\"Failed to load Shui module: \"+url+\" \"+err)})}});"
  },
  "aliases": {
    "shellfish/core/bezier": "core/util/bezier-easing.js",
    "shellfish/core/matrix": "core/util/matrix.js",
    "shellfish/core/mime": "core/util/mime.js",
    "shellfish/core/vector": "core/util/vec.js",
    "shellfish/core/warehouse": "core/util/warehouse.js",
    "shellfish/core/xmlsax": "core/util/xmlsax.js",
    "shellfish/core": "core.js",
    "shellfish/declarative": "declarative.js",
    "shellfish/fengshui": "fengshui.js"
  },
  "formats": {
    "core/action.js": "utf-8",
    "core/filefs.js": "utf-8",
    "core/filestorage.js": "utf-8",
    "core/filesystem.js": "utf-8",
    "core/fsmodel.js": "utf-8",
    "core/inertialengine.js": "utf-8",
    "core/listmodel.js": "utf-8",
    "core/object.js": "utf-8",
    "core/parallelaction.js": "utf-8",
    "core/registryfile.js": "utf-8",
    "core/registryoverlay.js": "utf-8",
    "core/repeater.js": "utf-8",
    "core/rpcproxy.js": "utf-8",
    "core/scalemodel.js": "utf-8",
    "core/scriptaction.js": "utf-8",
    "core/sequentialaction.js": "utf-8",
    "core/threadpool.js": "utf-8",
    "core/timer.js": "utf-8",
    "core/treemodeladapter.js": "utf-8",
    "core/util/bezier-easing.js": "utf-8",
    "core/util/color.js": "utf-8",
    "core/util/compat.js": "utf-8",
    "core/util/compression.js": "utf-8",
    "core/util/matrix.js": "utf-8",
    "core/util/mime.js": "utf-8",
    "core/util/vec.js": "utf-8",
    "core/util/warehouse.js": "utf-8",
    "core/util/xmlsax.js": "utf-8",
    "core/waitaction.js": "utf-8",
    "core/wasm.js": "utf-8",
    "core.js": "utf-8",
    "declarative.js": "utf-8",
    "fengshui.js": "utf-8",
    "shui-loader.js": "utf-8"
  }
}