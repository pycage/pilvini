require "shellfish/ui";

MouseBox {
    id: navbar

    property target: parent
    property getLabel: (idx) => { return ""; }
    property orientation: "vertical"
    property labelWidth: theme.itemWidthMedium
    property labelHeight: theme.itemHeightMedium
    property count: labelRepeater.count

    visible: target.contentHeight > target.bboxHeight

    color: theme.secondaryBackgroundColor

    layout: orientation === "vertical" ? "center-column"
                                       : "center-row"

    function update()
    {
        accumulateCallback(() =>
        {
            doUpdate();
        }, "update");
    }

    function doUpdate()
    {
        if (! target)
        {
            return;
        }

        let itemsPerRow = 1;
        let cellSize = 0;
        if (target.orientation === "vertical")
        {
            itemsPerRow = Math.floor(target.bboxWidth / target.cellWidth);
            cellSize = target.cellHeight;
        }
        else
        {
            itemsPerRow = Math.floor(target.bboxHeight / target.cellHeight);
            cellSize = target.cellWidth;
        }

        let maxItems = 0;
        if (orientation === "vertical")
        {
            maxItems = Math.floor(bboxHeight / labelHeight);
        }
        else
        {
            maxItems = Math.floor(bboxWidth / labelWidth);
        }

        let m = [];
        let pos = 0;
        let posFrom = 0;
        let posTo = 0;
        let prevLabel = "";

        let rowIndex = 0;
        for (let i = 0; i < target.count; ++i)
        {
            const label = navbar.getLabel(i);

            if (label !== prevLabel)
            {
                if (m.length > 0)
                {
                    m[m.length - 1].until = posTo;
                }

                posFrom = pos;
                posTo = pos + cellSize;
                m.push({ position: posFrom, until: posTo, label: label });
                prevLabel = label;
            }
            posTo = pos + cellSize;

            ++rowIndex;
            if (rowIndex === itemsPerRow)
            {
                rowIndex = 0;
                pos += cellSize;
            }
        }
        
        // remove exceeding items, but not the first or the last
        while (m.length > 0 && maxItems > 1 && m.length > maxItems)
        {
            const tooMany = m.length - maxItems;

            const sizes = m
            .map((item, idx) => { return { size: item.until - item.position, index: idx }; })
            .slice(1, -1)
            .sort((itemA, itemB) => itemA.size - itemB.size);

            const toRemove = sizes
            .slice(0, tooMany)
            .map(item => item.index);

            if (toRemove.length === 0)
            {
                break;
            }

            m = m.filter((nil, idx) => toRemove.indexOf(idx) === -1);
        }

        labelRepeater.model.reset(m);
    }

    onBboxChanged: () => { update(); }
    onLabelWidthChanged: () => { update(); }
    onGetLabelChanged: () => { update(); }
    target.onLayoutChange: () => { update(); }

    onWheel: ev =>
    {
        ev.accepted = true;
        if (labelRepeater.count === 0)
        {
            return;
        }

        const stepSize = bboxHeight / labelRepeater.count;
        if (ev.deltaY < 0)
        {
            target.contentY = target.contentY - stepSize;
        }
        else if (ev.deltaY > 0)
        {
            target.contentY = target.contentY + stepSize;
        }
    }

    Repeater {
        id: labelRepeater

        model: ListModel { }

        delegate: template Button {
            fillWidth: true
            fillHeight: true
            flat: true

            checked: target.contentY <= modelData.value.until &&
                     target.contentY + target.bboxHeight >= modelData.value.position
            text: modelData.value.label

            labelProfile: Object {
                property fontSize: theme.fontSizeSmall
                property color: theme.primaryColor
            }

            onClick: () =>
            {
                target.contentY = modelData.value.position;
            }
        }
    }

}