require "shellfish/ui";
require "./BreadCrumbs.shui";
require "./downloader.js";
require "./FileViewer.shui";
require "./HistoryScope.shui";
require "./NavBar.shui";
require "./uploadfiles.js" as uploadfiles;
require "./thumbnailgenerator.js";

Box {
    id: box

    property windowIcon: "fs-folder"
    property windowTitle: path

    property fs: null
    property path: "/"
    property searchBox: false
    property maximized: false

    event toggleMaximized
    event filesOpen

    fillWidth: true
    fillHeight: true

    //borderRadius: 6

    function setPath(newPath)
    {
        const currentPath = box.path;
        thisHistory.push(() =>
        {
            console.log("go back to " + currentPath);
            selector.clear();
            box.path = currentPath;
        });

        selector.clear();
        box.path = newPath;
    }

    function openAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const file = fsModel.at(idx);

        if (file.type === "d")
        {
            setPath(file.path);
        }
        else if (file.mimetype === "application/zip" ||
                    file.mimetype === "application/x-rar-compressed")
        {
            console.log("open ZIP: " + file.path);
            setPath(file.path);
        }
        else if (file.mimetype.startsWith("audio/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("audio/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype.startsWith("image/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("image/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype.startsWith("video/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("video/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype === "application/pdf" ||
                file.mimetype === "application/x-youtube-link" ||
                file.mimetype.startsWith("image/") ||
                file.mimetype.startsWith("text/"))
        {
            fileViewer.open([file], 0);
        }
    }

    function goBackAction()
    {
        console.log("GO BACK")
        thisHistory.back();
        //setPath(fs.dirname(box.path));
    }

    function newDirectoryAction()
    {
        const dlg = newDirectoryDialogT();
        dlg.callback = newName =>
        {
            box.fs.mkdir(box.path, box.fs.encodeName(newName));
        };
        dlg.show();
    }

    function newFileAction()
    {
        const dlg = newFileDialogT();
        dlg.callback = newName =>
        {
            box.fs.write(box.path + "/" + box.fs.encodeName(newName), new Blob([""]));
        };
        dlg.show();
    }

    function deleteAction()
    {
        if (selector.selection.size === 0)
        {
            return;
        }

        const selected = [...selector.selection];

        showQuestionDialog("Delete File",
                           "Do you want to delete " + selected.length + " items?\n\n" +
                           selected.map(idx => low.escapeMarkup(fsModel.at(idx).name)).join("\n"),
                           () =>
        {
            selected.forEach(idx =>
            {
                box.fs.remove(fsModel.at(idx).path);
            });
        });

        /*
        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        showQuestionDialog("Delete File",
                            "Do you want to delete this file?\n\n" +
                            low.escapeMarkup(item.name),
                            () =>
        {
            box.fs.remove(item.path);
        });
        */
    }

    function renameAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        const dlg = renameDialogT();
        dlg.name = item.name;
        dlg.callback = newName =>
        {
            box.fs.move(item.path, box.fs.pathJoin(box.fs.dirname(item.path), box.fs.encodeName(newName)));
        };
        dlg.show();
    }

    function downloadAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        if (item.type !== "d")
        {
            downloader.download(item.path, item.name);
        }
    }

    function takeFilesAction()
    {
        if (selector.selection.size === 0)
        {
            return;
        }

        const items = [];
        selector.selection.forEach(idx => items.push(fsModel.at(idx)));

        filesBag = items;
        filesBagSource = box.objectId;
    }

    HistoryScope { id: thisHistory }

    Downloader { id: downloader }

    ThumbnailGenerator {
        id: thumbnailer

        enabled: thumbnailCheckbox.checked
        filesystem: OfflineFS { volume: "Thumbnails" }
    }

    FSModel {
        id: fsModel

        filesystem: box.fs
        path: box.path
        sortRole: sortSelector.role
        sortAscending: sortSelector.ascending

        function getFiles(predicate)
        {
            const result = [];
            for (let i = 0; i < size; ++i)
            {
                const f = at(i);
                if (predicate(f))
                {
                    result.push(f);
                }
            }
            return result;
        }
    }

    // title bar
    MouseBox {
        visible: ! fileViewer.maximized
        marginTop: box.bboxY < theme.itemHeightMedium ? theme.itemHeightMedium : 0
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor

        layout: "center-row"
        
        onDoubleClick: ev =>
        {
            box.toggleMaximized();
            ev.accepted = true;
        }

        BreadCrumbs {
            visible: ! box.searchBox
            fillWidth: true
            fillHeight: true
            path: box.path

            onChangePath: path =>
            {
                box.setPath(path);
            }

            onSearch: () =>
            {
                box.searchBox = true;
            }
        }

        Label {
            visible: box.searchBox
            marginLeft: theme.paddingSmall
            bold: true
            text: "Search"
        }

        TextEntry {
            id: searchEntry

            visible: box.searchBox
            fillWidth: true
            marginLeft: theme.paddingSmall

            clearButton: true

            onVisibleChanged: () =>
            {
                if (visible)
                {
                    focus = true;
                }
            }

            onTextChanged: () =>
            {
                if (text === "")
                {
                    fsModel.query = text;
                }
            }

            onKeyDown: ev =>
            {
                if (ev.key === "Enter" || ev.key === "Tab")
                {
                    fsModel.query = text;
                }
            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            icon: "ui-search"

            onClick: () =>
            {
                fsModel.query = searchEntry.text;
            }
        }

        Button {
            visible: ! box.searchBox && selector.selection.size > 0 && filesBag.length === 0
            fillHeight: true
            flat: true
            icon: "fs-upload_file"
            text: "Take Selected"

            onClick: ev =>
            {
                box.takeFilesAction();
                ev.accepted = true;
            }
        }

        Button {
            visible: ! box.searchBox && filesBag.length > 0
            fillHeight: true
            flat: true
            icon: "fs-save"
            text: "Drop Here (" + filesBag.length + ")"

            onClick: ev =>
            {
                menuT().popup(self);
                ev.accepted = true;
            }

            property menuT: template Menu {

                MenuItem {
                    text: "Copy"
                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            statusLabel.text = "Copying: " + box.fs.filename(uri);
                            box.fs.copy(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                                statusLabel.text = "";
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Copying File", "" + err);
                                statusLabel.text = "";
                            });
                        });
                    }
                }

                MenuItem {
                    text: "Move"

                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            box.fs.move(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Moving File", "" + err);
                            });
                        });
                        filesBag = [];
                    }
                }

                MenuSeparator { }

                MenuItem {
                    text: "Clear"

                    onClick: () =>
                    {
                        filesBag = [];
                    }
                }

                MenuSeparator { }

                Repeater {
                    model: filesBag.length

                    delegate: template MenuItem {
                        enabled: false
                        text: low.escapeMarkup(filesBag[modelData.index].name)
                    }
                }

            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            text: "Close Search"

            onClick: ev =>
            {
                fsModel.query = "";
                searchEntry.text = "";
                box.searchBox = false;

                ev.accepted = true;
            }
        }
    }

    Box {
        fillWidth: true
        fillHeight: true
        color: theme.secondaryBackgroundColor
        layout: "row"

        Image {
            id: backdrop

            visible: status === "success"
            position: "free"
            fillWidth: true
            fillHeight: true
            fitMode: "cover"

            fsModel.onSizeChanged: () =>
            {
                source = "";
                if (fsModel.size > 0)
                {
                    const items = fsModel.getFiles(f => f.name === "background.jpg");
                    if (items.length > 0)
                    {
                        source = items[0].path;
                    }
                }
            }
        }

        Box {
            visible: backdrop.visible
            position: "free"
            fillWidth: true
            fillHeight: true
            color: parent.color.alpha(0.8)
        }

        // content box
        Box {
            id: contentBox

            fillWidth: true
            fillHeight: true
            layout: "column" //bboxWidth > bboxHeight ? "row" : "column"

            DropArea {
                visible: ! fileViewer.maximized
                //marginLeft: navbar.bboxWidth
                fillWidth: true
                fillHeight: true

                onDropAccept: (ev) =>
                {
                    if (ev.types.includes("Files"))
                    {
                        ev.dropEffect = "copy";
                        ev.accepted = true;
                    }
                    else if (ev.types.includes("text/plain"))
                    {
                        ev.dropEffect = ev.original.shiftKey ? "copy" : "move";
                        ev.accepted = true;
                    }
                }

                onDrop: (ev) =>
                {
                    //console.log(JSON.stringify(ev));

                    for (let i = 0; i < ev.items.length; ++i)
                    {
                        const item = ev.items[i];
                        if (item.kind !== "file")
                        {
                            continue;
                        }
                        const fileItem = item.webkitGetAsEntry();
                        statusLabel.text = fileItem.name;

                        const progressCb = (name, progress) =>
                        {
                            statusLabel.text = low.escapeMarkup(name) + " " + Math.round(progress * 100) + "%";
                        };

                        statusSpinner.counter += 1;
                        uploadfiles.uploadRecursive(fileItem, box.fs, box.path, progressCb)
                        .then(() =>
                        {
                            statusSpinner.counter -= 1;
                            statusLabel.text = "";
                        })
                        .catch(err =>
                        {
                            statusSpinner.counter -= 1;
                            statusLabel.text = "";
                            showErrorDialog("Error Uploading File", "" + err);
                        });

                        /*
                        box.fs.write(box.fs.pathJoin(box.path, box.fs.encodeName(fileItem.name)), fileItem)
                        .then(() =>
                        {
                            statusLabel.text = "";
                        })
                        .catch(err =>
                        {
                            statusLabel.text = "";
                            showErrorDialog("Error Uploading File", "" + err);
                        });
                        */
                    }

                    if (ev.data["text/plain"])
                    {
                        const uris = ev.data["text/plain"].split("\r\n");
                        console.log(JSON.stringify(uris));
                        uris.forEach(uri =>
                        {
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            console.log("DROP EFFECT " + ev.dropEffect);
                            if (ev.dropEffect === "copy")
                            {
                                statusLabel.text = "Copying: " + box.fs.filename(uri);
                                box.fs.copy(uri, destPath)
                                .then(() =>
                                {
                                    statusLabel.text = "";
                                    console.log("files copied");
                                })
                                .catch(err =>
                                {
                                    statusLabel.text = "";
                                    showErrorDialog("Error Copying File", "" + err);
                                });
                            }
                            else
                            {
                                box.fs.move(uri, destPath)
                                .then(() =>
                                {
                                    console.log("files moved");
                                })
                                .catch(err =>
                                {
                                    showErrorDialog("Error Moving File", "" + err);
                                });
                            }
                        });
                    }
                }

                MouseBox {
                    fillWidth: true
                    fillHeight: true
                    layout: "row"

                    onClick: ev =>
                    {
                        ev.accepted = true;
                        selector.clear();
                    }

                    onContextMenu: ev =>
                    {
                        ev.accepted = true;
                        const menu = fileMenuT();
                        menu.popup(null);
                    }

                    onKeyDown: ev =>
                    {
                        if (ev.altKey)
                        {
                            if (ev.key === "r")
                            {
                                ev.accepted = true;
                                box.renameAction();
                            }
                        }
                        else if (ev.key === "Delete")
                        {
                            ev.accepted = true;
                            box.deleteAction();
                        }
                        else if (ev.key === "Enter")
                        {
                            ev.accepted = true;
                            box.openAction();
                        }
                        else if (ev.key === "Backspace")
                        {
                            ev.accepted = true;
                            box.goBackAction();
                        }
                    }

                    IndexScroller {
                        id: navbar

                        labelSize: theme.itemHeightSmall
                        //width: orientation === "vertical" ? labelsize : -1
                        fillHeight: true

                        orientation: parent.layout === "row" ? "vertical" : "horizontal"

                        target: fsview
                        getLabel: idx =>
                        {
                            const item = fsModel.at(idx);
                            if (fsModel.sortRole === "time")
                            {
                                return new Date(item.mtime * 1000).toDateString();
                            }
                            else if (fsModel.sortRole === "size")
                            {
                                let size = Math.ceil(item.size / 1024);
                                const units = ["KB", "MB", "GB", "TB"];

                                for (let i = 0; i < units.length; ++i)
                                {
                                    const unit = units[i];
                                    if (size < 1024)
                                    {
                                        return (i === 0 ? size : size.toFixed(1)) + " " + unit;
                                    }
                                    size /= 1024;
                                }
                                return "" + item.size;
                            }
                            else
                            {
                                return item.name[0].toUpperCase();
                            }
                        }
                    }

                    ListView {
                        id: fsview

                        property displayMode: "grid"

                        visible: ! fsModel.loading
                        fillWidth: true
                        fillHeight: true
                        canFocus: true

                        cellWidth: displayMode === "list" ? bbox.width - 1
                                                          : (theme.itemWidthSmall / 2) * (sizeSelector.scale + 6)
                        cellHeight: displayMode === "list" ? (theme.itemHeightMedium / 2) * (sizeSelector.scale + 2)
                                                           : cellWidth + theme.fontSizeMedium * 1.2 * 4
                        cacheMargin: cellHeight //contentHeight

                        orientation: bboxHeight < cellHeight + theme.paddingLarge ? "horizontal" : "vertical"

                        model: fsModel

                        onCountChanged: () =>
                        {
                            wait(0).then(() => { positionViewAt(0); });
                        }

                        delegate: template Draggable {

                            onXChanged: () =>
                            {
                                if (x < 0)
                                {
                                    fsitem.thumbnail = "";
                                }
                            }

                            onDragStart: ev =>
                            {
                                const uris = [];
                                const items = [];
                                selector.selection.forEach(idx =>
                                {
                                    const item = fsview.model.at(idx);
                                    uris.push(item.path);
                                    items.push(item);
                                });

                                if (uris.length > 0)
                                {
                                    console.log(JSON.stringify(uris));

                                    ev.setData("text/uri-list", uris.join("\r\n"));
                                    ev.setData("text/plain", uris.join("\r\n"));
                                    ev.setData("text/x-fileitems", JSON.stringify(items));
                                    ev.accepted = true;
                                }
                            }

                            FSItem {
                                id: fsitem

                                property inView: file &&
                                                parent.x >= 0 &&
                                                parent.y >= fsview.contentY - fsview.cellHeight &&
                                                parent.y <= fsview.contentY + fsview.bboxHeight

                                property readyForThumbnail: inView && ! fsview.scrolling && ! fsview.rendering

                                fillWidth: true
                                fillHeight: true

                                displayMode: fsview.displayMode
                                highlighted: selector.selection.has(parent.modelData.index)

                                file: parent.modelData.value

                                onReadyForThumbnailChanged: () =>
                                {
                                    if (readyForThumbnail && thumbnail === "")
                                    {
                                        const forPath = file.path;

                                        const condition = () =>
                                        {
                                            return lifeCycleStatus !== "destroyed" &&
                                                file.path === forPath &&
                                                thumbnail === "" &&
                                                readyForThumbnail;
                                        }

                                        thumbnail = "";
                                        thumbnailer.generate(box.fs, file, condition)
                                        .then(safeCallback(blob =>
                                        {
                                            if (blob)
                                            {
                                                thumbnail = blobUrl(blob);
                                            }
                                        }, condition))
                                        .catch(err =>
                                        {

                                        });
                                    }

                                }

                                onPointerDown: (ev) =>
                                {
                                    const idx = parent.modelData.index;

                                    if (ev.original.ctrlKey)
                                    {
                                        selector.select(idx, "toggle");
                                    }
                                    else if (ev.original.shiftKey)
                                    {
                                        selector.select(idx, "range");
                                    }
                                    else if (! selector.selection.has(idx))
                                    {
                                        selector.select(idx, "replace");
                                    }
                                }

                                onClick: (ev) =>
                                {
                                    ev.accepted = true;
                                    if (ev.original.shiftKey || ev.original.ctrlKey || ev.buttons !== 1)
                                    {
                                        return;
                                    }

                                    box.openAction();
                                }
                            }

                            //Label { text: parent.y; color: "red"; fontSize: theme.fontSizeSmall }
                        }

                        model.onPathChanged: () =>
                        {
                            selector.clear();
                            thumbnailer.cancel();
                        }

                        ListViewSelector {
                            id: selector
                            multiple: true

                            /*
                            onSelectionChanged: () =>
                            {
                                const items = [];
                                selection.forEach(idx => items.push(fsModel.at(idx)));
                                filesBag = items;
                                filesBagSource = box.objectId;
                            }
                            */
                        }

                        OverflowScroller { stepSize: theme.paddingLarge }
                        ScrollIndicator { orientation: "horizontal" }
                        ScrollIndicator { orientation: "vertical" }
                    }

                    Label {
                        visible: ! fsview.visible

                        position: "free"
                        x: (parent.bboxWidth - bboxWidth) / 2
                        y: (parent.bboxHeight - bboxHeight) / 2
                        fontSize: theme.fontSizeLarge
                        text: "[icon:ui-spinner5]"
                    }

                    property fileMenuT: template Menu {
                        MenuItem {
                            text: "New Directory"
                            onClick: () =>
                            {
                                box.newDirectoryAction();
                            }
                        }

                        MenuItem {
                            text: "New File"
                            onClick: () =>
                            {
                                box.newFileAction();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            enabled: selector.selection.size > 0
                            text: "Rename"
                            onClick: () =>
                            {
                                box.renameAction();
                            }
                        }

                        MenuItem {
                            enabled: selector.selection.size > 0
                            text: "Delete"
                            onClick: () =>
                            {
                                box.deleteAction();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Download"
                            onClick: () =>
                            {
                                box.downloadAction();
                            }
                        }
                    }
                }

            }

            FileViewer {
                id: fileViewer

                visible: false
                fillWidth: maximized || parent.bboxWidth <= parent.bboxHeight
                fillHeight: maximized || parent.bboxWidth > parent.bboxHeight
                width: parent.bboxWidth - fsview.cellWidth - theme.paddingMedium
                height: parent.bboxHeight - fsview.cellHeight - theme.paddingMedium

                order: parent.layout === "column" ? -1 : 0

                fs: box.fs

                onCurrentChanged: () =>
                {
                    if (current !== -1 && ! visible)
                    {
                        maximized = true;
                        visible = true;
                    }
                }

                onVisibleChanged: () =>
                {
                    if (visible)
                    {
                        console.log("hide status bar");
                        doc.showStatusBar = false;
                    }
                    else
                    {
                        console.log("show status bar");
                        doc.showStatusBar = true;
                    }
                }
            }
        }

        // banner
        Box {
            id: banner

            visible: ! fileViewer.maximized && bannerLabel.text !== ""

            width: parent.bboxWidth / 3
            fillHeight: true
            color: theme.contentBackgroundColor
            overflowBehavior: "scroll"

            layout: "column"

            fsModel.onSizeChanged: () =>
            {
                const items = fsModel.getFiles(f => f.name === "description.txt");
                if (items.length > 0)
                {
                    box.fs.read(items[0].path)
                    .then(blob => { return blob.text(); })
                    .then(data =>
                    {
                        console.log(data);
                        bannerLabel.text = data;
                    })
                    .catch(err => { });
                }
                else
                {
                    bannerLabel.text = "";
                }

                const items2 = fsModel.getFiles(f => f.name === "cover.jpg");
                if (items2.length > 0)
                {
                    bannerImage.source = items2[0].path;
                }
                else
                {
                    bannerImage.source = "";
                }
            }

            Image {
                id: bannerImage

                visible: status === "success"

                marginTop: theme.paddingLarge
                marginLeft: theme.paddingLarge
                width: theme.itemWidthLarge
                height: width
                fitMode: "contain"
            }

            Label {
                id: bannerLabel

                fillWidth: true
                marginTop: theme.paddingLarge
                marginLeft: theme.paddingLarge
                marginRight: theme.paddingLarge
                marginBottom: theme.paddingLarge
                literal: true
                overflowBehavior: "wrap"
            }

            OverflowScroller { }
        }

    }




    // status bar
    Box {
        visible: ! fileViewer.maximized
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor
        layout: "center-row"

        Button {
            id: thumbnailCheckbox

            fillHeight: true
            flat: true
            icon: "media-image"
            checked: false

            onClick: (ev) =>
            {
                checked = ! checked;
                ev.accepted = true;
            }
        }

        Button {
            id: sortSelector

            property role: ["name", "time", "size"][selection % 3]
            property ascending: selection < 3
            property selection: 0

            property model: ListModel {
                data: [
                    { icon: "ui-sort-alpha-asc", label: "By Name" },
                    { icon: "ui-sort-numeric-asc", label: "By Date" },
                    { icon: "ui-sort-amount-asc", label: "By Size" },
                    { icon: "ui-sort-alpha-desc", label: "By Name" },
                    { icon: "ui-sort-numeric-desc", label: "By Date" },
                    { icon: "ui-sort-amount-desc", label: "By Size" }
                ]
            }

            fillHeight: true
            flat: true
            icon: model.at(selection).icon

            onClick: ev =>
            {
                ev.accepted = true;
                const menu = menuT();
                menu.popup(self);
            }

            property menuT: template Menu {
                Repeater {
                    model: sortSelector.model

                    delegate: template MenuItem {
                        icon: modelData.value.icon
                        text: modelData.value.label

                        onClick: () =>
                        {
                            sortSelector.selection = modelData.index;
                            thisMenu.close();
                        }
                    }
                }
            }
        }

        Label {
            marginLeft: theme.paddingSmall
            text: fsview.count + " items"
        }

        Label {
            id: statusSpinner

            property counter: 0

            visible: counter > 0
            marginLeft: theme.paddingSmall
            text: "[icon:ui-spinner5] Uploading"
        }

        Label {
            id: statusLabel

            fillWidth: true
            marginLeft: theme.paddingSmall
            overflowBehavior: "ellipsis"
        }

        Slider {
            id: sizeSelector

            property scale: Math.round(seekValue)

            width: theme.itemWidthMedium
            minValue: 0
            maxValue: 6
            value: 1

            styleOfHandle: template Box {
                width: height
                height: theme.itemHeightSmall / 2
                marginTop: (parent.bboxHeight - bboxHeight) / 2
                borderRadius: width / 2
                color: theme.primaryColor
            }
        }

        Button {
            fillHeight: true
            marginLeft: theme.paddingSmall
            flat: true
            icon: "ui-view_grid"
            checked: fsview.displayMode === "grid"
            onClick: (ev) =>
            {
                fsview.visible = false;
                fsview.displayMode = "grid";
                nextFrame(() => { fsview.visible = true; });
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_list"
            checked: fsview.displayMode === "list"
            onClick: (ev) =>
            {
                fsview.visible = false;
                fsview.displayMode = "list";
                nextFrame(() => { fsview.visible = true; });
                ev.accepted = true;
            }
        }

    }

    property newDirectoryDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New Directory"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New Directory"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property newFileDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New File"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New File.txt"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property renameDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "Rename"

        into buttons Button {
            text: "Rename"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: dialog.name

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        const pos = text.lastIndexOf(".");
                        if (pos !== -1)
                        {
                            selectRange(0, pos);
                        }
                        else
                        {
                            selectRange(0, text.length);
                        }
                    }
                }
            }
        }
    }

}