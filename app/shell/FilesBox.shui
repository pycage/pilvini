require "shellfish/ui";
require "./BreadCrumbs.shui";
require "./downloader.js";
require "./FileViewer.shui";
require "./folderinfo.js" as folderInfo;
require "./FolderInfoDialog.shui";
require "./HistoryScope.shui";
require "./uploadfiles.js" as uploadfiles;
require "./thumbnailgenerator.js";

Box {
    id: box

    property windowIcon: "fs-folder"
    property windowTitle: path

    property fs: null
    property path: ""
    property searchBox: false
    property maximized: false

    event toggleMaximized
    event filesOpen

    fillWidth: true
    fillHeight: true

    //borderRadius: 6

    function setPath(newPath)
    {
        const currentPath = box.path;
        thisHistory.push(() =>
        {
            console.log("go back to " + currentPath);
            selector.clear();
            box.path = currentPath;
        });

        selector.clear();
        box.path = newPath;
    }

    function readFolderInfo()
    {
        const f = async () =>
        {
            const infoObj = await folderInfo.load(fs, path);
            fsModel.path = path;

            bannerLabel.text = infoObj.description || "";
            const background = infoObj.background;
            if (background)
            {
                const url = URL.createObjectURL(background);
                backdrop.source = url;
                wait(500).then(() => { URL.revokeObjectURL(url); });
            }
            else
            {
                backdrop.source = "";
            }
            const icon = infoObj.icon;
            if (icon)
            {
                console.log("set icon");
                console.log(icon);
                const url = URL.createObjectURL(icon);
                bannerImage.source = url;
                wait(500).then(() => {URL.revokeObjectURL(url); });
            }
            else
            {
                bannerImage.source = "";
            }
        };
        f();
    }

    function openAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const file = fsModel.at(idx);

        openFile(file, 0);
    }

    function openMediaBookmarkAction()
    {
        let targetFiles = [];
        if (mediaBookmark.path !== "")
        {
            targetFiles = fsModel.getFiles(f => f.path === mediaBookmark.path);
        }
        else
        {
            targetFiles = fsModel.getFiles(f => f.mimetype.startsWith("audio/") ||
                                                f.mimetype.startsWith("image/") ||
                                                f.mimetype.startsWith("video/"));
        }

        if (targetFiles.length > 0)
        {
            openFile(targetFiles[0], mediaBookmark.mediaPosition);
        }
    }

    function openFile(file, mediaPosition)
    {
        if (file.type === "d")
        {
            // remember current scroll position
            priv.scrollPositionsMap.set(path, fsview.contentY);
            // reset scroll position for new path
            priv.scrollPositionsMap.delete(file.path);
            // open
            setPath(file.path);
        }
        else if (file.mimetype === "application/zip" ||
                 file.mimetype === "application/x-rar-compressed")
        {
            console.log("open ZIP: " + file.path);
            setPath(file.path);
        }
        else if (file.mimetype.startsWith("audio/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("audio/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx, mediaPosition);
        }
        else if (file.mimetype.startsWith("image/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("image/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx, mediaPosition);
        }
        else if (file.mimetype.startsWith("video/"))
        {
            const subtitles = new Set();
            fsModel.getFiles(f => f.mimetype === "text/vtt").forEach(f =>
            {
                subtitles.add(f.path);
            });

            const files = fsModel.getFiles(f => f.mimetype.startsWith("video/"));
            files.forEach(f =>
            {
                const vttPath = f.path.substring(0, f.path.length - 3) + "vtt";
                if (subtitles.has(vttPath))
                {
                    f.subtitles = vttPath;
                }
            });
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx, mediaPosition);
        }
        else if (file.mimetype === "application/pdf" ||
                 file.mimetype === "application/x-shellscript" ||
                 file.mimetype === "application/x-youtube-link" ||
                 file.mimetype.startsWith("image/") ||
                 file.mimetype.startsWith("text/"))
        {
            fileViewer.open([file], 0, mediaPosition);
        }
    }

    function goBackAction()
    {
        console.log("GO BACK")
        thisHistory.back();
        //setPath(fs.dirname(box.path));
    }

    function newDirectoryAction()
    {
        const dlg = newDirectoryDialogT();
        dlg.callback = newName =>
        {
            box.fs.mkdir(box.path, box.fs.encodeName(newName));
        };
        dlg.show();
    }

    function newFileAction()
    {
        const dlg = newFileDialogT();
        dlg.callback = newName =>
        {
            box.fs.write(box.path + "/" + box.fs.encodeName(newName), new core.FileData(""));
        };
        dlg.show();
    }

    function deleteAction()
    {
        if (selector.selection.size === 0)
        {
            return;
        }

        const selected = [...selector.selection];

        showQuestionDialog("Delete File",
                           "Do you want to delete " + selected.length + " items?\n\n" +
                           selected.map(idx => low.escapeMarkup(fsModel.at(idx).name)).join("\n"),
                           () =>
        {
            selected.forEach(idx =>
            {
                box.fs.remove(fsModel.at(idx).path);
            });
        });

        /*
        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        showQuestionDialog("Delete File",
                            "Do you want to delete this file?\n\n" +
                            low.escapeMarkup(item.name),
                            () =>
        {
            box.fs.remove(item.path);
        });
        */
    }

    function renameAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        const dlg = renameDialogT();
        dlg.name = item.name;
        dlg.callback = newName =>
        {
            box.fs.move(item.path, box.fs.pathJoin(box.fs.dirname(item.path), box.fs.encodeName(newName)));
        };
        dlg.show();
    }

    function downloadAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        if (item.type !== "d")
        {
            downloader.download(item.path, item.name);
        }
    }

    function uploadAction(files)
    {
        for (let i = 0; i < files.length; ++i)
        {
            const fileItem = files[i];
            console.log(fileItem);
            statusLabel.text = fileItem.name;

            const progressCb = (name, progress) =>
            {
                statusLabel.text = low.escapeMarkup(name) + " " + Math.round(progress * 100) + "%";
            };

            statusSpinner.counter += 1;
            uploadfiles.uploadRecursive(fileItem, box.fs, box.path, progressCb)
            .then(() =>
            {
                statusSpinner.counter -= 1;
                statusLabel.text = "";
            })
            .catch(err =>
            {
                statusSpinner.counter -= 1;
                statusLabel.text = "";
                showErrorDialog("Error Uploading File", "" + err);
            });
        }
    }

    function copyLinkAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        const url = window.location.origin + item.path;
        window.navigator.clipboard.writeText(url);
    }

    function takeFilesAction()
    {
        if (selector.selection.size === 0)
        {
            return;
        }

        const items = [];
        selector.selection.forEach(idx => items.push(fsModel.at(idx)));

        filesBag = items;
        filesBagSource = box.objectId;
    }

    onPathChanged: () =>
    {
        thumbnailer.filesystem.sync();
        readFolderInfo();
    }

    Object {
        id: priv

        property scrollPositionsMap: new Map()
    }

    HistoryScope { id: thisHistory }

    Downloader { id: downloader }

    RpcProxy {
        id: rpcProxy

        endpoint: "/::rpc"

        function update()
        {
            invoke("diskInfo")
            .then(async diskInfo =>
            {
                console.log(diskInfo);
                const info = (await diskInfo.free())[0];

                diskFreeBox.free = info.free;
                diskFreeBox.total = info.total;
            });
        }

        box.onPathChanged: () => { update(); }

        onStatusChanged: () =>
        {
            if (status === "disconnected")
            {
                thisDocument.showErrorDialog("Connection Lost", "The connection to the server was lost.");
            }
        }
    }

    Object {
        id: mediaBookmark

        property path: ""
        property mediaPosition: 0
        property name: ""

        function load()
        {
            const bookmarkFile = box.path + "/pilvini-media.bookmark";
            
            path = "";
            mediaPosition = 0;
            name = "";
            
            box.fs.exists(bookmarkFile)
            .then(safeCallback(async ok =>
            {
                if (ok)
                {
                    const fileData = await box.fs.read(bookmarkFile);
                    const data = await fileData.text();
                    if (data !== "")
                    {
                        const obj = JSON.parse(data);
                        path = obj.path;
                        mediaPosition = obj.mediaPosition;
                        name = obj.name;
                    }
                }
            }))
            .catch(err => { console.error(err); });
        }

        function save()
        {
            const obj = { path: path, mediaPosition: mediaPosition, name: name };
            const data = JSON.stringify(obj);

            const bookmarkFile = box.path + "/pilvini-media.bookmark";
            let fd = null;
            const c = core;
            unresolved {
                fd = new c.FileData(data);
            }
            box.fs.write(bookmarkFile, fd)
            .catch(err => { });
        }

        box.onPathChanged: () => { load(); }
    }

    ThumbnailGenerator {
        id: thumbnailer

        enabled: false
        //filesystem: OfflineFS { volume: "Thumbnails" }
        filesystem: FileFS {
            filesystem: box.fs
            path: box.path + "/.pilvini-thumbnails.cache"

            onStatusChanged: () =>
            {
                if (status === "success" && box.fs)
                {
                    box.fs.list(box.path)
                    .then(files =>
                    {
                        thumbnailer.removeUnused(files);
                    })
                    .catch(err => { });
                }
            }
        }
    }

    FSModel {
        id: fsModel

        property extensionFilter: []

        function makeFileFilter(showHidden, extensions)
        {
            console.log("EXT: " + JSON.stringify(extensions));
            return item =>
            {
                if (item.name.startsWith(".") && ! showHidden)
                {
                    return false;
                }
                const ext = item.name.split(".").pop();
                if (item.type === "f" && extensions.length > 0 && ! showHidden && ! extensions.includes(ext))
                {
                    return false;
                }
                return true;
            };
        }

        filesystem: box.fs
        filter: makeFileFilter(sortSelector.showHidden, fsModel.extensionFilter)
        sorter: makeSorter(sortSelector.role, sortSelector.ascending)

        function getFiles(predicate)
        {
            const result = [];
            for (let i = 0; i < size; ++i)
            {
                const f = at(i);
                if (predicate(f))
                {
                    result.push(f);
                }
            }
            return result;
        }
    }

    // title bar
    MouseBox {
        visible: ! fileViewer.maximized
        //marginTop: box.bboxY < theme.itemHeightMedium ? theme.itemHeightMedium : 0
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor

        layout: "center-row"
        
        onDoubleClick: ev =>
        {
            box.toggleMaximized();
            ev.accepted = true;
        }

        BreadCrumbs {
            id: breadcrumbs

            visible: ! box.searchBox
            fill: true
            path: box.path

            onChangePath: path =>
            {
                box.setPath(path);
            }

            onSearch: () =>
            {
                box.searchBox = true;
            }
        }

        Label {
            visible: box.searchBox
            marginLeft: theme.paddingSmall
            bold: true
            text: "Search"
        }

        TextEntry {
            id: searchEntry

            visible: box.searchBox
            fillWidth: true
            marginLeft: theme.paddingSmall

            clearButton: true

            onVisibleChanged: () =>
            {
                if (visible)
                {
                    focus = true;
                }
            }

            onTextChanged: () =>
            {
                if (text === "")
                {
                    fsModel.query = text;
                }
            }

            onKeyDown: ev =>
            {
                if (ev.key === "Enter" || ev.key === "Tab")
                {
                    fsModel.query = text;
                }
            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            icon: "ui-search"

            onClick: () =>
            {
                fsModel.query = searchEntry.text;
            }
        }

        Button {
            visible: ! box.searchBox && selector.selection.size > 0 && filesBag.length === 0
            fillHeight: true
            flat: true
            icon: "fs-upload_file"
            text: "Take Selected"

            onClick: ev =>
            {
                box.takeFilesAction();
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "fs-upload_file"
            text: "Upload"

            onClick: ev =>
            {
                fsel.open(files =>
                {
                    const items = [];
                    for (let i = 0; i < files.length; ++i)
                    {
                        const file = files[i];
                        items.push({
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            lastModified: file.lastModified,
                            isDirectory: false,
                            isFile: true,
                            file: (resolve, reject) => { resolve(file); }
                        });
                    }
                    box.uploadAction(items);
                });
            }

            FileSelector {
                id: fsel
                multiple: true
            }
        }

        Button {
            visible: ! box.searchBox && filesBag.length > 0
            fillHeight: true
            flat: true
            icon: "fs-save"
            text: "Drop Here (" + filesBag.length + ")"

            onClick: ev =>
            {
                menuT().popup(self);
                ev.accepted = true;
            }

            property menuT: template Menu {

                MenuItem {
                    text: "Copy"
                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            statusLabel.text = "Copying: " + box.fs.filename(uri);
                            box.fs.copy(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                                statusLabel.text = "";
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Copying File", "" + err);
                                statusLabel.text = "";
                            });
                        });
                    }
                }

                MenuItem {
                    text: "Move"

                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            box.fs.move(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Moving File", "" + err);
                            });
                        });
                        filesBag = [];
                    }
                }

                MenuSeparator { }

                MenuItem {
                    text: "Clear"

                    onClick: () =>
                    {
                        filesBag = [];
                    }
                }

                MenuSeparator { }

                Repeater {
                    model: filesBag.length

                    delegate: template MenuItem {
                        enabled: false
                        text: low.escapeMarkup(filesBag[modelData.index].name)
                    }
                }

            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            text: "Close Search"

            onClick: ev =>
            {
                fsModel.query = "";
                searchEntry.text = "";
                box.searchBox = false;

                ev.accepted = true;
            }
        }
    }

    Box {
        fillWidth: true
        fillHeight: true
        color: theme.secondaryBackgroundColor
        layout: bboxWidth < bboxHeight ? "column" : "row"

        Image {
            id: backdrop

            visible: status === "success"
            position: "free"
            fillWidth: true
            fillHeight: true
            fitMode: "cover"
        }

        Box {
            visible: backdrop.visible
            position: "free"
            fillWidth: true
            fillHeight: true
            color: parent.color.alpha(0.8)
        }

        // content box
        Box {
            id: contentBox

            fillWidth: true
            fillHeight: true

            DropArea {
                visible: ! fileViewer.maximized
                fillWidth: true
                fillHeight: true

                onDropAccept: (ev) =>
                {
                    if (ev.types.includes("Files"))
                    {
                        ev.dropEffect = "copy";
                        ev.accepted = true;
                    }
                    else if (ev.types.includes("text/plain"))
                    {
                        ev.dropEffect = ev.original.shiftKey ? "copy" : "move";
                        ev.accepted = true;
                    }
                }

                onDrop: (ev) =>
                {
                    //console.log(JSON.stringify(ev));

                    const files = [];
                    for (let i = 0; i < ev.items.length; ++i)
                    {
                        const item = ev.items[i];
                        if (item.kind === "file")
                        {
                            files.push(item.webkitGetAsEntry());
                        }
                    }
                    box.uploadAction(files);

                    if (ev.data["text/plain"])
                    {
                        const uris = ev.data["text/plain"].split("\r\n");
                        console.log(JSON.stringify(uris));
                        uris.forEach(uri =>
                        {
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            console.log("DROP EFFECT " + ev.dropEffect);
                            if (ev.dropEffect === "copy")
                            {
                                statusLabel.text = "Copying: " + box.fs.filename(uri);
                                box.fs.copy(uri, destPath)
                                .then(() =>
                                {
                                    statusLabel.text = "";
                                    console.log("files copied");
                                })
                                .catch(err =>
                                {
                                    statusLabel.text = "";
                                    showErrorDialog("Error Copying File", "" + err);
                                });
                            }
                            else
                            {
                                box.fs.move(uri, destPath)
                                .then(() =>
                                {
                                    console.log("files moved");
                                })
                                .catch(err =>
                                {
                                    showErrorDialog("Error Moving File", "" + err);
                                });
                            }
                        });
                    }
                }

                MouseBox {
                    fillWidth: true
                    fillHeight: true
                    layout: "row"

                    onClick: ev =>
                    {
                        ev.accepted = true;
                        selector.clear();
                    }

                    onContextMenu: ev =>
                    {
                        ev.accepted = true;
                        const menu = fileMenuT();
                        menu.popup(null);
                    }

                    onKeyDown: ev =>
                    {
                        if (ev.altKey)
                        {
                            if (ev.key === "r")
                            {
                                ev.accepted = true;
                                box.renameAction();
                            }
                        }
                        else if (ev.key === "Delete")
                        {
                            ev.accepted = true;
                            box.deleteAction();
                        }
                        else if (ev.key === "Enter")
                        {
                            ev.accepted = true;
                            box.openAction();
                        }
                        else if (ev.key === "Backspace")
                        {
                            ev.accepted = true;
                            box.goBackAction();
                        }
                    }

                    IndexScroller {
                        labelSize: theme.itemHeightSmall
                        //width: orientation === "vertical" ? labelsize : -1
                        fillHeight: true
                        width: theme.itemWidthMedium

                        orientation: parent.layout === "row" ? "vertical" : "horizontal"

                        target: fsview

                        getLabel: idx =>
                        {
                            const item = fsModel.at(idx);
                            const type = item.type === "d" ? "/"
                                                           : " ";

                            if (sortSelector.role === "mtime")
                            {
                                const d = new Date(item.mtime * 1000);
                                return type + ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][d.getMonth()] + " '" + (d.getFullYear() % 100);
                            }
                            else if (sortSelector.role === "size")
                            {
                                let size = Math.ceil(item.size / 1024);
                                const units = ["KB", "MB", "GB", "TB"];

                                for (let i = 0; i < units.length; ++i)
                                {
                                    const unit = units[i];
                                    if (size < 1024)
                                    {
                                        return type + (i === 0 ? size : size.toFixed(1)) + " " + unit;
                                    }
                                    size /= 1024;
                                }
                                return type + item.size;
                            }
                            else
                            {
                                return type + item.name[0].toUpperCase();
                            }
                        }

                        styleOfItem: template Box {

                            property text: parent.text || ""
                            property highlighted: parent.inView || parent.containsMouse
                            property isDirectory: text[0] === "/"

                            fillWidth: true
                            fillHeight: true

                            color: highlighted ? theme.highlightBackgroundColor
                                               : isDirectory ? theme.primaryBackgroundColor
                                                             : "transparent"

                            layout: "center"

                            Label {
                                fontSize: theme.fontSizeSmall
                                color: parent.highlighted ? theme.highlightColor
                                                          : theme.primaryColor
                                bold: true
                                text: parent.text.substring(1)
                            }
                        }
                    }

                    Box {
                        visible: ! fsModel.loading
                        fillWidth: true
                        fillHeight: true

                        ListHeader {
                            id: listHeader

                            visible: fsview.displayMode === "list"

                            model: ListModel {
                                data: [
                                    { title: "Name", width: -1 },
                                    { title: "Type", width: theme.itemWidthMedium },
                                    { title: "Date", width: theme.itemWidthMedium * 2 },
                                    { title: "Size", width: theme.itemWidthMedium * 1.5 }
                                ]
                            }

                            onColumnClick: idx =>
                            {
                                if (idx === 0)
                                {
                                    sortSelector.selection = 0;
                                }
                                else if (idx === 2)
                                {
                                    sortSelector.selection = 1;
                                }
                                else if (idx === 3)
                                {
                                    sortSelector.selection = 2;
                                }
                            }
                        }

                        ListView {
                            id: fsview

                            property displayMode: "compact"
                            property placeView: false

                            visible: ! fsModel.loading
                            fillWidth: true
                            fillHeight: true
                            canFocus: true

                            cellWidth: displayMode === "list" ? bboxWidth - 1
                                     : displayMode === "grid" ? theme.itemWidthLarge
                                                              : bboxWidth / Math.max(1, Math.floor(bboxWidth / (cellHeight * 3)))
                            cellHeight: displayMode === "list" ? theme.fontSizeMedium * 2
                                      : displayMode === "grid" ? cellWidth + theme.fontSizeMedium * 1.2 * 5
                                                               : theme.fontSizeMedium * 5

                            cacheMargin: cellHeight * 2 //contentHeight

                            orientation: visible && ancestorsVisible && bboxHeight < cellHeight + theme.paddingLarge ? "horizontal" : "vertical"

                            model: fsModel

                            onCountChanged: () =>
                            {
                                placeView = true;
                            }

                            onContentHeightChanged: () =>
                            {
                                if (placeView)
                                {
                                    placeView = false;
                                    contentY = priv.scrollPositionsMap.get(box.path) || 0;
                                }
                            }

                            delegate: template Draggable {

                                onXChanged: () =>
                                {
                                    if (x < 0)
                                    {
                                        fsitem.thumbnail = "";
                                    }
                                }

                                onDragStart: ev =>
                                {
                                    const uris = [];
                                    const items = [];
                                    selector.selection.forEach(idx =>
                                    {
                                        const item = fsview.model.at(idx);
                                        uris.push(item.path);
                                        items.push(item);
                                    });

                                    if (uris.length > 0)
                                    {
                                        console.log(JSON.stringify(uris));

                                        ev.setData("text/uri-list", uris.join("\r\n"));
                                        ev.setData("text/plain", uris.join("\r\n"));
                                        ev.setData("text/x-fileitems", JSON.stringify(items));
                                        ev.accepted = true;
                                    }
                                }

                                FSItem {
                                    id: fsitem

                                    property inView: file &&
                                                     parent.x >= 0 &&
                                                     parent.y >= fsview.contentY - fsview.cellHeight &&
                                                     parent.y <= fsview.contentY + fsview.bboxHeight

                                    property readyForThumbnail: inView && thumbnailer.filesystem.status === "success" // && ! fsview.scrolling //&& ! fsview.rendering

                                    fillWidth: true
                                    fillHeight: true

                                    displayMode: fsview.displayMode
                                    highlighted: selector.selection.has(modelData.index)

                                    file: modelData.value
                                    columnWidths: listHeader.columnWidths

                                    onReadyForThumbnailChanged: () =>
                                    {
                                        if (readyForThumbnail && thumbnail === "")
                                        {
                                            const forPath = file.path;

                                            const condition = () =>
                                            {
                                                return lifeCycleStatus !== "destroyed" &&
                                                    file.path === forPath &&
                                                    thumbnail === "" &&
                                                    readyForThumbnail;
                                            }

                                            thumbnail = "";

                                            const f = async () =>
                                            {
                                                const cached = await thumbnailer.cached(box.fs, file);
                                                if (! condition())
                                                {
                                                    return;
                                                }

                                                if (cached)
                                                {
                                                    thumbnail = blobUrl(cached);
                                                    return;
                                                }

                                                const newThumbnail = await thumbnailer.generate(box.fs, file, condition);
                                                if (! condition())
                                                {
                                                    return;
                                                }

                                                if (newThumbnail)
                                                {
                                                    thumbnail = blobUrl(newThumbnail);
                                                }
                                            };

                                            f()
                                            .then(() => { })
                                            .catch(err => { console.error(err); });
                                        }

                                    }

                                    onPointerDown: (ev) =>
                                    {
                                        const idx = modelData.index;

                                        if (ev.original.ctrlKey)
                                        {
                                            selector.select(idx, "toggle");
                                        }
                                        else if (ev.original.shiftKey)
                                        {
                                            selector.select(idx, "range");
                                        }
                                        else if (! selector.selection.has(idx))
                                        {
                                            selector.select(idx, "replace");
                                        }
                                    }

                                    onClick: (ev) =>
                                    {
                                        ev.accepted = true;
                                        if (ev.original.shiftKey || ev.original.ctrlKey || ev.buttons !== 1)
                                        {
                                            return;
                                        }

                                        box.openAction();
                                    }
                                }

                                //Label { text: parent.y; color: "red"; fontSize: theme.fontSizeSmall }
                            }

                            model.onPathChanged: () =>
                            {
                                selector.clear();
                                thumbnailer.cancel();
                            }

                            ListViewSelector {
                                id: selector
                                multiple: true

                                /*
                                onSelectionChanged: () =>
                                {
                                    const items = [];
                                    selection.forEach(idx => items.push(fsModel.at(idx)));
                                    filesBag = items;
                                    filesBagSource = box.objectId;
                                }
                                */
                            }

                            OverflowScroller { stepSize: theme.paddingLarge }
                            ScrollIndicator { orientation: "horizontal" }
                            ScrollIndicator { orientation: "vertical" }
                        }

                        // media bookmark bar
                        Box {
                            visible: mediaBookmark.path !== ""
                            fillWidth: true
                            height: theme.itemHeightMedium
                            layout: "center-row"

                            Button {
                                //visible: mediaBookmark.path !== ""
                                fillHeight: true
                                flat: true
                                icon: "media-play"
                                text: mediaBookmark.path !== "" ? "Continue" : "Start"

                                onClick: () =>
                                {
                                    openMediaBookmarkAction();
                                }
                            }

                            Label {
                                fillWidth: true
                                marginLeft: theme.paddingLarge
                                marginRight: theme.paddingSmall
                                overflowBehavior: "ellipsis"
                                text: low.escapeMarkup(mediaBookmark.name)
                            }

                            Box {
                                position: "free"
                                fillWidth: true
                                height: 1
                                color: theme.primaryColor
                            }
                        }
                    }


                    Label {
                        visible: ! fsview.visible

                        position: "free"
                        x: (parent.bboxWidth - bboxWidth) / 2
                        y: (parent.bboxHeight - bboxHeight) / 2
                        fontSize: theme.fontSizeLarge
                        text: "[icon:ui-spinner5]"
                    }

                    property fileMenuT: template Menu {
                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Open New Tab"
                            onClick: () =>
                            {
                                const idx = [...selector.selection][0];
                                const file = fsModel.at(idx);
                                if (file.type === "d")
                                {
                                    openNewTab(box.fs, file.path);
                                }
                            }
                        }

                        MenuSeparator { }

                        MenuExpander {
                            text: "New"

                            MenuItem {
                                text: "Directory"
                                onClick: () =>
                                {
                                    box.newDirectoryAction();
                                }
                            }

                            MenuItem {
                                text: "File"
                                onClick: () =>
                                {
                                    box.newFileAction();
                                }
                            }
                        }

                        MenuExpander {
                            enabled: selector.selection.size === 1
                            text: "Set as"

                            MenuItem {
                                text: "Folder Icon"
                                onClick: () =>
                                {
                                    const m = fsModel;
                                    const f = async () =>
                                    {
                                        const infoObj = await folderInfo.load(box.fs, box.path);
                                        const idx = [...selector.selection][0];
                                        const file = m.at(idx);

                                        let blob = null;
                                        if (file.mimetype === "audio/mp3")
                                        {
                                            blob = await box.fs.read(file.path + "?view=cover");
                                        }
                                        else if (file.type === "d")
                                        {
                                            const infoObj2 = await folderInfo.load(box.fs, file.path);
                                            blob = infoObj2.icon;
                                        }
                                        else
                                        {
                                            blob = await box.fs.read(file.path);
                                        }

                                        infoObj.icon = blob;
                                        await folderInfo.save(box.fs, box.path, infoObj);
                                        box.readFolderInfo();
                                    };
                                    f();
                                }
                            }

                            MenuItem {
                                text: "Folder Background"
                                onClick: () =>
                                {
                                    const m = fsModel;
                                    const f = async () =>
                                    {
                                        const infoObj = await folderInfo.load(box.fs, box.path);
                                        const idx = [...selector.selection][0];
                                        const file = m.at(idx);
                                        const blob = await box.fs.read(file.mimetype === "audio/mp3" ? file.path + "?view=cover" : file.path);
                                        infoObj.background = blob;
                                        await folderInfo.save(box.fs, box.path, infoObj);
                                        box.readFolderInfo();
                                    };
                                    f();
                                }
                            }

                            MenuItem {
                                text: "Folder Description"
                                onClick: () =>
                                {
                                    const m = fsModel;
                                    const f = async () =>
                                    {
                                        const infoObj = await folderInfo.load(box.fs, box.path);
                                        const idx = [...selector.selection][0];
                                        const file = m.at(idx);
                                        const blob = await box.fs.read(file.path);
                                        const text = await blob.text();
                                        infoObj.description = text;
                                        await folderInfo.save(box.fs, box.path, infoObj);
                                        box.readFolderInfo();
                                    };
                                    f();
                                }
                            }
                        }

                        MenuItem {
                            text: "Folder Properties"
                            onClick: () =>
                            {
                                const dlg = box.folderInfoDialogT();
                                dlg.show();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            enabled: selector.selection.size > 0
                            text: "Rename"
                            onClick: () =>
                            {
                                box.renameAction();
                            }
                        }

                        MenuItem {
                            enabled: selector.selection.size > 0
                            text: "Delete"
                            onClick: () =>
                            {
                                box.deleteAction();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Copy Link"
                            onClick: () =>
                            {
                                box.copyLinkAction();
                            }
                        }

                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Download"
                            onClick: () =>
                            {
                                box.downloadAction();
                            }
                        }
                    }
                }

            }

            FileViewer {
                id: fileViewer

                visible: false
                fillWidth: true
                fillHeight: true

                order: parent.layout === "column" ? -1 : 0

                fs: box.fs

                onCurrentChanged: () =>
                {
                    if (current !== -1 && ! visible)
                    {
                        maximized = true;
                        visible = true;
                    }
                }

                onMediaBookmarkUpdated: (path, mediaPosition, name) =>
                {
                    mediaBookmark.path = path;
                    mediaBookmark.mediaPosition = mediaPosition;
                    mediaBookmark.name = name;
                }

                onVisibleChanged: () =>
                {
                    if (visible)
                    {
                        console.log("hide status bar");
                        doc.showStatusBar = false;
                    }
                    else
                    {
                        console.log("show status bar");
                        doc.showStatusBar = true;
                        console.log(mediaBookmark.objectLocation);
                        mediaBookmark.save();
                    }
                }
            }

        }

        // banner
        Box {
            id: banner

            visible: ! fileViewer.visible && bannerLabel.text !== ""

            width: parent.bboxWidth / 3
            height: parent.bboxHeight / 3
            fillWidth: parent.layout === "column"
            fillHeight: parent.layout === "row"
            color: theme.contentBackgroundColor.alpha(0.3)

            layout: "column"

            Label {
                fillWidth: true
                marginTop: theme.paddingLarge
                marginLeft: theme.paddingLarge
                marginRight: theme.paddingLarge
                marginBottom: theme.paddingLarge
                fontSize: theme.fontSizeLarge
                literal: true
                overflowBehavior: "wrap"
                text: breadcrumbs.text
            }

            Image {
                id: bannerImage

                visible: status === "success" && banner.bboxWidth < banner.bboxHeight

                marginLeft: theme.paddingLarge
                width: theme.itemWidthLarge
            }

            Box {
                fillWidth: true
                fillHeight: true
                marginTop: theme.paddingLarge
                overflowBehavior: "scroll"

                Label {
                    id: bannerLabel

                    fillWidth: true
                    marginTop: theme.paddingLarge
                    marginLeft: theme.paddingLarge
                    marginRight: theme.paddingLarge
                    marginBottom: theme.paddingLarge
                    literal: true
                    overflowBehavior: "wrap"
                }

                OverflowScroller { }

                Timer {
                    running: ancestorsVisible && parent.contentHeight > parent.bboxHeight
                    interval: 100
                    repeat: true

                    onTimeout: () =>
                    {
                        if (parent.contentY < parent.contentHeight - parent.bboxHeight)
                        {
                            ++parent.contentY;
                        }
                        else
                        {
                            parent.contentY = 0;
                        }
                    }
                }
            }

        }

    }

    // status bar
    Box {
        visible: ! fileViewer.maximized
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor
        layout: "center-row"

        Button {
            id: sortSelector

            property role: ["name", "mtime", "size"][selection % 3]
            property ascending: selection < 3
            property selection: 0
            property showHidden: false

            property model: ListModel {
                data: [
                    { icon: "ui-sort-alpha-asc", label: "By Name" },
                    { icon: "ui-sort-numeric-asc", label: "By Date" },
                    { icon: "ui-sort-amount-asc", label: "By Size" },
                    { icon: "ui-sort-alpha-desc", label: "By Name" },
                    { icon: "ui-sort-numeric-desc", label: "By Date" },
                    { icon: "ui-sort-amount-desc", label: "By Size" }
                ]
            }

            fillHeight: true
            flat: true
            icon: model.at(selection).icon

            onClick: ev =>
            {
                ev.accepted = true;
                const menu = menuT();
                menu.popup(self);
            }

            property menuT: template Menu {

                MenuItem {
                    icon: sortSelector.showHidden ? "ui-check_box" : "ui-check_box_blank"
                    text: "Show Hidden"

                    onClick: ev =>
                    {
                        ev.accepted = true;
                        sortSelector.showHidden = ! sortSelector.showHidden;
                    }
                }

                MenuItem {
                    icon: thumbnailer.enabled ? "ui-check_box" : "ui-check_box_blank"
                    text: "Generate Thumbnails"

                    onClick: ev =>
                    {
                        ev.accepted = true;
                        thumbnailer.enabled = ! thumbnailer.enabled;
                    }
                }

                MenuSeparator { }
                
                Repeater {
                    model: sortSelector.model

                    delegate: template MenuItem {
                        icon: modelData.value.icon
                        text: modelData.value.label

                        onClick: () =>
                        {
                            sortSelector.selection = modelData.index;
                            thisMenu.close();
                        }
                    }
                }

            }
        }

        Label {
            marginLeft: theme.paddingSmall
            text: fsview.count + " items"
        }

        Label {
            id: statusSpinner

            property counter: 0

            visible: counter > 0
            marginLeft: theme.paddingSmall
            text: "[icon:ui-spinner5] Uploading"
        }

        Label {
            id: statusLabel

            fillWidth: true
            marginLeft: theme.paddingSmall
            overflowBehavior: "ellipsis"
        }

        Box {
            id: diskFreeBox

            property free: 0
            property total: 1

            marginRight: theme.paddingMedium

            Label {
                text: core.formatBytes(diskFreeBox.free) +
                      " of " +
                      core.formatBytes(diskFreeBox.total) +
                      " free"
            }

            Box {
                fillWidth: true
                height: 2
                color: theme.contentBackgroundColor

                Box {
                    width: parent.bboxWidth * (1.0 - (diskFreeBox.free / diskFreeBox.total))
                    fillHeight: true
                    color: theme.primaryColor
                }
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_grid"
            checked: fsview.displayMode === "grid"
            onClick: (ev) =>
            {
                fsview.opacity = 0;
                fsview.displayMode = "grid";
                wait(100).then(() => { fsview.opacity = 1; });
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_list"
            checked: fsview.displayMode === "compact"
            onClick: (ev) =>
            {
                fsview.opacity = 0;
                fsview.displayMode = "compact";
                wait(100).then(() => { fsview.opacity = 1; });
                ev.accepted = true;
            }
        }

    }

    property newDirectoryDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New Directory"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New Directory"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property newFileDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New File"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New File.txt"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property renameDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "Rename"

        into buttons Button {
            text: "Rename"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: dialog.name

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        const pos = text.lastIndexOf(".");
                        if (pos !== -1)
                        {
                            selectRange(0, pos);
                        }
                        else
                        {
                            selectRange(0, text.length);
                        }
                    }
                }
            }
        }
    }

    property linkDialogT: template Dialog {
        id: dialog

        property url: "http://localhost/index.html"

        title: "File Link"

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Close"
            onClick: () => { dialog.parent = null; }
        }

        Html {
            width: 3 * theme.itemWidthLarge
            height: theme.itemHeightMedium
            html: "<a href='" + dialog.url + "'>" + dialog.url + "</a>"
        }
    }

    property folderInfoDialogT: template FolderInfoDialog {
        filesystem: box.fs
        path: box.path
        filesBox: box
    }
}