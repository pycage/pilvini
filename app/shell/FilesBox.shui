require "shellfish/ui";
require "./BreadCrumbs.shui";
require "./downloader.js";
require "./FileViewer.shui";
require "./folderinfo.js" as folderInfo;
require "./FolderInfoDialog.shui";
require "./HistoryScope.shui";
require "./uploadfiles.js" as uploadfiles;
require "./thumbnailgenerator.js";

Box {
    id: box

    property windowIcon: "fs-folder"
    property windowTitle: path

    property fs: null
    property path: "/"
    property searchBox: false
    property maximized: false

    event toggleMaximized
    event filesOpen

    fillWidth: true
    fillHeight: true

    //borderRadius: 6

    function setPath(newPath)
    {
        const currentPath = box.path;
        thisHistory.push(() =>
        {
            console.log("go back to " + currentPath);
            selector.clear();
            box.path = currentPath;
        });

        selector.clear();
        box.path = newPath;
    }

    function readFolderInfo()
    {
        const f = async () =>
        {
            const infoObj = await folderInfo.load(fs, path);
            fsModel.path = path;

            bannerLabel.text = infoObj.description || "";
            const background = infoObj.background;
            if (background)
            {
                const url = URL.createObjectURL(background);
                backdrop.source = url;
                wait(500).then(() => { URL.revokeObjectURL(url); });
            }
            else
            {
                backdrop.source = "";
            }
            const icon = infoObj.icon;
            if (icon)
            {
                console.log("set icon");
                console.log(icon);
                const url = URL.createObjectURL(icon);
                bannerImage.source = url;
                wait(500).then(() => {URL.revokeObjectURL(url); });
            }
            else
            {
                bannerImage.source = "";
            }
        };
        f();
    }

    function openAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const file = fsModel.at(idx);

        if (file.type === "d")
        {
            // remember current scroll position
            priv.scrollPositionsMap.set(path, fsview.contentY);
            // reset scroll position for new path
            priv.scrollPositionsMap.delete(file.path);
            // open
            setPath(file.path);
        }
        else if (file.mimetype === "application/zip" ||
                 file.mimetype === "application/x-rar-compressed")
        {
            console.log("open ZIP: " + file.path);
            setPath(file.path);
        }
        else if (file.mimetype.startsWith("audio/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("audio/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype.startsWith("image/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("image/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype.startsWith("video/"))
        {
            const subtitles = new Set();
            fsModel.getFiles(f => f.mimetype === "text/vtt").forEach(f =>
            {
                subtitles.add(f.path);
            });

            const files = fsModel.getFiles(f => f.mimetype.startsWith("video/"));
            files.forEach(f =>
            {
                const vttPath = f.path.substring(0, f.path.length - 3) + "vtt";
                if (subtitles.has(vttPath))
                {
                    f.subtitles = vttPath;
                }
            });
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype === "application/pdf" ||
                 file.mimetype === "application/x-shellscript" ||
                 file.mimetype === "application/x-youtube-link" ||
                 file.mimetype.startsWith("image/") ||
                 file.mimetype.startsWith("text/"))
        {
            fileViewer.open([file], 0);
        }
    }

    function goBackAction()
    {
        console.log("GO BACK")
        thisHistory.back();
        //setPath(fs.dirname(box.path));
    }

    function newDirectoryAction()
    {
        const dlg = newDirectoryDialogT();
        dlg.callback = newName =>
        {
            box.fs.mkdir(box.path, box.fs.encodeName(newName));
        };
        dlg.show();
    }

    function newFileAction()
    {
        const dlg = newFileDialogT();
        dlg.callback = newName =>
        {
            box.fs.write(box.path + "/" + box.fs.encodeName(newName), new Blob([""]));
        };
        dlg.show();
    }

    function deleteAction()
    {
        if (selector.selection.size === 0)
        {
            return;
        }

        const selected = [...selector.selection];

        showQuestionDialog("Delete File",
                           "Do you want to delete " + selected.length + " items?\n\n" +
                           selected.map(idx => low.escapeMarkup(fsModel.at(idx).name)).join("\n"),
                           () =>
        {
            selected.forEach(idx =>
            {
                box.fs.remove(fsModel.at(idx).path);
            });
        });

        /*
        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        showQuestionDialog("Delete File",
                            "Do you want to delete this file?\n\n" +
                            low.escapeMarkup(item.name),
                            () =>
        {
            box.fs.remove(item.path);
        });
        */
    }

    function renameAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        const dlg = renameDialogT();
        dlg.name = item.name;
        dlg.callback = newName =>
        {
            box.fs.move(item.path, box.fs.pathJoin(box.fs.dirname(item.path), box.fs.encodeName(newName)));
        };
        dlg.show();
    }

    function downloadAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        if (item.type !== "d")
        {
            downloader.download(item.path, item.name);
        }
    }

    function uploadAction(files)
    {
        for (let i = 0; i < files.length; ++i)
        {
            const fileItem = files[i];
            console.log(fileItem);
            statusLabel.text = fileItem.name;

            const progressCb = (name, progress) =>
            {
                statusLabel.text = low.escapeMarkup(name) + " " + Math.round(progress * 100) + "%";
            };

            statusSpinner.counter += 1;
            uploadfiles.uploadRecursive(fileItem, box.fs, box.path, progressCb)
            .then(() =>
            {
                statusSpinner.counter -= 1;
                statusLabel.text = "";
            })
            .catch(err =>
            {
                statusSpinner.counter -= 1;
                statusLabel.text = "";
                showErrorDialog("Error Uploading File", "" + err);
            });
        }
    }

    function copyLinkAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        const url = window.location.origin + item.path;
        window.navigator.clipboard.writeText(url);
    }

    function takeFilesAction()
    {
        if (selector.selection.size === 0)
        {
            return;
        }

        const items = [];
        selector.selection.forEach(idx => items.push(fsModel.at(idx)));

        filesBag = items;
        filesBagSource = box.objectId;
    }

    onPathChanged: () =>
    {
        readFolderInfo();
    }

    Object {
        id: priv

        property scrollPositionsMap: new Map()
    }

    HistoryScope { id: thisHistory }

    Downloader { id: downloader }

    ThumbnailGenerator {
        id: thumbnailer

        enabled: thumbnailCheckbox.checked
        filesystem: OfflineFS { volume: "Thumbnails" }
    }

    FSModel {
        id: fsModel

        property extensionFilter: []

        function makeFileFilter(showHidden, extensions)
        {
            console.log("EXT: " + JSON.stringify(extensions));
            return item =>
            {
                if (item.name.startsWith(".") && ! showHidden)
                {
                    return false;
                }
                const ext = item.name.split(".").pop();
                if (item.type === "f" && extensions.length > 0 && ! showHidden && ! extensions.includes(ext))
                {
                    return false;
                }
                return true;
            };
        }

        filesystem: box.fs
        filter: makeFileFilter(sortSelector.showHidden, fsModel.extensionFilter)
        sorter: makeSorter(sortSelector.role, sortSelector.ascending)

        function getFiles(predicate)
        {
            const result = [];
            for (let i = 0; i < size; ++i)
            {
                const f = at(i);
                if (predicate(f))
                {
                    result.push(f);
                }
            }
            return result;
        }
    }

    // title bar
    MouseBox {
        visible: ! fileViewer.maximized
        marginTop: box.bboxY < theme.itemHeightMedium ? theme.itemHeightMedium : 0
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor

        layout: "center-row"
        
        onDoubleClick: ev =>
        {
            box.toggleMaximized();
            ev.accepted = true;
        }

        BreadCrumbs {
            id: breadcrumbs

            visible: ! box.searchBox
            fillWidth: true
            fillHeight: true
            path: box.path

            onChangePath: path =>
            {
                box.setPath(path);
            }

            onSearch: () =>
            {
                box.searchBox = true;
            }
        }

        Label {
            visible: box.searchBox
            marginLeft: theme.paddingSmall
            bold: true
            text: "Search"
        }

        TextEntry {
            id: searchEntry

            visible: box.searchBox
            fillWidth: true
            marginLeft: theme.paddingSmall

            clearButton: true

            onVisibleChanged: () =>
            {
                if (visible)
                {
                    focus = true;
                }
            }

            onTextChanged: () =>
            {
                if (text === "")
                {
                    fsModel.query = text;
                }
            }

            onKeyDown: ev =>
            {
                if (ev.key === "Enter" || ev.key === "Tab")
                {
                    fsModel.query = text;
                }
            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            icon: "ui-search"

            onClick: () =>
            {
                fsModel.query = searchEntry.text;
            }
        }

        Button {
            visible: ! box.searchBox && selector.selection.size > 0 && filesBag.length === 0
            fillHeight: true
            flat: true
            icon: "fs-upload_file"
            text: "Take Selected"

            onClick: ev =>
            {
                box.takeFilesAction();
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "fs-upload_file"
            text: "Upload"

            onClick: ev =>
            {
                fsel.open(files =>
                {
                    const items = [];
                    for (let i = 0; i < files.length; ++i)
                    {
                        const file = files[i];
                        items.push({
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            lastModified: file.lastModified,
                            isDirectory: false,
                            isFile: true,
                            file: (resolve, reject) => { resolve(file); }
                        });
                    }
                    box.uploadAction(items);
                });
            }

            FileSelector {
                id: fsel
                multiple: true
            }
        }

        Button {
            visible: ! box.searchBox && filesBag.length > 0
            fillHeight: true
            flat: true
            icon: "fs-save"
            text: "Drop Here (" + filesBag.length + ")"

            onClick: ev =>
            {
                menuT().popup(self);
                ev.accepted = true;
            }

            property menuT: template Menu {

                MenuItem {
                    text: "Copy"
                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            statusLabel.text = "Copying: " + box.fs.filename(uri);
                            box.fs.copy(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                                statusLabel.text = "";
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Copying File", "" + err);
                                statusLabel.text = "";
                            });
                        });
                    }
                }

                MenuItem {
                    text: "Move"

                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            box.fs.move(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Moving File", "" + err);
                            });
                        });
                        filesBag = [];
                    }
                }

                MenuSeparator { }

                MenuItem {
                    text: "Clear"

                    onClick: () =>
                    {
                        filesBag = [];
                    }
                }

                MenuSeparator { }

                Repeater {
                    model: filesBag.length

                    delegate: template MenuItem {
                        enabled: false
                        text: low.escapeMarkup(filesBag[modelData.index].name)
                    }
                }

            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            text: "Close Search"

            onClick: ev =>
            {
                fsModel.query = "";
                searchEntry.text = "";
                box.searchBox = false;

                ev.accepted = true;
            }
        }
    }

    Box {
        fillWidth: true
        fillHeight: true
        color: theme.secondaryBackgroundColor
        layout: bboxWidth < bboxHeight ? "column" : "row"

        Image {
            id: backdrop

            visible: status === "success"
            position: "free"
            fillWidth: true
            fillHeight: true
            fitMode: "cover"
        }

        Box {
            visible: backdrop.visible
            position: "free"
            fillWidth: true
            fillHeight: true
            color: parent.color.alpha(0.8)
        }

        // content box
        Box {
            id: contentBox

            fillWidth: true
            fillHeight: true
            layout: bboxWidth > bboxHeight ? "row" : "column"

            DropArea {
                visible: ! fileViewer.maximized
                fillWidth: true
                fillHeight: true

                onDropAccept: (ev) =>
                {
                    if (ev.types.includes("Files"))
                    {
                        ev.dropEffect = "copy";
                        ev.accepted = true;
                    }
                    else if (ev.types.includes("text/plain"))
                    {
                        ev.dropEffect = ev.original.shiftKey ? "copy" : "move";
                        ev.accepted = true;
                    }
                }

                onDrop: (ev) =>
                {
                    //console.log(JSON.stringify(ev));

                    const files = [];
                    for (let i = 0; i < ev.items.length; ++i)
                    {
                        const item = ev.items[i];
                        if (item.kind === "file")
                        {
                            files.push(item.webkitGetAsEntry());
                        }
                    }
                    box.uploadAction(files);

                    if (ev.data["text/plain"])
                    {
                        const uris = ev.data["text/plain"].split("\r\n");
                        console.log(JSON.stringify(uris));
                        uris.forEach(uri =>
                        {
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            console.log("DROP EFFECT " + ev.dropEffect);
                            if (ev.dropEffect === "copy")
                            {
                                statusLabel.text = "Copying: " + box.fs.filename(uri);
                                box.fs.copy(uri, destPath)
                                .then(() =>
                                {
                                    statusLabel.text = "";
                                    console.log("files copied");
                                })
                                .catch(err =>
                                {
                                    statusLabel.text = "";
                                    showErrorDialog("Error Copying File", "" + err);
                                });
                            }
                            else
                            {
                                box.fs.move(uri, destPath)
                                .then(() =>
                                {
                                    console.log("files moved");
                                })
                                .catch(err =>
                                {
                                    showErrorDialog("Error Moving File", "" + err);
                                });
                            }
                        });
                    }
                }

                MouseBox {
                    fillWidth: true
                    fillHeight: true
                    layout: "row"

                    onClick: ev =>
                    {
                        ev.accepted = true;
                        selector.clear();
                    }

                    onContextMenu: ev =>
                    {
                        ev.accepted = true;
                        const menu = fileMenuT();
                        menu.popup(null);
                    }

                    onKeyDown: ev =>
                    {
                        if (ev.altKey)
                        {
                            if (ev.key === "r")
                            {
                                ev.accepted = true;
                                box.renameAction();
                            }
                        }
                        else if (ev.key === "Delete")
                        {
                            ev.accepted = true;
                            box.deleteAction();
                        }
                        else if (ev.key === "Enter")
                        {
                            ev.accepted = true;
                            box.openAction();
                        }
                        else if (ev.key === "Backspace")
                        {
                            ev.accepted = true;
                            box.goBackAction();
                        }
                    }

                    IndexScroller {
                        labelSize: theme.itemHeightSmall
                        //width: orientation === "vertical" ? labelsize : -1
                        fillHeight: true
                        width: theme.itemWidthMedium

                        orientation: parent.layout === "row" ? "vertical" : "horizontal"

                        target: fsview

                        getLabel: idx =>
                        {
                            const item = fsModel.at(idx);
                            const type = item.type === "d" ? "/"
                                                           : " ";

                            if (sortSelector.role === "mtime")
                            {
                                const d = new Date(item.mtime * 1000);
                                return type + ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][d.getMonth()] + " '" + (d.getFullYear() % 100);
                            }
                            else if (sortSelector.role === "size")
                            {
                                let size = Math.ceil(item.size / 1024);
                                const units = ["KB", "MB", "GB", "TB"];

                                for (let i = 0; i < units.length; ++i)
                                {
                                    const unit = units[i];
                                    if (size < 1024)
                                    {
                                        return type + (i === 0 ? size : size.toFixed(1)) + " " + unit;
                                    }
                                    size /= 1024;
                                }
                                return type + item.size;
                            }
                            else
                            {
                                return type + item.name[0].toUpperCase();
                            }
                        }

                        styleOfItem: template Box {

                            property text: parent.text || ""
                            property highlighted: parent.inView || parent.containsMouse
                            property isDirectory: text[0] === "/"

                            fillWidth: true
                            fillHeight: true

                            color: highlighted ? theme.highlightBackgroundColor
                                               : isDirectory ? theme.primaryBackgroundColor
                                                             : "transparent"

                            layout: "center"

                            Label {
                                fontSize: theme.fontSizeSmall
                                color: parent.highlighted ? theme.highlightColor
                                                          : theme.primaryColor
                                bold: true
                                text: parent.text.substring(1)
                            }
                        }
                    }

                    Box {
                        visible: ! fsModel.loading
                        fillWidth: true
                        fillHeight: true

                        ListHeader {
                            id: listHeader

                            visible: fsview.displayMode === "list"

                            model: ListModel {
                                data: [
                                    { title: "Name", width: -1 },
                                    { title: "Type", width: theme.itemWidthMedium },
                                    { title: "Size", width: theme.itemWidthMedium * 1.5 }
                                ]
                            }

                            onColumnClick: idx =>
                            {
                                if (idx === 0)
                                {
                                    sortSelector.selection = 0;
                                }
                                else if (idx === 2)
                                {
                                    sortSelector.selection = 2;
                                }
                            }
                        }

                        ListView {
                            id: fsview

                            property displayMode: "list"

                            visible: ! fsModel.loading
                            fillWidth: true
                            fillHeight: true
                            canFocus: true

                            cellWidth: displayMode === "list" ? bboxWidth - 1
                                                            : (theme.itemWidthSmall / 2) * (sizeSelector.scale + 6)
                            cellHeight: displayMode === "list" ? (theme.itemHeightMedium / 2) * (sizeSelector.scale + 2)
                                                               : cellWidth + theme.fontSizeMedium * 1.2 * 5
                            //cacheMargin: cellHeight //contentHeight

                            orientation: visible && ancestorsVisible && bboxHeight < cellHeight + theme.paddingLarge ? "horizontal" : "vertical"

                            model: fsModel

                            onCountChanged: () =>
                            {
                                wait(100).then(() =>
                                {
                                    contentY = priv.scrollPositionsMap.get(box.path) || 0;
                                });
                            }

                            delegate: template Draggable {

                                onXChanged: () =>
                                {
                                    if (x < 0)
                                    {
                                        fsitem.thumbnail = "";
                                    }
                                }

                                onDragStart: ev =>
                                {
                                    const uris = [];
                                    const items = [];
                                    selector.selection.forEach(idx =>
                                    {
                                        const item = fsview.model.at(idx);
                                        uris.push(item.path);
                                        items.push(item);
                                    });

                                    if (uris.length > 0)
                                    {
                                        console.log(JSON.stringify(uris));

                                        ev.setData("text/uri-list", uris.join("\r\n"));
                                        ev.setData("text/plain", uris.join("\r\n"));
                                        ev.setData("text/x-fileitems", JSON.stringify(items));
                                        ev.accepted = true;
                                    }
                                }

                                FSItem {
                                    id: fsitem

                                    property inView: file &&
                                                    parent.x >= 0 &&
                                                    parent.y >= fsview.contentY - fsview.cellHeight &&
                                                    parent.y <= fsview.contentY + fsview.bboxHeight

                                    property readyForThumbnail: inView && ! fsview.scrolling //&& ! fsview.rendering

                                    fillWidth: true
                                    fillHeight: true

                                    displayMode: fsview.displayMode
                                    highlighted: selector.selection.has(parent.modelData.index)

                                    file: parent.modelData.value
                                    columnWidths: listHeader.columnWidths

                                    onReadyForThumbnailChanged: () =>
                                    {
                                        if (readyForThumbnail && thumbnail === "")
                                        {
                                            const forPath = file.path;

                                            const condition = () =>
                                            {
                                                return lifeCycleStatus !== "destroyed" &&
                                                    file.path === forPath &&
                                                    thumbnail === "" &&
                                                    readyForThumbnail;
                                            }

                                            thumbnail = "";
                                            thumbnailer.generate(box.fs, file, condition)
                                            .then(safeCallback(blob =>
                                            {
                                                if (blob)
                                                {
                                                    thumbnail = blobUrl(blob);
                                                }
                                            }, condition))
                                            .catch(err =>
                                            {

                                            });
                                        }

                                    }

                                    onPointerDown: (ev) =>
                                    {
                                        const idx = parent.modelData.index;

                                        if (ev.original.ctrlKey)
                                        {
                                            selector.select(idx, "toggle");
                                        }
                                        else if (ev.original.shiftKey)
                                        {
                                            selector.select(idx, "range");
                                        }
                                        else if (! selector.selection.has(idx))
                                        {
                                            selector.select(idx, "replace");
                                        }
                                    }

                                    onClick: (ev) =>
                                    {
                                        ev.accepted = true;
                                        if (ev.original.shiftKey || ev.original.ctrlKey || ev.buttons !== 1)
                                        {
                                            return;
                                        }

                                        box.openAction();
                                    }
                                }

                                //Label { text: parent.y; color: "red"; fontSize: theme.fontSizeSmall }
                            }

                            model.onPathChanged: () =>
                            {
                                selector.clear();
                                thumbnailer.cancel();
                            }

                            ListViewSelector {
                                id: selector
                                multiple: true

                                /*
                                onSelectionChanged: () =>
                                {
                                    const items = [];
                                    selection.forEach(idx => items.push(fsModel.at(idx)));
                                    filesBag = items;
                                    filesBagSource = box.objectId;
                                }
                                */
                            }

                            OverflowScroller { stepSize: theme.paddingLarge }
                            ScrollIndicator { orientation: "horizontal" }
                            ScrollIndicator { orientation: "vertical" }
                        }

                    }


                    Label {
                        visible: ! fsview.visible

                        position: "free"
                        x: (parent.bboxWidth - bboxWidth) / 2
                        y: (parent.bboxHeight - bboxHeight) / 2
                        fontSize: theme.fontSizeLarge
                        text: "[icon:ui-spinner5]"
                    }

                    property fileMenuT: template Menu {
                        MenuItem {
                            text: "New Directory"
                            onClick: () =>
                            {
                                box.newDirectoryAction();
                            }
                        }

                        MenuItem {
                            text: "New File"
                            onClick: () =>
                            {
                                box.newFileAction();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            text: "Folder Properties"
                            onClick: () =>
                            {
                                const dlg = box.folderInfoDialogT();
                                dlg.show();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Set As Background"
                            onClick: () =>
                            {
                                const m = fsModel;
                                const f = async () =>
                                {
                                    const infoObj = await folderInfo.load(box.fs, box.path);
                                    const idx = [...selector.selection][0];
                                    const file = m.at(idx);
                                    const blob = await box.fs.read(file.path);
                                    infoObj.background = blob;
                                    await folderInfo.save(box.fs, box.path, infoObj);
                                    box.readFolderInfo();
                                };
                                f();
                            }
                        }

                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Set As Description"
                            onClick: () =>
                            {
                                const m = fsModel;
                                const f = async () =>
                                {
                                    const infoObj = await folderInfo.load(box.fs, box.path);
                                    const idx = [...selector.selection][0];
                                    const file = m.at(idx);
                                    const blob = await box.fs.read(file.path);
                                    const text = await blob.text();
                                    infoObj.description = text;
                                    await folderInfo.save(box.fs, box.path, infoObj);
                                    box.readFolderInfo();
                                };
                                f();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            enabled: selector.selection.size > 0
                            text: "Rename"
                            onClick: () =>
                            {
                                box.renameAction();
                            }
                        }

                        MenuItem {
                            enabled: selector.selection.size > 0
                            text: "Delete"
                            onClick: () =>
                            {
                                box.deleteAction();
                            }
                        }

                        MenuSeparator { }

                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Copy Link"
                            onClick: () =>
                            {
                                box.copyLinkAction();
                            }
                        }

                        MenuItem {
                            enabled: selector.selection.size === 1
                            text: "Download"
                            onClick: () =>
                            {
                                box.downloadAction();
                            }
                        }
                    }
                }

            }

            FileViewer {
                id: fileViewer

                visible: false
                fillWidth: true
                fillHeight: true

                order: parent.layout === "column" ? -1 : 0

                fs: box.fs

                onCurrentChanged: () =>
                {
                    if (current !== -1 && ! visible)
                    {
                        maximized = true;
                        visible = true;
                    }
                }

                onVisibleChanged: () =>
                {
                    if (visible)
                    {
                        console.log("hide status bar");
                        doc.showStatusBar = false;
                    }
                    else
                    {
                        console.log("show status bar");
                        doc.showStatusBar = true;
                    }
                }
            }
        }

        // banner
        Box {
            id: banner

            visible: ! fileViewer.visible && bannerLabel.text !== ""

            width: parent.bboxWidth / 3
            height: parent.bboxHeight / 3
            fillWidth: parent.layout === "column"
            fillHeight: parent.layout === "row"
            color: theme.contentBackgroundColor.alpha(0.3)
            overflowBehavior: "scroll"

            layout: "column"

            Label {
                fillWidth: true
                marginTop: theme.paddingLarge
                marginLeft: theme.paddingLarge
                marginRight: theme.paddingLarge
                marginBottom: theme.paddingLarge
                fontSize: theme.fontSizeLarge
                literal: true
                overflowBehavior: "wrap"
                text: breadcrumbs.text
            }

            Image {
                id: bannerImage

                visible: status === "success" && banner.bboxWidth < banner.bboxHeight

                marginLeft: theme.paddingLarge
                width: theme.itemWidthLarge
                height: width
                fitMode: "contain"
            }

            Label {
                id: bannerLabel

                fillWidth: true
                marginTop: theme.paddingLarge
                marginLeft: theme.paddingLarge
                marginRight: theme.paddingLarge
                marginBottom: theme.paddingLarge
                literal: true
                overflowBehavior: "wrap"
            }

            OverflowScroller { }
        }

    }




    // status bar
    Box {
        visible: ! fileViewer.maximized
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor
        layout: "center-row"

        Button {
            id: thumbnailCheckbox

            fillHeight: true
            flat: true
            icon: "media-image"
            checked: false

            onClick: (ev) =>
            {
                checked = ! checked;
                ev.accepted = true;
            }
        }

        Button {
            id: sortSelector

            property role: ["name", "mtime", "size"][selection % 3]
            property ascending: selection < 3
            property selection: 0
            property showHidden: false

            property model: ListModel {
                data: [
                    { icon: "ui-sort-alpha-asc", label: "By Name" },
                    { icon: "ui-sort-numeric-asc", label: "By Date" },
                    { icon: "ui-sort-amount-asc", label: "By Size" },
                    { icon: "ui-sort-alpha-desc", label: "By Name" },
                    { icon: "ui-sort-numeric-desc", label: "By Date" },
                    { icon: "ui-sort-amount-desc", label: "By Size" }
                ]
            }

            fillHeight: true
            flat: true
            icon: model.at(selection).icon

            onClick: ev =>
            {
                ev.accepted = true;
                const menu = menuT();
                menu.popup(self);
            }

            property menuT: template Menu {

                MenuItem {
                    icon: sortSelector.showHidden ? "ui-check_box" : "ui-check_box_blank"
                    text: "Show Hidden"

                    onClick: ev =>
                    {
                        ev.accepted = true;
                        sortSelector.showHidden = ! sortSelector.showHidden;
                    }
                }

                MenuSeparator { }
                
                Repeater {
                    model: sortSelector.model

                    delegate: template MenuItem {
                        icon: modelData.value.icon
                        text: modelData.value.label

                        onClick: () =>
                        {
                            sortSelector.selection = modelData.index;
                            thisMenu.close();
                        }
                    }
                }

            }
        }

        Label {
            marginLeft: theme.paddingSmall
            text: fsview.count + " items"
        }

        Label {
            id: statusSpinner

            property counter: 0

            visible: counter > 0
            marginLeft: theme.paddingSmall
            text: "[icon:ui-spinner5] Uploading"
        }

        Label {
            id: statusLabel

            fillWidth: true
            marginLeft: theme.paddingSmall
            overflowBehavior: "ellipsis"
        }

        Slider {
            id: sizeSelector

            property scale: Math.round(seekValue)

            width: theme.itemWidthMedium
            minValue: 0
            maxValue: 6
            value: 1

            styleOfHandle: template Box {
                width: height
                height: theme.itemHeightSmall / 2
                marginTop: (parent.bboxHeight - bboxHeight) / 2
                borderRadius: width / 2
                color: theme.primaryColor
            }
        }

        Button {
            fillHeight: true
            marginLeft: theme.paddingSmall
            flat: true
            icon: "ui-view_grid"
            checked: fsview.displayMode === "grid"
            onClick: (ev) =>
            {
                fsview.visible = false;
                fsview.displayMode = "grid";
                nextFrame(() => { fsview.visible = true; });
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_list"
            checked: fsview.displayMode === "list"
            onClick: (ev) =>
            {
                fsview.visible = false;
                fsview.displayMode = "list";
                nextFrame(() => { fsview.visible = true; });
                ev.accepted = true;
            }
        }

    }

    property newDirectoryDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New Directory"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New Directory"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property newFileDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New File"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New File.txt"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property renameDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "Rename"

        into buttons Button {
            text: "Rename"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: dialog.name

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        const pos = text.lastIndexOf(".");
                        if (pos !== -1)
                        {
                            selectRange(0, pos);
                        }
                        else
                        {
                            selectRange(0, text.length);
                        }
                    }
                }
            }
        }
    }

    property linkDialogT: template Dialog {
        id: dialog

        property url: "http://localhost/index.html"

        title: "File Link"

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Close"
            onClick: () => { dialog.parent = null; }
        }

        Html {
            width: 3 * theme.itemWidthLarge
            height: theme.itemHeightMedium
            html: "<a href='" + dialog.url + "'>" + dialog.url + "</a>"
        }
    }

    property folderInfoDialogT: template FolderInfoDialog {
        filesystem: box.fs
        path: box.path
        filesBox: box
    }
}