require "shellfish/ui";
require "./BreadCrumbs.shui";
require "./thumbnailgenerator.js";

Box {
    id: box

    property fs: null
    property path: "/"
    property maximized: false

    event toggleMaximized

    event newPane
    event closePane
    event filesOpen

    borderWidth: 1
    borderColor: theme.borderColor

    ThumbnailGenerator {
        id: thumbnailer

        filesystem: OfflineFS { volume: "Thumbnails" }
    }

    FSModel {
        id: fsModel

        filesystem: box.fs
        path: box.path
    }

    Box {
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor

        layout: "center-row"
        
        BreadCrumbs {
            marginLeft: theme.paddingSmall
            fillHeight: true
            path: box.path

            onChangePath: path =>
            {
                box.path = path;
            }
        }

        Box { fillWidth: true }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-tab"
            onClick: ev =>
            {
                box.newPane(box.path);
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: box.maximized ? "ui-unfold_less" : "ui-unfold_more"
            onClick: ev =>
            {
                box.toggleMaximized();
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-clear"

            onClick: () =>
            {
                box.closePane();
            }
        }
    }

    DropArea {
        fillWidth: true
        fillHeight: true

        onDropAccept: (ev) =>
        {
            if (ev.types.includes("Files"))
            {
                ev.dropEffect = "copy";
                ev.accepted = true;
            }
            else if (ev.types.includes("text/plain"))
            {
                ev.dropEffect = ev.original.shiftKey ? "copy" : "move";
                ev.accepted = true;
            }
        }

        onDrop: (ev) =>
        {
            console.log(JSON.stringify(ev));

            for (let i = 0; i < ev.items.length; ++i)
            {
                const item = ev.items[i];
                if (item.kind !== "file")
                {
                    continue;
                }
                const fileItem = item.getAsFile();
                box.fs.write(box.fs.pathJoin(box.path, box.fs.encodeName(fileItem.name)), fileItem)
                .then(() =>
                {

                });
            }

            if (ev.data["text/plain"])
            {
                const uris = ev.data["text/plain"].split("\r\n");
                console.log(JSON.stringify(uris));
                uris.forEach(uri =>
                {
                    const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                    console.log("DROP EFFECT " + ev.dropEffect);
                    if (ev.dropEffect === "copy")
                    {
                        box.fs.copy(uri, destPath)
                        .then(() =>
                        {
                            console.log("files copied");
                        })
                        .catch(err =>
                        {
                            console.log("failed to copy files: " + err);
                        });
                    }
                    else
                    {
                        box.fs.move(uri, destPath)
                        .then(() =>
                        {
                            console.log("files moved");
                        })
                        .catch(err =>
                        {
                            console.log("failed to move files: " + err);
                        });
                    }
                });
            }
        }

        MouseBox {
            fillWidth: true
            fillHeight: true
            layout: "center"

            onContextMenu: (ev) =>
            {
                ev.accepted = true;
                const menu = fileMenuT();
                menu.popup(null);
            }

            ListView {
                id: fsview

                property iconScale: 1
                property displayMode: "grid"

                visible: ! fsModel.loading
                fillWidth: true
                fillHeight: true
                canFocus: true

                cellWidth: displayMode === "list" ? bbox.width - 1
                                                  : theme.itemWidthLarge * iconScale
                cellHeight: displayMode === "list" ? theme.itemHeightMedium * iconScale
                                                   : cellWidth
                cacheMargin: cellHeight //contentHeight

                model: fsModel

                delegate: template Draggable {

                    onXChanged: () =>
                    {
                        if (x < 0)
                        {
                            fsitem.thumbnail = "";
                        }
                    }

                    onDragStart: ev =>
                    {
                        console.log("drag start");
                        const uris = [];
                        const items = [];
                        selector.selection.forEach(idx =>
                        {
                            const item = fsview.model.at(idx);
                            uris.push(item.path);
                            items.push(item);
                        });

                        if (uris.length > 0)
                        {
                            console.log(JSON.stringify(uris));

                            ev.setData("text/uri-list", uris.join("\r\n"));
                            ev.setData("text/plain", uris.join("\r\n"));
                            ev.setData("text/x-fileitems", JSON.stringify(items));
                            ev.accepted = true;
                        }
                    }

                    FSItem {
                        id: fsitem

                        property inView: file &&
                                         parent.x >= 0 &&
                                         parent.y >= fsview.contentY - fsview.cellHeight &&
                                         parent.y <= fsview.contentY + fsview.bboxHeight

                        fillWidth: true
                        fillHeight: true

                        displayMode: fsview.displayMode
                        highlighted: selector.selection.has(parent.modelData.index)

                        file: parent.modelData.value

                        onInViewChanged: () =>
                        {
                            if (inView && thumbnail === "")
                            {
                                const forPath = file.path;

                                const condition = () =>
                                {
                                    return lifeCycleStatus !== "destroyed" &&
                                           file.path === forPath &&
                                           thumbnail === "" &&
                                           inView;
                                }

                                thumbnail = "";
                                thumbnailer.generate(box.fs, file, condition)
                                .then(safeCallback(blob =>
                                {
                                    thumbnail = blobUrl(blob);
                                }, condition))
                                .catch(err =>
                                {

                                });
                            }

                        }

                        onPointerDown: (ev) =>
                        {
                            const idx = parent.modelData.index;

                            if (ev.original.ctrlKey)
                            {
                                selector.select(idx, "toggle");
                            }
                            else if (ev.original.shiftKey)
                            {
                                selector.select(idx, "range");
                            }
                            else
                            {
                                selector.select(idx, "replace");
                            }
                        }

                        onDoubleClick: (ev) =>
                        {
                            const file = parent.modelData.value;
                            if (file.type === "d")
                            {
                                selector.clear();
                                box.path = file.path;
                            }
                            else if (file.mimetype === "application/zip")
                            {
                                selector.clear();
                                console.log("open ZIP: " + file.path);
                                box.path = file.path;
                            }
                            else if (file.mimetype === "application/pdf" ||
                                     file.mimetype.startsWith("audio/") ||
                                     file.mimetype.startsWith("image/") ||
                                     file.mimetype.startsWith("text/") ||
                                     file.mimetype.startsWith("video/"))
                            {
                                box.filesOpen([file], 0);
                            }
                            ev.accepted = true;
                        }
                    }

                    //Label { text: parent.modelData.index; color: "red"; fontSize: theme.fontSizeSmall }
                }

                model.onPathChanged: () =>
                {
                    selector.clear();
                    thumbnailer.cancel();
                }

                ListViewSelector {
                    id: selector
                    multiple: true
                }

                ScrollIndicator { }
            }

            Label {
                visible: ! fsview.visible
                fontSize: theme.fontSizeLarge
                text: "[icon:ui-spinner5]"
            }

            property fileMenuT: template Menu {
                MenuItem {
                    text: "New Directory"
                    onClick: () =>
                    {
                        const dlg = newDirectoryDialogT();
                        dlg.callback = newName =>
                        {
                            box.fs.mkdir(box.path, box.fs.encodeName(newName));
                        };
                        dlg.show();
                    }
                }

                MenuSeparator { }

                MenuItem {
                    text: "Rename"
                    onClick: () =>
                    {
                        if (selector.selection.size !== 1)
                        {
                            return;

                        }

                        const idx = [...selector.selection][0];
                        const item = fsModel.at(idx);

                        const dlg = renameDialogT();
                        dlg.name = item.name;
                        dlg.callback = newName =>
                        {
                            box.fs.move(item.path, box.fs.pathJoin(box.fs.dirname(item.path), box.fs.encodeName(newName)));
                        };
                        dlg.show();
                    }
                }

                MenuItem {
                    text: "Delete"
                    onClick: () =>
                    {
                        const idx = [...selector.selection][0];
                        const item = fsModel.at(idx);

                        showQuestionDialog("Delete File",
                                           "Do you want to delete this file?\n" + item.name,
                                           () =>
                        {
                            box.fs.remove(item.path);
                        });
                    }
                }
            }
        }

    }

    Box {
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor
        layout: "center-row"

        Label {
            marginLeft: theme.paddingSmall
            text: fsview.count + " items"
        }

        Box { fillWidth: true }

        Slider {
            marginLeft: theme.paddingSmall
            marginRight: theme.paddingSmall
            minValue: 0.5
            maxValue: 3
            value: fsview.iconScale

            onValueChanged: () => { fsview.iconScale = value;}
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_grid"
            checked: fsview.displayMode === "grid"
            onClick: (ev) =>
            {
                fsview.displayMode = "grid";
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_list"
            checked: fsview.displayMode === "list"
            onClick: (ev) =>
            {
                fsview.displayMode = "list";
                ev.accepted = true;
            }
        }

    }

    property newDirectoryDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New Directory"

        into buttons Button {
            text: "Create"
            onClick: () => { callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New Directory"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property renameDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "Rename"

        into buttons Button {
            text: "Rename"
            onClick: () => { callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: dialog.name

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        const pos = text.lastIndexOf(".");
                        if (pos !== -1)
                        {
                            selectRange(0, pos);
                        }
                        else
                        {
                            selectRange(0, text.length);
                        }
                    }
                }
            }
        }
    }

}