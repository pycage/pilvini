require "shellfish/ui";
require "./BreadCrumbs.shui";
require "./thumbnailgenerator.js";

Box {
    id: box

    property windowIcon: "fs-folder"
    property windowTitle: path

    property fs: null
    property path: "/"
    property maximized: false

    event toggleMaximized

    event newPane
    event closePane
    event filesOpen
    event takeFiles

    borderWidth: maximized ? 0 : 1
    borderColor: theme.borderColor

    ThumbnailGenerator {
        id: thumbnailer

        enabled: thumbnailCheckbox.checked
        filesystem: OfflineFS { volume: "Thumbnails" }
    }

    FSModel {
        id: fsModel

        filesystem: box.fs
        path: box.path
        sortRole: sortSelector.role
        sortAscending: sortSelector.ascending

        function getFiles(predicate)
        {
            const result = [];
            for (let i = 0; i < size; ++i)
            {
                const f = at(i);
                if (predicate(f))
                {
                    result.push(f);
                }
            }
            return result;
        }
    }

    MouseBox {
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor

        layout: "center-row"
        
        onDoubleClick: ev =>
        {
            box.toggleMaximized();
            ev.accepted = true;
        }

        BreadCrumbs {
            fillWidth: true
            fillHeight: true
            path: box.path

            onChangePath: path =>
            {
                box.path = path;
            }
        }

        //Box { fillWidth: true }

        Button {
            visible: filesBag.length > 0 && filesBagSource !== box.objectId
            fillHeight: true
            flat: true
            icon: "fs-save"
            text: "Drop"

            onClick: ev =>
            {
                menuT().popup(self);
                ev.accepted = true;
            }

            property menuT: template Menu {
                MenuItem {
                    text: "Copy"
                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            statusLabel.text = "Copying: " + box.fs.filename(uri);
                            box.fs.copy(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                                statusLabel.text = "";
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Copying File", "" + err);
                                statusLabel.text = "";
                            });
                        });
                    }
                }

                MenuItem {
                    text: "Move"

                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            box.fs.move(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Moving File", "" + err);
                            });
                        });
                        filesBag = [];
                    }
                }
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: box.maximized ? "ui-unfold_less" : "ui-unfold_more"
            onClick: ev =>
            {
                box.toggleMaximized();
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-clear"

            onClick: () =>
            {
                box.closePane();
            }
        }
    }

    DropArea {
        fillWidth: true
        fillHeight: true

        onDropAccept: (ev) =>
        {
            if (ev.types.includes("Files"))
            {
                ev.dropEffect = "copy";
                ev.accepted = true;
            }
            else if (ev.types.includes("text/plain"))
            {
                ev.dropEffect = ev.original.shiftKey ? "copy" : "move";
                ev.accepted = true;
            }
        }

        onDrop: (ev) =>
        {
            console.log(JSON.stringify(ev));

            for (let i = 0; i < ev.items.length; ++i)
            {
                const item = ev.items[i];
                if (item.kind !== "file")
                {
                    continue;
                }
                const fileItem = item.getAsFile();
                statusLabel.text = "Uploading: " + fileItem.name;
                box.fs.write(box.fs.pathJoin(box.path, box.fs.encodeName(fileItem.name)), fileItem)
                .then(() =>
                {
                    statusLabel.text = "";
                })
                .catch(err =>
                {
                    statusLabel.text = "";
                    showErrorDialog("Error Uploading File", "" + err);
                });
            }

            if (ev.data["text/plain"])
            {
                const uris = ev.data["text/plain"].split("\r\n");
                console.log(JSON.stringify(uris));
                uris.forEach(uri =>
                {
                    const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                    console.log("DROP EFFECT " + ev.dropEffect);
                    if (ev.dropEffect === "copy")
                    {
                        statusLabel.text = "Copying: " + box.fs.filename(uri);
                        box.fs.copy(uri, destPath)
                        .then(() =>
                        {
                            statusLabel.text = "";
                            console.log("files copied");
                        })
                        .catch(err =>
                        {
                            statusLabel.text = "";
                            showErrorDialog("Error Copying File", "" + err);
                        });
                    }
                    else
                    {
                        box.fs.move(uri, destPath)
                        .then(() =>
                        {
                            console.log("files moved");
                        })
                        .catch(err =>
                        {
                            showErrorDialog("Error Moving File", "" + err);
                        });
                    }
                });
            }
        }

        MouseBox {
            fillWidth: true
            fillHeight: true
            layout: "center"

            onContextMenu: (ev) =>
            {
                ev.accepted = true;
                const menu = fileMenuT();
                menu.popup(null);
            }

            ListView {
                id: fsview

                property displayMode: "grid"

                visible: ! fsModel.loading
                fillWidth: true
                fillHeight: true
                canFocus: true

                cellWidth: displayMode === "list" ? bbox.width - 1
                                                  : (theme.itemWidthLarge / 2) * (sizeSelector.value + 1)
                cellHeight: displayMode === "list" ? (theme.itemHeightMedium / 2) * (sizeSelector.value + 1)
                                                   : cellWidth
                cacheMargin: cellHeight //contentHeight

                model: fsModel

                delegate: template Draggable {

                    onXChanged: () =>
                    {
                        if (x < 0)
                        {
                            fsitem.thumbnail = "";
                        }
                    }

                    onDragStart: ev =>
                    {
                        console.log("drag start");
                        const uris = [];
                        const items = [];
                        selector.selection.forEach(idx =>
                        {
                            const item = fsview.model.at(idx);
                            uris.push(item.path);
                            items.push(item);
                        });

                        if (uris.length > 0)
                        {
                            console.log(JSON.stringify(uris));

                            ev.setData("text/uri-list", uris.join("\r\n"));
                            ev.setData("text/plain", uris.join("\r\n"));
                            ev.setData("text/x-fileitems", JSON.stringify(items));
                            ev.accepted = true;
                        }
                    }

                    FSItem {
                        id: fsitem

                        property inView: file &&
                                         parent.x >= 0 &&
                                         parent.y >= fsview.contentY - fsview.cellHeight &&
                                         parent.y <= fsview.contentY + fsview.bboxHeight

                        fillWidth: true
                        fillHeight: true

                        displayMode: fsview.displayMode
                        highlighted: selector.selection.has(parent.modelData.index)

                        file: parent.modelData.value

                        onInViewChanged: () =>
                        {
                            if (inView && thumbnail === "")
                            {
                                const forPath = file.path;

                                const condition = () =>
                                {
                                    return lifeCycleStatus !== "destroyed" &&
                                           file.path === forPath &&
                                           thumbnail === "" &&
                                           inView;
                                }

                                thumbnail = "";
                                thumbnailer.generate(box.fs, file, condition)
                                .then(safeCallback(blob =>
                                {
                                    if (blob)
                                    {
                                        thumbnail = blobUrl(blob);
                                    }
                                }, condition))
                                .catch(err =>
                                {

                                });
                            }

                        }

                        onPointerDown: (ev) =>
                        {
                            const idx = parent.modelData.index;

                            if (ev.original.ctrlKey)
                            {
                                selector.select(idx, "toggle");
                            }
                            else if (ev.original.shiftKey)
                            {
                                selector.select(idx, "range");
                            }
                            else
                            {
                                selector.select(idx, "replace");
                            }
                        }

                        onDoubleClick: (ev) =>
                        {
                            const file = parent.modelData.value;
                            if (file.type === "d")
                            {
                                selector.clear();
                                box.path = file.path;
                            }
                            else if (file.mimetype === "application/zip" ||
                                     file.mimetype === "application/x-rar-compressed")
                            {
                                selector.clear();
                                console.log("open ZIP: " + file.path);
                                box.path = file.path;
                            }
                            else if (file.mimetype.startsWith("audio/"))
                            {
                                const files = fsModel.getFiles(f => f.mimetype.startsWith("audio/"));
                                const idx = files.findIndex(f => f.path === file.path);
                                box.filesOpen(files, idx);
                            }
                            else if (file.mimetype.startsWith("image/"))
                            {
                                const files = fsModel.getFiles(f => f.mimetype.startsWith("image/"));
                                const idx = files.findIndex(f => f.path === file.path);
                                box.filesOpen(files, idx);
                            }
                            else if (file.mimetype === "application/pdf" ||
                                     file.mimetype.startsWith("image/") ||
                                     file.mimetype.startsWith("text/") ||
                                     file.mimetype.startsWith("video/"))
                            {
                                box.filesOpen([file], 0);
                            }
                            ev.accepted = true;
                        }
                    }

                    //Label { text: parent.modelData.index; color: "red"; fontSize: theme.fontSizeSmall }
                }

                model.onPathChanged: () =>
                {
                    selector.clear();
                    thumbnailer.cancel();
                }

                ListViewSelector {
                    id: selector
                    multiple: true

                    onSelectionChanged: () =>
                    {
                        const items = [];
                        selection.forEach(idx => items.push(fsModel.at(idx)));
                        filesBag = items;
                        filesBagSource = box.objectId;
                    }
                }

                ScrollIndicator { }
            }

            Label {
                visible: ! fsview.visible
                fontSize: theme.fontSizeLarge
                text: "[icon:ui-spinner5]"
            }

            property fileMenuT: template Menu {
                MenuItem {
                    text: "New Directory"
                    onClick: () =>
                    {
                        const dlg = newDirectoryDialogT();
                        dlg.callback = newName =>
                        {
                            box.fs.mkdir(box.path, box.fs.encodeName(newName));
                        };
                        dlg.show();
                    }
                }

                MenuSeparator { }

                MenuItem {
                    text: "Rename"
                    onClick: () =>
                    {
                        if (selector.selection.size !== 1)
                        {
                            return;

                        }

                        const idx = [...selector.selection][0];
                        const item = fsModel.at(idx);

                        const dlg = renameDialogT();
                        dlg.name = item.name;
                        dlg.callback = newName =>
                        {
                            box.fs.move(item.path, box.fs.pathJoin(box.fs.dirname(item.path), box.fs.encodeName(newName)));
                        };
                        dlg.show();
                    }
                }

                MenuItem {
                    text: "Delete"
                    onClick: () =>
                    {
                        const idx = [...selector.selection][0];
                        const item = fsModel.at(idx);

                        showQuestionDialog("Delete File",
                                           "Do you want to delete this file?\n" + item.name,
                                           () =>
                        {
                            box.fs.remove(item.path);
                        });
                    }
                }
            }
        }

    }

    Box {
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor
        layout: "center-row"

        Label {
            marginLeft: theme.paddingSmall
            text: fsview.count + " items"
        }

        Label {
            id: statusLabel

            fillWidth: true
            marginLeft: theme.paddingSmall
            overflowBehavior: "ellipsis"
        }

        SelectionBox {
            id: sortSelector

            property role: ["name", "time", "size"][selection % 3]
            property ascending: selection < 3

            labelProfile: Object { property literal: false }

            model: ListModel {
                data: [
                    "[icon:ui-arrow_up] By Name", "[icon:ui-arrow_up] By Date", "[icon:ui-arrow_up] By Size",
                    "[icon:ui-arrow_down] By Name", "[icon:ui-arrow_down] By Date", "[icon:ui-arrow_down] By Size"
                ]
            }
        }

        SpinBox {
            id: sizeSelector

            marginLeft: theme.paddingSmall
            marginRight: theme.paddingSmall
            minValue: 1
            maxValue: 6
            stepSize: 1
            value: 1
        }

        Button {
            id: thumbnailCheckbox

            fillHeight: true
            flat: true
            icon: "media-image"
            checked: false

            onClick: (ev) =>
            {
                checked = ! checked;
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_grid"
            checked: fsview.displayMode === "grid"
            onClick: (ev) =>
            {
                fsview.displayMode = "grid";
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_list"
            checked: fsview.displayMode === "list"
            onClick: (ev) =>
            {
                fsview.displayMode = "list";
                ev.accepted = true;
            }
        }
    }

    property newDirectoryDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New Directory"

        into buttons Button {
            text: "Create"
            onClick: () => { callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New Directory"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property renameDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "Rename"

        into buttons Button {
            text: "Rename"
            onClick: () => { callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: dialog.name

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        const pos = text.lastIndexOf(".");
                        if (pos !== -1)
                        {
                            selectRange(0, pos);
                        }
                        else
                        {
                            selectRange(0, text.length);
                        }
                    }
                }
            }
        }
    }

}