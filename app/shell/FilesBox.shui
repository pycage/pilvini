require "shellfish/ui";
require "./BreadCrumbs.shui";
require "./FileViewer.shui";
require "./thumbnailgenerator.js";

Box {
    id: box

    property windowIcon: "fs-folder"
    property windowTitle: path

    property fs: null
    property path: "/"
    property searchBox: false
    property maximized: false

    event toggleMaximized
    event filesOpen
    event takeFiles

    fillWidth: true
    fillHeight: true

    borderRadius: 6

    color: theme.secondaryBackgroundColor

    function setPath(newPath)
    {
        const currentPath = box.path;
        history.push(() =>
        {
            selector.clear();
            box.path = currentPath;
        });

        selector.clear();
        box.path = newPath;
    }

    function openAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const file = fsModel.at(idx);

        if (file.type === "d")
        {
            setPath(file.path);
        }
        else if (file.mimetype === "application/zip" ||
                    file.mimetype === "application/x-rar-compressed")
        {
            console.log("open ZIP: " + file.path);
            setPath(file.path);
        }
        else if (file.mimetype.startsWith("audio/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("audio/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype.startsWith("image/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("image/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype.startsWith("video/"))
        {
            const files = fsModel.getFiles(f => f.mimetype.startsWith("video/"));
            const idx = files.findIndex(f => f.path === file.path);
            fileViewer.open(files, idx);
        }
        else if (file.mimetype === "application/pdf" ||
                file.mimetype === "application/x-youtube-link" ||
                file.mimetype.startsWith("image/") ||
                file.mimetype.startsWith("text/"))
        {
            fileViewer.open([file], 0);
        }
    }

    function goBackAction()
    {
        history.back();
        //setPath(fs.dirname(box.path));
    }

    function newDirectoryAction()
    {
        const dlg = newDirectoryDialogT();
        dlg.callback = newName =>
        {
            box.fs.mkdir(box.path, box.fs.encodeName(newName));
        };
        dlg.show();
    }

    function newFileAction()
    {
        const dlg = newFileDialogT();
        dlg.callback = newName =>
        {
            box.fs.write(box.path + "/" + box.fs.encodeName(newName), new Blob([""]));
        };
        dlg.show();
    }

    function deleteAction()
    {
        if (selector.selection.size === 0)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        showQuestionDialog("Delete File",
                            "Do you want to delete this file?\n\n" +
                            low.escapeMarkup(item.name),
                            () =>
        {
            box.fs.remove(item.path);
        });
    }

    function renameAction()
    {
        if (selector.selection.size !== 1)
        {
            return;
        }

        const idx = [...selector.selection][0];
        const item = fsModel.at(idx);

        const dlg = renameDialogT();
        dlg.name = item.name;
        dlg.callback = newName =>
        {
            box.fs.move(item.path, box.fs.pathJoin(box.fs.dirname(item.path), box.fs.encodeName(newName)));
        };
        dlg.show();
    }

    ThumbnailGenerator {
        id: thumbnailer

        enabled: thumbnailCheckbox.checked
        filesystem: OfflineFS { volume: "Thumbnails" }
    }

    FSModel {
        id: fsModel

        filesystem: box.fs
        path: box.path
        sortRole: sortSelector.role
        sortAscending: sortSelector.ascending

        function getFiles(predicate)
        {
            const result = [];
            for (let i = 0; i < size; ++i)
            {
                const f = at(i);
                if (predicate(f))
                {
                    result.push(f);
                }
            }
            return result;
        }
    }

    Image {
        id: backdrop

        visible: status === "success"
        position: "free"
        fillWidth: true
        fillHeight: true
        fitMode: "cover"

        fsModel.onSizeChanged: () =>
        {
            source = "";
            if (fsModel.size > 0)
            {
                const items = fsModel.getFiles(f => f.name === "background.jpg");
                if (items.length > 0)
                {
                    source = items[0].path;
                }
            }
        }
    }

    Box {
        visible: backdrop.visible
        position: "free"
        fillWidth: true
        fillHeight: true
        color: parent.color.alpha(0.8)
    }

    // title bar
    MouseBox {
        visible: ! fileViewer.maximized
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor

        layout: "center-row"
        
        onDoubleClick: ev =>
        {
            box.toggleMaximized();
            ev.accepted = true;
        }

        BreadCrumbs {
            visible: ! box.searchBox
            fillWidth: true
            fillHeight: true
            path: box.path

            onChangePath: path =>
            {
                box.setPath(path);
            }

            onSearch: () =>
            {
                box.searchBox = true;
            }
        }

        Label {
            visible: box.searchBox
            marginLeft: theme.paddingSmall
            bold: true
            text: "Search"
        }

        TextEntry {
            id: searchEntry

            visible: box.searchBox
            fillWidth: true
            marginLeft: theme.paddingSmall

            clearButton: true

            onVisibleChanged: () =>
            {
                if (visible)
                {
                    focus = true;
                }
            }

            onTextChanged: () =>
            {
                if (text === "")
                {
                    fsModel.query = text;
                }
            }

            onKeyDown: ev =>
            {
                if (ev.key === "Enter" || ev.key === "Tab")
                {
                    fsModel.query = text;
                }
            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            icon: "ui-search"

            onClick: () =>
            {
                fsModel.query = searchEntry.text;
            }
        }

        Button {
            visible: ! box.searchBox &&
                     filesBag.length > 0 && filesBagSource !== box.objectId
            fillHeight: true
            flat: true
            icon: "fs-save"
            text: "Drop"

            onClick: ev =>
            {
                menuT().popup(self);
                ev.accepted = true;
            }

            property menuT: template Menu {
                MenuItem {
                    text: "Copy"
                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            statusLabel.text = "Copying: " + box.fs.filename(uri);
                            box.fs.copy(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                                statusLabel.text = "";
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Copying File", "" + err);
                                statusLabel.text = "";
                            });
                        });
                    }
                }

                MenuItem {
                    text: "Move"

                    onClick: () =>
                    {
                        filesBag.forEach(item =>
                        {
                            const uri = item.path;
                            const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                            box.fs.move(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Moving File", "" + err);
                            });
                        });
                        filesBag = [];
                    }
                }
            }
        }

        Button {
            visible: box.searchBox
            fillHeight: true
            flat: true
            text: "Close Search"

            onClick: ev =>
            {
                fsModel.query = "";
                searchEntry.text = "";
                box.searchBox = false;

                ev.accepted = true;
            }
        }
    }

    // banner
    Box {
        id: banner

        visible: ! fileViewer.maximized && bannerLabel.text !== ""

        height: bannerImage.height + 2 * theme.paddingLarge
        overflowBehavior: "scroll"

        layout: "row"

        fsModel.onSizeChanged: () =>
        {
            const items = fsModel.getFiles(f => f.name === "description.txt");
            if (items.length > 0)
            {
                box.fs.read(items[0].path)
                .then(blob => { return blob.text(); })
                .then(data =>
                {
                    console.log(data);
                    bannerLabel.text = data;
                })
                .catch(err => { });
            }
            else
            {
                bannerLabel.text = "";
            }

            const items2 = fsModel.getFiles(f => f.name === "cover.jpg");
            if (items2.length > 0)
            {
                bannerImage.source = items2[0].path;
            }
            else
            {
                bannerImage.source = "";
            }
        }

        Image {
            id: bannerImage

            visible: status === "success"

            marginTop: theme.paddingLarge
            marginLeft: theme.paddingLarge
            width: theme.itemWidthLarge
            height: width
            fitMode: "contain"
        }

        Label {
            id: bannerLabel

            fillWidth: true
            marginTop: theme.paddingLarge
            marginLeft: theme.paddingLarge
            marginRight: theme.paddingLarge
            marginBottom: theme.paddingLarge
            literal: true
            overflowBehavior: "wrap"
        }

        OverflowScroller { }
    }

    Box {
        visible: banner.visible
        fillWidth: true
        marginLeft: theme.paddingLarge
        marginRight: theme.paddingLarge
        marginBottom: theme.paddingSmall
        height: 1
        color: theme.primaryColor
    }

    Box {
        fillWidth: true
        fillHeight: true
        layout: bboxWidth > bboxHeight ? "row" : "column"

        DropArea {
            visible: ! fileViewer.maximized
            fillWidth: true
            fillHeight: true

            onDropAccept: (ev) =>
            {
                if (ev.types.includes("Files"))
                {
                    ev.dropEffect = "copy";
                    ev.accepted = true;
                }
                else if (ev.types.includes("text/plain"))
                {
                    ev.dropEffect = ev.original.shiftKey ? "copy" : "move";
                    ev.accepted = true;
                }
            }

            onDrop: (ev) =>
            {
                console.log(JSON.stringify(ev));

                for (let i = 0; i < ev.items.length; ++i)
                {
                    const item = ev.items[i];
                    if (item.kind !== "file")
                    {
                        continue;
                    }
                    const fileItem = item.getAsFile();
                    statusLabel.text = "Uploading: " + fileItem.name;
                    box.fs.write(box.fs.pathJoin(box.path, box.fs.encodeName(fileItem.name)), fileItem)
                    .then(() =>
                    {
                        statusLabel.text = "";
                    })
                    .catch(err =>
                    {
                        statusLabel.text = "";
                        showErrorDialog("Error Uploading File", "" + err);
                    });
                }

                if (ev.data["text/plain"])
                {
                    const uris = ev.data["text/plain"].split("\r\n");
                    console.log(JSON.stringify(uris));
                    uris.forEach(uri =>
                    {
                        const destPath = box.fs.pathJoin(box.path, box.fs.filename(uri));
                        console.log("DROP EFFECT " + ev.dropEffect);
                        if (ev.dropEffect === "copy")
                        {
                            statusLabel.text = "Copying: " + box.fs.filename(uri);
                            box.fs.copy(uri, destPath)
                            .then(() =>
                            {
                                statusLabel.text = "";
                                console.log("files copied");
                            })
                            .catch(err =>
                            {
                                statusLabel.text = "";
                                showErrorDialog("Error Copying File", "" + err);
                            });
                        }
                        else
                        {
                            box.fs.move(uri, destPath)
                            .then(() =>
                            {
                                console.log("files moved");
                            })
                            .catch(err =>
                            {
                                showErrorDialog("Error Moving File", "" + err);
                            });
                        }
                    });
                }
            }

            MouseBox {
                fillWidth: true
                fillHeight: true
                layout: "center"

                onClick: ev =>
                {
                    ev.accepted = true;
                    selector.clear();
                }

                onContextMenu: ev =>
                {
                    ev.accepted = true;
                    const menu = fileMenuT();
                    menu.popup(null);
                }

                onKeyDown: ev =>
                {
                    if (ev.altKey)
                    {
                        if (ev.key === "r")
                        {
                            ev.accepted = true;
                            box.renameAction();
                        }
                    }
                    else if (ev.key === "Delete")
                    {
                        ev.accepted = true;
                        box.deleteAction();
                    }
                    else if (ev.key === "Enter")
                    {
                        ev.accepted = true;
                        box.openAction();
                    }
                    else if (ev.key === "Backspace")
                    {
                        ev.accepted = true;
                        box.goBackAction();
                    }
                }

                ListView {
                    id: fsview

                    property displayMode: "grid"

                    visible: ! fsModel.loading
                    fillWidth: true
                    fillHeight: true
                    canFocus: true

                    cellWidth: displayMode === "list" ? bbox.width - 1
                                                      : theme.itemWidthMedium * (sizeSelector.scale + 1) 
                    cellHeight: displayMode === "list" ? (theme.itemHeightMedium / 2) * (sizeSelector.scale + 2)
                                                       : cellWidth + theme.itemHeightMedium
                    cacheMargin: cellHeight //contentHeight

                    orientation: bboxHeight < cellHeight + theme.paddingLarge ? "horizontal" : "vertical"

                    model: fsModel

                    onCountChanged: () =>
                    {
                        wait(0).then(() => { positionViewAt(0); });
                    }

                    delegate: template Draggable {

                        onXChanged: () =>
                        {
                            if (x < 0)
                            {
                                fsitem.thumbnail = "";
                            }
                        }

                        onDragStart: ev =>
                        {
                            console.log("drag start");
                            const uris = [];
                            const items = [];
                            selector.selection.forEach(idx =>
                            {
                                const item = fsview.model.at(idx);
                                uris.push(item.path);
                                items.push(item);
                            });

                            if (uris.length > 0)
                            {
                                console.log(JSON.stringify(uris));

                                ev.setData("text/uri-list", uris.join("\r\n"));
                                ev.setData("text/plain", uris.join("\r\n"));
                                ev.setData("text/x-fileitems", JSON.stringify(items));
                                ev.accepted = true;
                            }
                        }

                        FSItem {
                            id: fsitem

                            property inView: file &&
                                            parent.x >= 0 &&
                                            parent.y >= fsview.contentY - fsview.cellHeight &&
                                            parent.y <= fsview.contentY + fsview.bboxHeight

                            property readyForThumbnail: inView && ! fsview.scrolling

                            fillWidth: true
                            fillHeight: true

                            displayMode: fsview.displayMode
                            highlighted: selector.selection.has(parent.modelData.index)

                            file: parent.modelData.value

                            onReadyForThumbnailChanged: () =>
                            {
                                if (readyForThumbnail && thumbnail === "")
                                {
                                    const forPath = file.path;

                                    const condition = () =>
                                    {
                                        return lifeCycleStatus !== "destroyed" &&
                                            file.path === forPath &&
                                            thumbnail === "" &&
                                            readyForThumbnail;
                                    }

                                    thumbnail = "";
                                    thumbnailer.generate(box.fs, file, condition)
                                    .then(safeCallback(blob =>
                                    {
                                        if (blob)
                                        {
                                            thumbnail = blobUrl(blob);
                                        }
                                    }, condition))
                                    .catch(err =>
                                    {

                                    });
                                }

                            }

                            onPointerDown: (ev) =>
                            {
                                const idx = parent.modelData.index;

                                if (ev.original.ctrlKey)
                                {
                                    selector.select(idx, "toggle");
                                }
                                else if (ev.original.shiftKey)
                                {
                                    selector.select(idx, "range");
                                }
                                else
                                {
                                    selector.select(idx, "replace");
                                }
                            }

                            onClick: (ev) =>
                            {
                                ev.accepted = true;
                                if (ev.original.shiftKey || ev.original.ctrlKey || ev.buttons !== 1)
                                {
                                    return;
                                }

                                box.openAction();
                            }
                        }

                        //Label { text: parent.modelData.index; color: "red"; fontSize: theme.fontSizeSmall }
                    }

                    model.onPathChanged: () =>
                    {
                        selector.clear();
                        thumbnailer.cancel();
                    }

                    ListViewSelector {
                        id: selector
                        multiple: true

                        onSelectionChanged: () =>
                        {
                            const items = [];
                            selection.forEach(idx => items.push(fsModel.at(idx)));
                            filesBag = items;
                            filesBagSource = box.objectId;
                        }
                    }

                    OverflowScroller { stepSize: theme.paddingLarge }
                    ScrollIndicator { orientation: "horizontal" }
                    ScrollIndicator { orientation: "vertical" }
                }

                Label {
                    visible: ! fsview.visible
                    fontSize: theme.fontSizeLarge
                    text: "[icon:ui-spinner5]"
                }

                property fileMenuT: template Menu {
                    MenuItem {
                        text: "New Directory"
                        onClick: () =>
                        {
                            box.newDirectoryAction();
                        }
                    }

                    MenuItem {
                        text: "New File"
                        onClick: () =>
                        {
                            box.newFileAction();
                        }
                    }

                    MenuSeparator { }

                    MenuItem {
                        enabled: selector.selection.size > 0
                        text: "Rename"
                        onClick: () =>
                        {
                            box.renameAction();
                        }
                    }

                    MenuItem {
                        enabled: selector.selection.size > 0
                        text: "Delete"
                        onClick: () =>
                        {
                            box.deleteAction();
                        }
                    }
                }
            }

        }

        FileViewer {
            id: fileViewer

            visible: false
            fillWidth: maximized || parent.bboxWidth <= parent.bboxHeight
            fillHeight: maximized || parent.bboxWidth > parent.bboxHeight
            width: parent.bboxWidth - fsview.cellHeight - theme.paddingMedium
            height: parent.bboxHeight - fsview.cellHeight - theme.paddingMedium

            order: parent.layout === "column" ? -1 : 0

            fs: box.fs

            onCurrentChanged: () =>
            {
                if (current !== -1 && ! visible)
                {
                    maximized = true;
                    visible = true;
                }
            }
        }
    }

    // status bar
    Box {
        visible: ! fileViewer.maximized
        fillWidth: true
        height: theme.itemHeightMedium
        color: theme.secondaryBackgroundColor
        layout: "center-row"

        Button {
            id: thumbnailCheckbox

            fillHeight: true
            flat: true
            icon: "media-image"
            checked: false

            onClick: (ev) =>
            {
                checked = ! checked;
                ev.accepted = true;
            }
        }

        Button {
            id: sortSelector

            property role: ["name", "time", "size"][selection % 3]
            property ascending: selection < 3
            property selection: 0

            property model: ListModel {
                data: [
                    { icon: "ui-sort-alpha-asc", label: "By Name" },
                    { icon: "ui-sort-numeric-asc", label: "By Date" },
                    { icon: "ui-sort-amount-asc", label: "By Size" },
                    { icon: "ui-sort-alpha-desc", label: "By Name" },
                    { icon: "ui-sort-numeric-desc", label: "By Date" },
                    { icon: "ui-sort-amount-desc", label: "By Size" }
                ]
            }

            fillHeight: true
            flat: true
            icon: model.at(selection).icon

            onClick: ev =>
            {
                ev.accepted = true;
                const menu = menuT();
                menu.popup(self);
            }

            property menuT: template Menu {
                Repeater {
                    model: sortSelector.model

                    delegate: template MenuItem {
                        icon: modelData.value.icon
                        text: modelData.value.label

                        onClick: () =>
                        {
                            sortSelector.selection = modelData.index;
                            thisMenu.close();
                        }
                    }
                }
            }
        }

        Label {
            marginLeft: theme.paddingSmall
            text: fsview.count + " items"
        }

        Label {
            id: statusLabel

            fillWidth: true
            marginLeft: theme.paddingSmall
            overflowBehavior: "ellipsis"
        }

        Slider {
            id: sizeSelector

            property scale: Math.round(seekValue)

            width: theme.itemWidthMedium
            minValue: 0
            maxValue: 6
            value: 1

            styleOfHandle: template Box {
                width: height
                height: theme.itemHeightSmall / 2
                marginTop: (parent.bboxHeight - bboxHeight) / 2
                borderRadius: width / 2
                color: theme.primaryColor
            }
        }

        Button {
            fillHeight: true
            marginLeft: theme.paddingSmall
            flat: true
            icon: "ui-view_grid"
            checked: fsview.displayMode === "grid"
            onClick: (ev) =>
            {
                fsview.displayMode = "grid";
                ev.accepted = true;
            }
        }

        Button {
            fillHeight: true
            flat: true
            icon: "ui-view_list"
            checked: fsview.displayMode === "list"
            onClick: (ev) =>
            {
                fsview.displayMode = "list";
                ev.accepted = true;
            }
        }

    }

    property newDirectoryDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New Directory"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New Directory"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property newFileDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "New File"

        into buttons Button {
            text: "Create"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: "New File.txt"

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        selectRange(0, text.length);
                    }
                }
            }
        }
    }

    property renameDialogT: template Dialog {
        id: dialog

        property name: ""
        property callback: (newName) => { }

        title: "Rename"

        into buttons Button {
            text: "Rename"
            onClick: () => { dialog.callback(textEntry.text); dialog.parent = null; }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"
            onClick: () => { dialog.parent = null; }
        }

        onKeyDown: ev =>
        {
            if (ev.key === "Enter")
            {
                ev.accepted = true;
                callback(textEntry.text);
                parent = null;
            }
            else if (ev.key === "Escape")
            {
                ev.accepted = true;
                parent = null;
            }
        }

        Box {
            layout: "center-row"

            Label { text: "Name:" }

            TextEntry {
                id: textEntry

                marginLeft: theme.paddingSmall
                width: theme.itemWidthLarge * 2
                text: dialog.name

                onAncestorsVisibleChanged: () =>
                {
                    if (ancestorsVisible)
                    {
                        active = true;
                        const pos = text.lastIndexOf(".");
                        if (pos !== -1)
                        {
                            selectRange(0, pos);
                        }
                        else
                        {
                            selectRange(0, text.length);
                        }
                    }
                }
            }
        }
    }

}