require "shellfish/ui";
require "./inertialengine.js";
require "./ViewportBox.shui";

MouseBox {
    id: page

    property pageBrowser: null
    property viewport: vp

    container default: contentArea

    onPointerDown: ev =>
    {
        if (pinchGesture.pinching || ! vp.zoomed)
        {
            return;
        }

        inertialEngine.reset(ev.x, ev.y);
        ev.accepted = true;
    }

    onPointerMove: ev =>
    {
        if (pinchGesture.pinching || ! vp.zoomed)
        {
            return;
        }

        if (ev.buttons !== 0)
        {
            inertialEngine.takeSample(ev.x, ev.y);
            ev.accepted = true;
        }
    }

    onPointerUp: ev =>
    {
        if (pinchGesture.pinching || ! vp.zoomed)
        {
            return;
        }

        inertialEngine.start();
        ev.accepted = true;
    }

    onClick: () =>
    {
        pageBrowser.showNavigation = ! pageBrowser.showNavigation;
    }

    onDoubleClick: ev =>
    {
        vp.scaleToFit();
        ev.accepted = true;
    }

    onWheel: ev =>
    {
        if (page.pageBrowser.scrolling)
        {
            return;
        }

        const scaleAnchorX = ev.x / bbox.width;
        const scaleAnchorY = ev.y / bbox.height;

        if (ev.deltaY < 0)
        {
            vp.setScale(vp.scale * 1.1, scaleAnchorX, scaleAnchorY);
            ev.accepted = true;
        }
        else if (ev.deltaY > 0)
        {
            vp.setScale(vp.scale * 0.9, scaleAnchorX, scaleAnchorY);
            ev.accepted = true;
        }
    }

    ViewportBox {
        id: vp

        property zoomed: scale > minScale + 0.001

        fillWidth: true
        fillHeight: true
    }

    InertialEngine {
        id: inertialEngine

        onMotion: (dx, dy) =>
        {
            vp.confineViewport(vp.viewX + dx / vp.scale, vp.viewY + dy / vp.scale);
        }
    }

    PinchGesture {
        id: pinchGesture

        onDistanceChanged: () =>
        {
            if (! page.pageBrowser.scrolling && previousDistance > 0)
            {
                const factor = distance / previousDistance;
                const scaleAnchorX = (x1 + (x2 - x1) / 2) / parent.bboxWidth;
                const scaleAnchorY = (y1 + (y2 - y1) / 2) / parent.bboxHeight;
                vp.setScale(vp.scale * factor, scaleAnchorX, scaleAnchorY);
            }
        }
    }

    Box {
        id: contentArea

        position: "free"
        fillWidth: true
        fillHeight: true
    }

    ScrollIndicator { id: sh; target: vp.adapter; other: sv; orientation: "horizontal" }
    ScrollIndicator { id: sv; target: vp.adapter; other: sh; orientation: "vertical" }
}