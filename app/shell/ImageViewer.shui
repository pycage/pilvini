require "shellfish/ui";
require "./inertialengine.js";
require "./ViewportBox.shui";

Box {
    id: box

    property model: ListModel { }
    property current: 0
    property source: ""

    MouseBox {
        fillWidth: true
        fillHeight: true

        onPointerDown: ev =>
        {
            if (pinchGesture.pinching)
            {
                return;
            }

            inertialEngine.reset(ev.x, ev.y);
            ev.accepted = true;
        }

        onPointerMove: ev =>
        {
            if (pinchGesture.pinching)
            {
                return;
            }

            if (ev.buttons !== 0)
            {
                inertialEngine.takeSample(ev.x, ev.y);
                ev.accepted = true;
            }
        }

        onPointerUp: ev =>
        {
            if (pinchGesture.pinching)
            {
                return;
            }

            inertialEngine.start();
            ev.accepted = true;
        }

        onDoubleClick: ev =>
        {
            vp.scaleToFit();
            ev.accepted = true;
        }

        onWheel: ev =>
        {
            const scaleAnchorX = ev.x / bbox.width;
            const scaleAnchorY = ev.y / bbox.height;

            if (ev.deltaY < 0)
            {
                vp.setScale(vp.scale * 1.1, scaleAnchorX, scaleAnchorY);
                ev.accepted = true;
            }
            else if (ev.deltaY > 0)
            {
                vp.setScale(vp.scale * 0.9, scaleAnchorX, scaleAnchorY);
                ev.accepted = true;
            }
        }

        InertialEngine {
            id: inertialEngine

            onMotion: (dx, dy) =>
            {
                vp.confineViewport(vp.viewX + dx / vp.scale, vp.viewY + dy / vp.scale);
            }
        }

        PinchGesture {
            id: pinchGesture

            onDistanceChanged: () =>
            {
                if (previousDistance > 0)
                {
                    const factor = distance / previousDistance;
                    const scaleAnchorX = (x1 + (x2 - x1) / 2) / parent.bbox.width;
                    const scaleAnchorY = (y1 + (y2 - y1) / 2) / parent.bbox.height;
                    vp.setScale(vp.scale * factor, scaleAnchorX, scaleAnchorY);
                }
            }
        }

        onClick: ev =>
        {
            if (ev.y > bboxHeight * 0.66)
            {
                imagesBox.visible = ! imagesBox.visible;
            }
            else if (ev.x < bboxWidth * 0.5)
            {
                if (box.current > 0)
                {
                    box.current -= 1;
                }
            }
            else
            {
                if (box.current < box.model.size - 1)
                {
                    box.current += 1;
                }
            }
            ev.accepted = true;
        }

        ViewportBox {
            id: vp

            fillWidth: true
            fillHeight: true
        }

        Image {
            id: image

            position: "free"
            x: -vp.viewX * vp.scale
            y: -vp.viewY * vp.scale
            width: originalWidth * vp.scale
            height: originalHeight * vp.scale

            source: box.current < box.model.size ? box.model.at(box.current).path : ""

            onStatusChanged: () =>
            {
                if (status === "success")
                {
                    vp.originalWidth = originalWidth;
                    vp.originalHeight = originalHeight;
                    vp.scaleToFit();
                }
            }
        }

        ScrollIndicator { id: sh; target: vp.adapter; other: sv; orientation: "horizontal" }
        ScrollIndicator { id: sv; target: vp.adapter; other: sh; orientation: "vertical" }
    }

    Box {
        id: imagesBox

        visible: false

        //position: "free"
        //origin: "bottom-left"
        fillWidth: true
        //marginLeft: theme.paddingLarge
        //marginRight: theme.paddingLarge
        //y: theme.paddingLarge
        height: theme.itemHeightLarge * 2

        color: theme.contentBackgroundColor

        layout: "row"

        Button {
            enabled: box.current > 0
            width: theme.itemWidthSmall
            fillHeight: true
            flat: true
            icon: "ui-arrow_left"

            onClick: () =>
            {
                box.current -= 1;
            }
        }

        Box {
            fillWidth: true
            fillHeight: true

            ListView {
                id: listView

                fillWidth: true
                fillHeight: true

                orientation: "horizontal"
                model: box.model
                cellWidth: bboxHeight
                cellHeight: bboxHeight

                box.onCurrentChanged: () =>
                {
                    positionViewAt(box.current);
                }

                delegate: template MouseBox {
                    color: box.current === modelData.index ? theme.highlightBackgroundColor
                                                        : "transparent"

                    Image {
                        fillWidth: true
                        fillHeight: true
                        marginTop: theme.paddingSmall
                        marginLeft: theme.paddingSmall
                        marginRight: theme.paddingSmall
                        marginBottom: theme.paddingSmall
                        fitMode: "cover"
                        source: parent.modelData.value.path
                    }

                    onClick: () =>
                    {
                        box.current = modelData.index;
                    }
                }
            }

            ScrollIndicator { target: listView; orientation: "horizontal" }
        }

        Button {
            enabled: box.current < box.model.size - 1
            width: theme.itemWidthSmall
            fillHeight: true
            flat: true
            icon: "ui-arrow_right"

            onClick: () =>
            {
                box.current += 1;
            }
        }


    }
}
