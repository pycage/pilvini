require "shellfish/ui";
require "./EpgEvent.shui";

Box {
    id: app

    function formatTime(d)
    {
        const hours = d.getHours();
        const minutes = d.getMinutes();
        return (hours < 10 ? "0" + hours : hours) + ":" +
               (minutes < 10 ? "0" + minutes : minutes);
    }

    property epgService: null

    fill: true

    onInitialization: async () =>
    {
        epgService = await rpcProxy.invoke("epgService");
        console.log("got EPG service");
    }

    Repeater {
        model: app.epgService ? 1 : 0

        delegate: template Box {
            fill: true

            ListModel {
                id: eventsModel

                property serviceId: "0"
            }

            ListModel {
                id: recordingsModel

                function recordingsAt(begin, end)
                {
                    const result = [];
                    for (let i = 0; i < size; ++i)
                    {
                        const rec = at(i);
                        if (rec.begin < end && rec.end > begin)
                        {
                            result.push(rec);
                        }
                    }
                    return result;
                }

                onInitialization: async () =>
                {
                    const recs = await app.epgService.recordings();
                    console.log("recordings");
                    console.log(recs);
                    reset(recs);
                }
            }

            Box {
                fillWidth: true
                height: theme.itemHeightMedium
                color: theme.secondaryBackgroundColor
                layout: "center-row"

                SelectionBox {
                    id: serviceSelector

                    property services: []

                    width: theme.itemWidthLarge * 2

                    model: ListModel { }

                    onInitialization: async () =>
                    {
                        services = await app.epgService.services();
                        //console.log("Services: " + JSON.stringify(services));
                        model.reset(services.map(item => escapeMarkup(item.name)));
                    }

                    onSelectionChanged: async () =>
                    {
                        if (selection >= 0 && selection < services.length)
                        {
                            const serviceId = services[selection].serviceId;
                            const events = await app.epgService.events(serviceId);
                            //console.log("Events: " + JSON.stringify(events));
                            eventsModel.serviceId = serviceId;
                            eventsModel.reset(events);
                        }
                    }
                }
            }

            ListView {
                fill: true
                cellWidth: bboxWidth
                cellHeight: theme.itemHeightLarge

                model: eventsModel

                delegate: template EpgEvent {
                    id: listItem

                    property recordings: recordingsModel.recordingsAt(epgEvent.begin, epgEvent.end)
                    property isThisChannel: recordings.filter(rec => rec.serviceId === epgEvent.serviceId && rec.eventId === epgEvent.eventId).length > 0

                    index: modelData.index
                    epgEvent: modelData.value
                    sideColor: isThisChannel ? "darkred"
                                             : recordings.length > 0 ? "orange"
                                                                     : "transparent"

                    onModelDataChanged: () =>
                    {
                        epgEventChanged();
                    }

                    onClick: ev =>
                    {
                        ev.accepted = true;

                        app.epgService.eventInfo(eventsModel.serviceId, epgEvent.eventId)
                        .then(info =>
                        {
                            showInfoDialog(info.name, info.description, () => { });
                        });
                    }

                    onClickRec: async ev =>
                    {
                        ev.accepted = true;

                        if (! epgEvent.scheduled)
                        {
                            await app.epgService.record(epgEvent.serviceId, epgEvent.eventId, true);
                            recordingsModel.insertOrdered(epgEvent, (a, b) => a.begin - b.begin);
                            const evObj = epgEvent;
                            evObj.scheduled = true;
                            eventsModel.replace(modelData.index, evObj);
                        }
                        else
                        {
                            await app.epgService.record(epgEvent.serviceId, epgEvent.eventId, false);
                            for (let i = 0; i < recordingsModel.size; ++i)
                            {
                                const event = recordingsModel.at(i);
                                if (event.serviceId === event.serviceId && event.eventId === event.eventId)
                                {
                                    recordingsModel.remove(i);
                                    break;
                                }
                            }
                            const evObj = epgEvent;
                            evObj.scheduled = false;
                            eventsModel.replace(modelData.index, evObj);
                        }
                    }
                }

                IndexScroller {
                    position: "global"
                    y: parent.bboxY
                    height: parent.bboxHeight
                    width: theme.itemWidthMedium

                    getLabel: idx =>
                    {
                        const item = eventsModel.at(idx);
                        const d = new Date(item.begin * 1000);
                        return d.getDate() + " / " + formatTime(d);
                    }
                }

                ScrollIndicator { }
            }

            MouseBox {
                fillWidth: true
                height: theme.itemHeightMedium
                color: containsMouse ? theme.highlightBackgroundColor : theme.secondaryBackgroundColor
                layout: "center-row"

                Label {
                    color: parent.containsMouse ? theme.highlightColor : theme.primaryColor
                    text: "Recordings (" + recordingsListView.count + ")"
                }

                onClick: () =>
                {
                    recordingsListView.visible = ! recordingsListView.visible;
                }
            }

            ListView {
                id: recordingsListView

                visible: false
                fill: true
                cellWidth: bboxWidth
                cellHeight: theme.itemHeightLarge

                model: recordingsModel

                delegate: template EpgEvent {
                    id: listItem

                    property recordings: recordingsModel.recordingsAt(epgEvent.begin, epgEvent.end)
                    property isThisChannel: recordings.filter(rec => rec.serviceId === epgEvent.serviceId && rec.eventId === epgEvent.eventId).length > 0

                    index: modelData.index
                    epgEvent: modelData.value
                    sideColor: isThisChannel ? "darkred"
                                             : recordings.length > 0 ? "orange"
                                                                     : "transparent"

                    onModelDataChanged: () =>
                    {
                        epgEventChanged();
                    }

                    onClick: ev =>
                    {
                        ev.accepted = true;

                        app.epgService.eventInfo(eventsModel.serviceId, epgEvent.eventId)
                        .then(info =>
                        {
                            showInfoDialog(info.name, info.description, () => { });
                        });
                    }

                    onClickRec: async ev =>
                    {
                        ev.accepted = true;

                        await app.epgService.record(epgEvent.serviceId, epgEvent.eventId, false);

                        if (eventsModel.serviceId === epgEvent.serviceId)
                        {
                            for (let i = 0; i < eventsModel.size; ++i)
                            {
                                const event = eventsModel.at(i);
                                if (event.eventId === epgEvent.eventId)
                                {
                                    event.scheduled = false;
                                    eventsModel.replace(i, event);
                                }
                            }
                        }
                        recordingsModel.remove(modelData.index);
                    }
                }

                IndexScroller {
                    position: "global"
                    y: parent.bboxY
                    height: parent.bboxHeight
                    width: theme.itemWidthMedium

                    getLabel: idx =>
                    {
                        const item = recordingsModel.at(idx);
                        const d = new Date(item.begin * 1000);
                        return d.getDate() + " / " + formatTime(d);
                    }
                }

                ScrollIndicator { }
            }
        }
    }

}