require "shellfish/ui";

Button {
    id: cutButton

    property file: null
    property sectionsModel: null

    icon: "ui-content_cut"

    onClick: ev =>
    {
        ev.accepted = true;
        const dlg = dialogT();
        dlg.show();
    }

    property dialogT: template Dialog {

        title: "Cut Video"

        into buttons Button {
            text: "Cut"

            onClick: async () =>
            {
                const directions = repeater.getDirections();
                const path = cutButton.file.path;
                thisDialog.close();

                const notifications = new Map();

                const videoEditor = await rpcProxy.invoke("videoEditor");
                videoEditor.cutVideo(decodeURIComponent(path), directions, (name, seconds, duration) =>
                {
                    if (! notifications.has(name))
                    {
                        const notification = notificationArea.createNotification();
                        notification.title = "Cutting Video";
                        notifications.set(name, notification);
                    }

                    notifications.get(name).message = escapeMarkup(name + ": " + seconds + "s / " + duration + "s");

                    console.log("Cut progress: " + name + " " + seconds + " of " + duration);
                },
                () =>
                {
                    notifications.forEach(notification => notification.close());
                    console.log("Cutting finished");
                });
            }
        }

        into buttons Button {
            marginLeft: theme.paddingSmall
            text: "Cancel"

            onClick: () =>
            {
                thisDialog.close();
            }
        }

        Label {
            fillWidth: true
            overflowBehavior: "wrap"
            text: "Sections with the same target name will be merged into one file."
        }

        Box {
            marginTop: theme.paddingMedium

            Ruler { id: labelRuler }

            Repeater {
                id: repeater

                function getDirections()
                {
                    const directions = { };

                    items.forEach(item =>
                    {
                        const settings = item.getSettings();
                        if (settings.enabled)
                        {
                            if (! directions[settings.name])
                            {
                                directions[settings.name] = [];
                            }
                            directions[settings.name].push([settings.begin, settings.end]);
                        }
                    });

                    return directions;
                }

                model: thisButton.sectionsModel

                delegate: template Box {

                    function getSettings()
                    {
                        return {
                            enabled: checkBox.checked,
                            begin: modelData.value.begin,
                            end: modelData.value.end,
                            name: textEntry.text
                        };
                    }

                    height: theme.itemHeightMedium
                    layout: "center-row"

                    CheckBox {
                        id: checkBox

                        checked: true
                    }

                    Label {
                        enabled: checkBox.checked
                        ruler: labelRuler
                        marginLeft: theme.paddingSmall
                        minWidth: labelRuler.max.width
                        text: core.formatSeconds(modelData.value.begin, true) + " - " + core.formatSeconds(modelData.value.end, true)
                    }

                    TextEntry {
                        id: textEntry

                        enabled: checkBox.checked
                        marginLeft: theme.paddingSmall
                        width: theme.itemWidthLarge * 2
                        text: thisButton.file.name
                    }
                }
            }
        }
    }
}