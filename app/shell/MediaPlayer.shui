require "shellfish/low" as low;
require "shellfish/ui";
require "./PlaySeekButton.shui";
require "./SeekBar.shui";
require "./SubtitlesBox.shui";
require "./TimeLabel.shui";
require "./VideoCutButton.shui";

MouseBox {
    id: playerBox

    function formatTime(seconds, detailed)
    {
        let hs = "" + Math.floor((seconds - Math.floor(seconds)) * 100);
        let t = seconds;
        const secs = Math.floor(t) % 60;
        t /= 60;
        const minutes = Math.floor(t) % 60;
        t /= 60;
        const hours = Math.floor(t);

        let h = hours.toFixed(0);
        let m = minutes.toFixed(0);
        let s = secs.toFixed(0);

        if (h.length === 1) h = "0" + h;
        if (m.length === 1) m = "0" + m;
        if (s.length === 1) s = "0" + s;
        if (hs.length === 1) hs = "0" + hs;

        if (detailed)
        {
            return (hours > 0 ? h + ":" : "") + m + ":" + s + "." + hs;
        }
        else
        {
            return (hours > 0 ? h + ":" : "") + m + ":" + s;
        }
    }

    function stripExtension(filename)
    {
        const pos = filename.lastIndexOf(".");
        if (pos !== -1)
        {
            return filename.substr(0, pos);
        }
        else
        {
            return pos;
        }
    }

    function addMarker(timePos)
    {
        markersModel.insertOrdered(timePos, (a, b) => a - b);
    }

    function removeMarker(idx)
    {
        markersModel.remove(idx);
    }

    property model: ListModel { }
    property current: -1
    property startPosition: 0
    property title: model.at(current) ? model.at(current).name : ""

    color: "black"
    canFocus: true

    onCurrentChanged: () =>
    {
        markersModel.reset([]);
        if (current === -1)
        {
            videoPlayer.source = "";
            coverArt.source = "";
        }
        else
        {
            const mediaItem = model.at(current);
            if (mediaItem.mimetype.startsWith("video/"))
            {
                coverArt.visible = false;
                coverArt.source = "";
                videoPlayer.visible = true;
                videoPlayer.source = mediaItem.path;

                if (mediaItem.subtitles)
                {
                    console.log("Have subs: " + mediaItem.subtitles);
                    videoPlayer.subtitles = mediaItem.subtitles;
                    subtitlesToggle.checked = true;
                }
                else
                {
                    videoPlayer.subtitles = "";
                }
            }
            else if (mediaItem.mimetype.startsWith("audio/"))
            {
                videoPlayer.visible = false;
                coverArt.visible = true;
                controls.active = true;
                videoPlayer.source = mediaItem.path;
                const newSource = mediaItem.path + "?view=cover"; //"/::thumbnail" + mediaItem.path + "?maxWidth=1080&maxHeight=1080";
                if (coverArt.source !== newSource)
                {
                    coverArt.source = newSource;
                }
            }
        }
    }

    onKeyDown: ev =>
    {
        ev.accepted = true;

        if (ev.key === "Enter")
        {
            addMarker(controls.player.currentTime);
        }
        else if (ev.key === " ")
        {
            if (controls.player.playing)
            {
                controls.player.pause();
            }
            else
            {
                controls.player.play();
            }
        }
        else if (ev.key === "ArrowLeft")
        {
            const diff = ev.shiftKey ? 1.0 : 1.0 / 24;
            controls.player.currentTime = Math.max(0, controls.player.currentTime - diff);
        }
        else if (ev.key === "ArrowRight")
        {
            const diff = ev.shiftKey ? 1.0 : 1.0 / 24;
            controls.player.currentTime = Math.min(controls.player.duration, controls.player.currentTime + diff);
        }
    }

    ListModel {
        id: markersModel
    }

    ListModel {
        id: cutSectionsModel

        function makeModel()
        {
            const m = [];
            if (! controls.player)
            {
                return m;
            }

            const points = [];
            for (let i = 0; i < markersModel.size; ++i)
            {
                points.push(markersModel.at(i));
            }
            points.push(controls.player.duration);
            
            let prevPos = 0.0;
            points.forEach((pos, idx) =>
            {
                if (idx % 2 === 1)
                {
                    m.push({ begin: prevPos, end: pos, color: "green" });
                }
                prevPos = pos;
            });
            return m;
        }

        data: makeModel(markersModel.size)
    }

    MouseBox {
        fillWidth: true
        fillHeight: true

        onClick: () =>
        {
            controls.active = ! controls.active;
        }

        onWheel: ev =>
        {
            ev.accepted = true;
            if (ev.deltaY < 0)
            {
                volumeSlider.value = Math.min(100, volumeSlider.value + 5);
            }
            else if (ev.deltaY > 0)
            {
                volumeSlider.value = Math.max(0, volumeSlider.value - 5);
            }
        }

        Box {
            fillWidth: true
            fillHeight: true
            layout: "center"

            Video {
                id: videoPlayer

                property ratio: 0

                visible: false
                width: parent.bboxWidth
                height: parent.bboxHeight
                fitMode: ratio !== 3 ? "fill" : "cover"
                volume: volumeSlider.volume

                onStatusChanged: () =>
                {
                    if (status === "success")
                    {
                        if (playerBox.startPosition > 0)
                        {
                            videoPlayer.currentTime = playerBox.startPosition;
                            playerBox.startPosition = 0;
                        }
                    }
                }

                onCurrentTimeChanged: () =>
                {
                    if (status === "success")
                    {
                        const name = playerBox.title + " (" + formatTime(currentTime, false) + ")";
                        thisFileViewer.mediaBookmarkUpdated(source, currentTime, name);
                    }
                }

                aspectRatio: (() =>
                {
                    switch (ratio)
                    {
                    case 0:
                        return originalHeight > 0 ? originalWidth / originalHeight : 1;
                    case 1:
                        return 4 / 3;
                    case 2:
                    case 3:
                        return 16 / 9;
                    default:
                        return 0;
                    }
                })()

                onFinish: () =>
                {
                    if (playerBox.current < playerBox.model.size - 1)
                    {
                        playerBox.current = playerBox.current + 1;
                    }
                }
            }

            SubtitlesBox {
                visible: subtitlesToggle.checked
                position: "free"
                origin: "bottom-left"
                fillWidth: true
                marginLeft: theme.paddingSmall
                marginRight: theme.paddingSmall
                marginBottom: (controls.active ? controls.bboxHeight : 0) + theme.paddingLarge
                cues: videoPlayer.cues
            }

            Box {
                id: coverArt

                property source: ""

                visible: false
                fillWidth: true
                fillHeight: true
                layout: "center"

                Image {
                    visible: status === "success"
                    position: "free"
                    fillWidth: true
                    fillHeight: true
                    opacity: 0.1
                    fitMode: "cover"
                    source: coverArt.source
                }

                Image {
                    visible: status === "success"
                    style: ["sh-dropshadow"]
                    marginTop: theme.paddingLarge * 3
                    marginLeft: theme.paddingLarge * 3
                    marginRight: theme.paddingLarge * 3
                    marginBottom: theme.paddingLarge * 3
                    fillWidth: true
                    fillHeight: true
                    fitMode: "contain"
                    source:coverArt.source
                }
            }

        }

        Box {
            //visible: controls.active

            position: "free"
            origin: "bottom-left"
            y: controls.active ? 0 : -height
            yTransition: NumberAnimation { }
            fillWidth: true
            height: controls.bboxHeight * 1.3

            LinearGradient {
                id: grd

                GradientStop { position: 0.0; color: theme.primaryBackgroundColor.alpha(0.8) }
                GradientStop { position: 0.5; color: theme.primaryBackgroundColor.alpha(0.8) }
                GradientStop { position: 1.0; color: "transparent" }
            }

            gradient: grd.expression
        }

        Label {
            //visible: controls.active
            
            position: "free"
            origin: "top-right"
            marginTop: theme.paddingLarge
            marginRight: theme.paddingLarge
            y: timeLabel.y + 2
            fontSize: theme.fontSizeLarge
            color: "#444"
            text: timeLabel.text
        }

        TimeLabel {
            id: timeLabel

            //visible: controls.active
            
            position: "free"
            origin: "top-right"
            marginTop: theme.paddingLarge
            marginRight: theme.paddingLarge
            x: 2
            y: controls.active ? 0 : -bboxHeight * 1.3
            yTransition: NumberAnimation { }
            fontSize: theme.fontSizeLarge
            color: "white"
        }

        Box {
            id: controls

            property player: videoPlayer
            property active: false

            //visible: false
            position: "free"
            origin: "bottom-left"
            y: active ? 0 : -bboxHeight * 1.3
            yTransition: NumberAnimation { }
            fillWidth: true
            marginLeft: theme.paddingSmall
            marginRight: marginLeft
            marginBottom: marginLeft

            /*
            Box {
                visible: coverArt.visible && !! playerBox.model && playerBox.model.size > 1
                fillWidth: true
                layout: "center-row"
                overflowBehavior: "wrap"

                onAncestorsVisibleChanged: () =>
                {
                    if (! ancestorsVisible)
                    {
                        trackButtonRuler.reset();
                    }
                }

                Ruler {
                    id: trackButtonRuler
                }

                Repeater {
                    model: playerBox.model
                    delegate: template Button {
                        ruler: trackButtonRuler
                        minWidth: trackButtonRuler.max.width
                        flat: true
                        checked: modelData.index === playerBox.current

                        onInitialization: () =>
                        {
                            if (! modelData.value.mimetype.startsWith("audio/"))
                            {
                                return;
                            }

                            text = low.escapeMarkup(stripExtension(modelData.value.name));
                        }

                        onClick: (ev) =>
                        {
                            playerBox.current = modelData.index;
                            ev.accepted = true;
                        }
                    }
                }
            }
            */

            // controls bar 1
            Box {
                fillWidth: true
                height: theme.itemHeightMedium
                layout: "center-row"

                Button {
                    fillHeight: true
                    width: bboxHeight
                    flat: true
                    icon: "ui-clear"

                    onClick: ev =>
                    {
                        ev.accepted = true;
                        thisFileViewer.close();
                    }
                }

                VideoCutButton {
                    visible: cutSectionsModel.size > 0

                    fillHeight: true
                    width: bboxHeight
                    flat: true

                    file: playerBox.model.at(playerBox.current)
                    sectionsModel: cutSectionsModel
                }

                Box { fillWidth: true }

                Button {
                    id: subtitlesToggle

                    visible: videoPlayer.subtitles !== ""
                    fillHeight: true
                    flat: true
                    text: "CC"
                    onClick: (ev) => { checked = ! checked; ev.accepted = true; }
                }

                Button {
                    visible: videoPlayer.visible
                    marginLeft: theme.paddingLarge
                    checked: controls.player.ratio === 0
                    fillHeight: true
                    flat: true
                    text: "Auto"
                    onClick: (ev) => { controls.player.ratio = 0; ev.accepted = true; }
                }

                Button {
                    visible: videoPlayer.visible
                    checked: controls.player.ratio === 1
                    fillHeight: true
                    flat: true
                    text: "4:3"
                    onClick: (ev) => { controls.player.ratio = 1; ev.accepted = true; }
                }

                Button {
                    visible: videoPlayer.visible
                    checked: controls.player.ratio === 2
                    fillHeight: true
                    flat: true
                    text: "16:9"
                    onClick: (ev) => { controls.player.ratio = 2; ev.accepted = true; }
                }

                Button {
                    visible: videoPlayer.visible
                    checked: controls.player.ratio === 3
                    fillHeight: true
                    flat: true
                    text: "Zoom"
                    onClick: (ev) => { controls.player.ratio = 3; ev.accepted = true; }
                }

                Button {
                    visible: videoPlayer.visible
                    checked: controls.player.ratio === 4
                    fillHeight: true
                    flat: true
                    text: "Fit"
                    onClick: (ev) => { controls.player.ratio = 4; ev.accepted = true; }
                }

                Button {
                    id: muteButton

                    property muted: false

                    marginLeft: theme.paddingLarge
                    width: bboxHeight
                    fillHeight: true
                    flat: true
                    icon: muted ? "media-volume_off" : "media-volume_up"

                    onClick: ev => { muted = ! muted; ev.accepted = true; }
                }

                Slider {
                    id: volumeSlider

                    property volume: muteButton.muted ? 0.0 : seekValue / 100.0

                    marginRight: theme.paddingLarge
                    width: theme.itemWidthMedium
                    height: theme.itemHeightSmall / 2
                    minValue: 0
                    maxValue: 100
                    value: 75

                    styleOfBackground: template Box {
                        fill: true
                        color: theme.secondaryBackgroundColor
                        borderRadius: bboxHeight / 2
                    }

                    styleOfHandle: template Box {
                        width: height
                        height: thisSlider.bboxHeight
                        marginTop: (parent.bboxHeight - bboxHeight) / 2
                        borderRadius: width / 2
                        color: theme.primaryColor
                    }
                }

            }

            // controls bar 2
            Box {
                fillWidth: true
                height: theme.itemHeightLarge
                layout: "center-row"

                Button {
                    fillHeight: true
                    width: bboxHeight
                    flat: true
                    icon: "media-previous"

                    onClick: (ev) =>
                    {
                        if (controls.player.currentTime < 3 && playerBox.current > 0)
                        {
                            playerBox.current = playerBox.current - 1;
                        }
                        else
                        {
                            controls.player.currentTime = 0;
                        }
                        ev.accepted = true;
                    }
                }

                Button {
                    fillHeight: true
                    width: bboxHeight
                    flat: true
                    icon: "media-replay_10"
                    repeatAcceleration: 1.0

                    onClick: (ev) =>
                    {
                        controls.player.currentTime = Math.max(0, controls.player.currentTime - 10);
                        ev.accepted = true;
                    }
                }

                Box { fillWidth: true }

                PlaySeekButton {
                    id: playSeekButton

                    fillHeight: true
                    player: controls.player
                }

                Box { fillWidth: true }

                Button {
                    fillHeight: true
                    width: bboxHeight
                    flat: true
                    icon: "media-forward_10"
                    repeatAcceleration: 1.0

                    onClick: (ev) =>
                    {
                        controls.player.currentTime = Math.min(controls.player.duration, controls.player.currentTime + 10);
                        ev.accepted = true;
                    }
                }

                Button {
                    enabled: !! playerBox.model && (playerBox.current < playerBox.model.size - 1)
                    fillHeight: true
                    width: bboxHeight
                    flat: true
                    icon: "media-next"

                    onClick: (ev) =>
                    {
                        playerBox.current = playerBox.current + 1;
                        ev.accepted = true;
                    }
                }

            }

            // markers bar
            Box {
                visible: markersModel.size > 0

                marginLeft: theme.paddingMedium
                marginRight: theme.paddingMedium
                fillWidth: true
                height: theme.itemHeightSmall

                Repeater {
                    model: markersModel
                    delegate: template MouseBox {
                        position: "free"
                        x: modelData.value / controls.player.duration * parent.bboxWidth - bboxWidth / 2
                        fillHeight: true
                        color: containsMouse ? theme.highlightBackgroundColor : "transparent"
                        layout: "center-column"

                        onClick: ev =>
                        {
                            ev.accepted = true;
                            console.log(ev.buttons);
                            if (ev.buttons === 1)
                            {
                                controls.player.currentTime = modelData.value;
                            }
                            else if (ev.buttons === 2)
                            {
                                playerBox.removeMarker(modelData.index);
                            }
                        }

                        Box { fillHeight: true }
                        Label {
                            fontSize: theme.fontSizeLarge
                            color: parent.containsMouse ? theme.highlightColor : theme.primaryColor
                            text: "[icon:ui-arrow_down]"
                        }

                        Tooltip {
                            text: playerBox.formatTime(modelData.value, true)
                        }
                    }
                }
            }

            // seek bar
            SeekBar {
                id: seekbar

                marginLeft: theme.paddingMedium
                marginRight: theme.paddingMedium
                fillWidth: true
                height: theme.itemHeightSmall
                player: controls.player

                sectionsModel: cutSectionsModel
            }

            // position bar
            Box {
                marginLeft: theme.paddingMedium
                marginRight: theme.paddingMedium
                marginBottom: theme.paddingMedium
                fillWidth: true
                layout: "center-row"

                Label {
                    text: formatTime(seekbar.seeking ? seekbar.seekTime : controls.player.currentTime, playSeekButton.seeking && Math.abs(playSeekButton.seekValue) > 0.0001)
                }

                Button {
                    id: titleLabel

                    fillWidth: true
                    marginLeft: theme.paddingMedium
                    marginRight: theme.paddingMedium
                    flat: true

                    playerBox.onCurrentChanged: () =>
                    {
                        if (playerBox.current === -1)
                        {
                            text = "";
                            return;
                        }

                        const file = playerBox.model.at(playerBox.current);
                        if (file.mimetype.startsWith("audio/"))
                        {
                            text = low.escapeMarkup(stripExtension(file.name));

                            /*
                            text = "Loading...";
                            httpRequest("/::tags" + file.path).send()
                            .then(response =>
                            {
                                if (response.ok)
                                {
                                    return response.text();
                                }
                            })
                            .then(data =>
                            {
                                const tags = JSON.parse(data);
                                text = tags.TITLE || stripExtension(file.name);
                            })
                            .catch(err =>
                            {

                            });
                            */
                        }
                        else
                        {
                            text = (playerBox.current + 1) + "/" + playerBox.model.size + " - " + low.escapeMarkup(stripExtension(file.name));
                        }
                    }

                    onClick: ev =>
                    {
                        ev.accepted = true;

                        const menu = menuT();
                        menu.popup(self);
                    }

                    property menuT: template Menu {

                        Repeater {
                            model: playerBox.model

                            delegate: template MenuItem {
                                text: (modelData.index + 1) + " - " +
                                      low.escapeMarkup(stripExtension(modelData.value.name))
                                maxWidth: titleLabel.bboxWidth

                                onClick: () =>
                                {
                                    playerBox.current = modelData.index;
                                    thisMenu.parent = null;
                                }
                            }
                        }

                    }
                }

                Label {
                    text: formatTime(controls.player.duration, false)
                }
            }

        }

    }

}
