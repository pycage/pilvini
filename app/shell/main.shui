require "shellfish/low" as low;
require "shellfish/ui";
require "./FilesBox.shui";
require "./FileViewer.shui";
require "./GridLayout.shui";
require "./SettingsDialog.shui";
require "/icons/comm-icons.css";
require "/icons/fs-icons.css";
require "/icons/media-icons.css";
require "/icons/ui-icons.css";

Document {
    id: doc

    property loggedIn: false
    property filesBag: []
    property filesBagSource: null

    property darkMode: systemDarkMode
    property darkTheme: DarkTheme { }
    property lightTheme: Theme { }
    theme: darkMode ? darkTheme : lightTheme

    color: theme.primaryBackgroundColor

    onContextMenu: ev => { ev.accepted = true; }

    onInitialization: () =>
    {
        remoteFs.list("/")
        .then(f =>
        {
            loggedIn = true;
        })
        .catch(err =>
        {
            alert("Login Failed.");
        });
    }

    DavFS {
        id: remoteFs
    }

    OfflineFS {
        id: offlineFs
        volume: "offline"
    }

    ListModel {
        id: panesModel

        data: ["/"]
    }

    ListModel {
        id: mediaModel

        data: []
    }

    Box {
        visible: doc.loggedIn

        fillWidth: true
        height: documentRoot.windowHeight
        color: theme.contentBackgroundColor

        layout: "row"

        MouseBox {
            //visible: grid.maximizedItem === null
            width: theme.itemHeightMedium
            fillHeight: true
            color: theme.contentBackgroundColor

            layout: "center-column"

            Button {
                width: parent.width
                height: width
                flat: true
                icon: "ui-menu"

                onClick: (ev) =>
                {
                    ev.accepted = true;
                    const menu = menuT();
                    menu.popup(self);
                }

                property menuT: template Menu {

                    MenuItem {
                        text: "About..."
                    }

                    MenuItem {
                        text: doc.darkMode ? "Light Mode"
                                           : "Dark Mode"
                        onClick: () =>
                        {
                            doc.darkMode = ! doc.darkMode;
                        }
                    }

                    MenuItem {
                        text: "Toggle Fullscreen"
                        onClick: () =>
                        {
                            if (documentRoot.fullscreenItem)
                            {
                                documentRoot.fullscreenItem = null;
                            }
                            else
                            {
                                documentRoot.fullscreenItem = documentRoot;
                            }
                        }
                    }

                    MenuItem {
                        text: "Settings..."
                        onClick: () =>
                        {
                            const dlg = doc.settingsDialogT();
                            dlg.show();
                        }
                    }

                    MenuItem {
                        text: "Log Out"
                        onClick: () =>
                        {
                            window.fetch("/logout")
                            .then(() => { window.location.reload(); })
                            .catch(err => { });
                        }
                    }

                }
            }

            Button {
                width: parent.width
                height: width
                flat: true
                icon: "fs-folder"
                onClick: () =>
                {
                    panesModel.insert(panesModel.size, path);
                }
            }

            Box { fillHeight: true }
            
            Repeater {
                model: grid.items.length

                delegate: template Button {
                    width: parent.width
                    height: width
                    flat: true
                    checked: grid.items[modelData.index].objectId === grid.maximizedItem
                    icon: grid.items[modelData.index].windowIcon
                    //text: low.escapeMarkup(grid.items[modelData.index].windowTitle)

                    onClick: () =>
                    {
                        grid.maximizedItem = grid.items[modelData.index].objectId;
                    }
                }
            }
        }


        Box {
            fillWidth: true
            fillHeight: true

            GridLayout {
                id: grid

                property maximizedItem: null

                fillWidth: true
                fillHeight: true

                layout: bbox.width > bbox.height ? "row" : "column"

                onMaximizedItemChanged: () =>
                {
                    wait(100).then(() => { update(); });
                }

                Repeater {
                    model: panesModel

                    delegate: template FilesBox {
                        visible: ! grid.maximizedItem || grid.maximizedItem === objectId

                        maximized: grid.maximizedItem === objectId
                        fillWidth: true
                        fillHeight: true

                        fs: remoteFs
                        path: modelData.value

                        onToggleMaximized: () =>
                        {
                            if (grid.maximizedItem)
                            {
                                grid.maximizedItem = null;
                            }
                            else
                            {
                                grid.maximizedItem = objectId;
                            }
                            grid.update();
                        }

                        onNewPane: (path) =>
                        {
                            panesModel.insert(panesModel.size, path);
                        }

                        onClosePane: () =>
                        {
                            panesModel.remove(modelData.index);
                        }

                        onFilesOpen: (files, idx) =>
                        {
                            if (mediaModel.size === 0)
                            {
                                mediaModel.insert(mediaModel.size, { files: files, index: idx });
                            }
                            else
                            {
                                mediaModel.replace(mediaModel.size - 1, { files: files, index: idx });
                            }
                        }

                        onTakeFiles: (files) =>
                        {
                            filesBag = files;
                        }
                    }
                }

                Repeater {
                    model: mediaModel

                    delegate: template FileViewer {
                        property files: modelData.value.files

                        visible: ! grid.maximizedItem || grid.maximizedItem === objectId

                        maximized: grid.maximizedItem === objectId
                        fillWidth: true
                        fillHeight: true

                        current: 0

                        onToggleMaximized: () =>
                        {
                            if (grid.maximizedItem)
                            {
                                grid.maximizedItem = null;
                            }
                            else
                            {
                                grid.maximizedItem = objectId;
                            }
                            grid.update();
                        }

                        onFilesChanged: () =>
                        {
                            if (grid.maximizedItem)
                            {
                                grid.maximizedItem = objectId;
                            }
                            console.log("SET FILES: " + JSON.stringify(files));
                            console.log("Index: " + modelData.value.index);
                            model.reset(files);
                            current = modelData.value.index;
                        }

                        onCurrentChanged: () =>
                        {
                            if (current === -1)
                            {
                                if (grid.maximizedItem === objectId)
                                {
                                    grid.maximizedItem = null;
                                }
                                mediaModel.remove(modelData.index);
                            }
                        }
                    }
                }
            }//GridLayout

            /*
            Box {
                visible: grid.items.length > 1 && grid.maximizedItem !== null
                fillWidth: true
                height: theme.itemHeightSmall
                color: theme.secondaryBackgroundColor

                layout: "row"

                Repeater {
                    model: grid.items.length

                    delegate: template Button {
                        fillWidth: true
                        fillHeight: true
                        flat: true
                        checked: grid.items[modelData.index].objectId === grid.maximizedItem
                        icon: grid.items[modelData.index].windowIcon
                        text: low.escapeMarkup(grid.items[modelData.index].windowTitle)

                        onClick: () =>
                        {
                            grid.maximizedItem = grid.items[modelData.index].objectId;
                        }
                    }
                }
            }
            */

        }

    }

    Placeholder {
        visible: ! doc.loggedIn

        fillWidth: true
        height: documentRoot.windowHeight

        text: "Pilvini Secure Cloud Drive"
    }

    property settingsDialogT: template SettingsDialog { }

}