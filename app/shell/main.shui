require "shellfish/low" as low;
require "shellfish/ui";
require "./FilesBox.shui";
require "./FileViewer.shui";
require "./GridLayout.shui";
require "./SettingsDialog.shui";
require "./TimeLabel.shui";
require "./youtubefs.js";
require "/icons/comm-icons.css";
require "/icons/fs-icons.css";
require "/icons/media-icons.css";
require "/icons/ui-icons.css";

Document {
    id: doc

    property loggedIn: false
    property filesBag: []
    property filesBagSource: null

    property darkMode: true //systemDarkMode
    property darkTheme: DarkTheme { contentBackgroundColor: "black" }
    property lightTheme: Theme { }
    theme: darkMode ? darkTheme : lightTheme

    color: theme.primaryBackgroundColor

    onContextMenu: ev => { ev.accepted = true; }

    onInitialization: () =>
    {
        remoteFs.list("/")
        .then(f =>
        {
            loggedIn = true;
        })
        .catch(err =>
        {
            alert("Login Failed.");
        });
    }

    onKeyDown: ev =>
    {
        // dump debug information
        if (ev.key === "d" && ev.ctrlKey)
        {
            console.log("Objects Dump:");
            console.log(core.dumpStatus());
            ev.accepted = true;
        }
    }

    DavFS {
        id: remoteFs
    }

    YouTubeFS {
        id: youTubeFs
    }

    OfflineFS {
        id: offlineFs
        volume: "offline"
    }

    ListModel {
        id: windowsModel

        data: [{
            component: filesBoxT, //__dirname + "/FilesBox.shui",
            properties: {
                fs: remoteFs,
                path: "/"
            }
        }]
    }

    ListModel {
        id: panesModel

        data: ["/"]
    }

    Box {
        visible: doc.loggedIn

        fillWidth: true
        height: documentRoot.windowHeight
        color: theme.contentBackgroundColor

        Box {
            fillWidth: true
            height: theme.itemHeightSmall / 2
            layout: "center"

            TimeLabel {
                color: theme.secondaryColor
                fontSize: parent.bboxHeight * 0.9
            }
        }

        Box {
            fillWidth: true
            fillHeight: true
            marginLeft: toolbar.orientation === "vertical" ? toolbar.bboxWidth : 0
            marginBottom: toolbar.orientation === "horizontal" ? toolbar.bboxHeight : 0

            GridLayout {
                id: grid

                property maximizedItem: null
                property fileViewers: []

                fillWidth: true
                fillHeight: true

                layout: bbox.width > bbox.height ? "row" : "column"

                Repeater {
                    model: windowsModel

                    delegate: template Loader {
                        visible: ! grid.maximizedItem || grid.maximizedItem === objectId

                        property sortIndex: objectId

                        fillWidth: true
                        fillHeight: true

                        sourceTemplate: modelData.value.component

                        onItemChanged: () =>
                        {
                            if (item)
                            {
                                for (let key in modelData.value.properties)
                                {
                                    item[key] = modelData.value.properties[key];
                                }

                                item.onToggleMaximized = () =>
                                {
                                    if (grid.maximizedItem)
                                    {
                                        grid.maximizedItem = null;
                                    }
                                    else
                                    {
                                        grid.maximizedItem = objectId;
                                    }
                                    grid.update();
                                };

                                item.onSwapPanes = direction =>
                                {
                                    grid.swap(self, direction);
                                };

                                item.onClosePane = () =>
                                {
                                    if (grid.maximizedItem === objectId)
                                    {
                                        grid.maximizedItem = null;
                                    }

                                    windowsModel.remove(modelData.index);
                                    dumpRecycleBin();

                                    grid.update();
                                };

                                grid.get().onMaximizedItemChanged = safeCallback(() =>
                                {
                                    item.maximized = grid.maximizedItem === objectId;
                                });

                                grid.maximizedItem = objectId;
                                grid.update();
                            }
                        }
                    }
                }

            }//GridLayout

            /*
            Box {
                visible: grid.items.length > 1 && grid.maximizedItem === null
                fillWidth: true
                height: theme.itemHeightSmall
                color: theme.contentBackgroundColor

                layout: "center-row"

                Button {
                    flat: true
                    fillHeight: true
                    checked: grid.columns === 1
                    text: "1"
                    onClick: () => { grid.columns = 1; }
                }

                Button {
                    flat: true
                    fillHeight: true
                    checked: grid.columns === 2
                    text: "2"
                    onClick: () => { grid.columns = 2; }
                }

                Button {
                    flat: true
                    fillHeight: true
                    checked: grid.columns === 3
                    text: "3"
                    onClick: () => { grid.columns = 3; }
                }

            }
            */

        }

        MouseBox {
            id: toolbar

            property orientation: documentRoot.windowWidth > documentRoot.windowHeight ? "vertical"
                                                                                       : "horizontal"
           
            //opacity: containsMouse ? 1.0 : 0.0
            opacity: 0.6

            position: "free"
            origin: orientation === "horizontal" ? "bottom-left" : "top-left"
            fillWidth: orientation === "horizontal"
            fillHeight: orientation === "vertical"
            width: fillWidth ? -1 : theme.itemHeightMedium
            height: fillHeight ? -1 : theme.itemHeightMedium

            layout: orientation === "horizontal" ? "row" : "column"

            Button {
                width: height
                height: theme.itemHeightMedium
                flat: true
                icon: "ui-menu"

                onClick: (ev) =>
                {
                    ev.accepted = true;
                    const menu = menuT();
                    menu.popup(self);
                }

                property menuT: template Menu {

                    MenuItem {
                        icon: "fs-folder"
                        text: "File Browser"

                        onClick: () =>
                        {
                            windowsModel.insert(windowsModel.size, {
                                component: filesBoxT,
                                properties: {
                                    fs: remoteFs,
                                    path: "/"
                                }
                            });
                        }
                    }

                    MenuItem {
                        icon: "media-movie"
                        text: "YouTube Browser"

                        onClick: () =>
                        {
                            windowsModel.insert(windowsModel.size, {
                                component: filesBoxT,
                                properties: {
                                    fs: youTubeFs,
                                    path: "/",
                                    searchBox: true
                                }
                            });
                        }
                    }

                    MenuSeparator { }

                    MenuItem {
                        text: doc.darkMode ? "Bright Mode"
                                           : "Dark Mode"
                        onClick: () =>
                        {
                            doc.darkMode = ! doc.darkMode;
                        }
                    }

                    MenuItem {
                        text: "Settings..."
                        onClick: () =>
                        {
                            const dlg = doc.settingsDialogT();
                            dlg.show();
                        }
                    }

                    MenuItem {
                        text: "About..."
                    }

                    MenuSeparator { }

                    MenuItem {
                        text: "Log Out"
                        onClick: () =>
                        {
                            window.fetch("/logout")
                            .then(() => { window.location.reload(); })
                            .catch(err => { });
                        }
                    }

                }
            }

            Box {
                visible: grid.items.length <= 1
                fillWidth: toolbar.orientation === "horizontal"
                fillHeight: toolbar.orientation === "vertical"
            }

            Box {
                visible: grid.items.length > 1

                fillWidth: true
                fillHeight: true
                layout: toolbar.orientation === "horizontal" ? "row" : "column"

                Repeater {
                    model: grid.items.length

                    delegate: template Button {
                        fillWidth: true
                        fillHeight: true
                        flat: true
                        checked: modelData.index < grid.items.length && grid.items[modelData.index].objectId === grid.maximizedItem
                        icon: modelData.index < grid.items.length && grid.items[modelData.index].item.windowIcon
                        //text: low.escapeMarkup(grid.items[modelData.index].windowTitle)

                        onClick: () =>
                        {
                            if (checked)
                            {
                                grid.maximizedItem = null;
                            }
                            else
                            {
                                grid.maximizedItem = grid.items[modelData.index].objectId;
                            }
                            grid.update();
                        }
                    }
                }
            }

            Button {
                width: height
                height: theme.itemHeightMedium
                flat: true
                icon: documentRoot.fullscreenItem ? "ui-fullscreen_exit"
                                                  : "ui-fullscreen"

                onClick: () =>
                {
                    if (documentRoot.fullscreenItem)
                    {
                        documentRoot.fullscreenItem = null;
                    }
                    else
                    {
                        documentRoot.fullscreenItem = documentRoot;
                    }
                }
            }

        }


    }

    Placeholder {
        visible: ! doc.loggedIn

        fillWidth: true
        height: documentRoot.windowHeight

        text: "Pilvini Secure Cloud Drive"
    }

    property settingsDialogT: template SettingsDialog { }

    property filesBoxT: template FilesBox {

        onFilesOpen: (files, idx, asNew) =>
        {
            if (grid.fileViewers.length === 0 || asNew)
            {
                windowsModel.insert(windowsModel.size, {
                    component: mediaViewerT,
                    properties: {
                        fs: fs,
                        files: files,
                        current: idx
                    }
                });
            }
            else
            {
                const viewer = grid.fileViewers[grid.fileViewers.length - 1];
                viewer.fs = fs;
                viewer.files = files;
                viewer.current = idx;

                if (grid.maximizedItem)
                {
                    grid.maximizedItem = viewer.parent.objectId;
                }
            }

        }

        onTakeFiles: (files) =>
        {
            filesBag = files;
        }
    }

    property mediaViewerT: template FileViewer {

        onInitialization: () =>
        {
            grid.fileViewers.push(self);
        }

        onDestruction: () =>
        {
            grid.fileViewers = grid.fileViewers.filter(obj => obj !== self);
        }

    }

}