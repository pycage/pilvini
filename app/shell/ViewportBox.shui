require "shellfish/ui";

Box {
    id: box

    // original width of the displayed target item
    property originalWidth: 100
    // original height of the displayed target item 
    property originalHeight: 100

    property minScale: Math.min(Math.max(1, bbox.width) / Math.max(1, originalWidth),
                                Math.max(1, bbox.height) / Math.max(1, originalHeight))
    property maxScale: minScale * 32;
    property scale: 1.0

    // the viewport position in target coordinates
    property viewX: 0
    property viewY: 0

    property adapter: Object {
        property bbox: box.bbox
        property bboxWidth: box.bboxWidth
        property bboxHeight: box.bboxHeight

        property contentX: 0
        property contentY: 0
        property contentWidth: box.originalWidth * box.scale
        property contentHeight: box.originalHeight * box.scale

        property _contentX: box.viewX * box.scale
        property _contentY: box.viewY * box.scale

        property updatePending: false

        function updatePos()
        {
            if (contentX !== _contentX)
            {
                contentX = _contentX;
            }
            if (contentY !== _contentY)
            {
                contentY = _contentY;
            }
            updatePending = false;
        }

        onContentXChanged: () =>
        {
            const v = Math.max(0, Math.min(contentWidth - bboxWidth, contentX));
            box.confineViewport(v / scale, box.viewY);
            if (contentX !== v)
            {
                contentX = v;
            }
        }

        onContentYChanged: () =>
        {
            const v = Math.max(0, Math.min(contentHeight - bboxHeight, contentY));
            box.confineViewport(box.viewX, v / scale);
            if (contentY !== v)
            {
                contentY = v;
            }
        }

        on_contentXChanged: () =>
        {
            if (! updatePending)
            {
                updatePending = true;
                wait(0).then(safeCallback(() =>
                {
                    updatePos();
                    updatePending = false;
                }));
            }
        }

        on_contentYChanged: () =>
        {
            if (! updatePending)
            {
                updatePending = true;
                wait(0).then(safeCallback(() =>
                {
                    updatePos();
                    updatePending = false;
                }));
            }
        }
    }

    Object {
        id: priv

        property prevScale: 1.0
        property scaleAnchorX: 0.5
        property scaleAnchorY: 0.5
    }

    function confineViewport(vx, vy)
    {
        if (bboxWidth * bboxHeight === 0)
        {
            return;
        }

        const viewWidth = bboxWidth / scale;
        const viewHeight = bboxHeight / scale;

        if (viewWidth < originalWidth)
        {
            if (vx < 0)
            {
                vx = 0;
            }
            if (vx + viewWidth > originalWidth)
            {
                vx = originalWidth - viewWidth;
            }
        }
        else
        {
            vx = (originalWidth - viewWidth) / 2;
        }

        if (viewHeight < originalHeight)
        {
            if (vy < 0)
            {
                vy = 0;
            }
            if (vy + viewHeight > originalHeight)
            {
                vy = originalHeight - viewHeight;
            }
        }
        else
        {
            vy = (originalHeight - viewHeight) / 2;
        }

        viewX = vx;
        viewY = vy;
    }

    function scaleToFit()
    {
        if (originalWidth * originalHeight > 0 && bboxWidth * bboxHeight > 0)
        {
            const factor1 = bboxWidth / originalWidth;
            const factor2 = bboxHeight / originalHeight;
            scale = Math.max(minScale, Math.min(maxScale, Math.min(factor1, factor2)));
            confineViewport(0, 0);
        }
    }

    function setScale(newScale, anchorX, anchorY)
    {
        priv.scaleAnchorX = anchorX;
        priv.scaleAnchorY = anchorY;
        scale = Math.max(minScale, Math.min(maxScale, newScale));
    }

    onScaleChanged: () =>
    {
        if (! scale)
        {
            return;
        }

        // convert anchors to viewport coordinates
        const anchorXBefore = viewX + priv.scaleAnchorX * bboxWidth / priv.prevScale;
        const anchorYBefore = viewY + priv.scaleAnchorY * bboxHeight / priv.prevScale;

        const anchorXAfter = viewX + priv.scaleAnchorX * bboxWidth / scale;
        const anchorYAfter = viewY + priv.scaleAnchorY * bboxHeight / scale;
      
        const dx = anchorXAfter - anchorXBefore;
        const dy = anchorYAfter - anchorYBefore;

        confineViewport(viewX - dx, viewY - dy);

        priv.prevScale = scale;
    }

    onBboxChanged: () =>
    {
        const minScale = Math.min(Math.max(1, bboxWidth) / Math.max(1, originalWidth),
                         Math.max(1, bboxHeight) / Math.max(1, originalHeight));
        const maxScale = minScale * 32.0;
        scale = Math.max(minScale, Math.min(maxScale, scale));
        confineViewport(viewX, viewY);
    }

 
}