require "shellfish/server";
require "./diskinfo.js" as diskinfo;
require "./epgservice.js";
require "./proxysession.js";
require "./virtualfs.js";
require "./rarfs.js";
require "./videoeditor.js";
require "./viewsdavsession.js";
require "./zipfs.js";

HTTPServer {

    enabled: false
    certificate: __dirname + "/../cert/server.cert"
    key: __dirname + "/../cert/server.key"

    host: registryFile.read("/server/address")
    port: registryFile.read("/server/port")
    secure: registryFile.read("/server/use_ssl")
    enabled: registryFile.ready

    function log(domain, level, message)
    {
        if (domain === "HTTP" ||
            domain === "TokenAuth" ||
            domain === "HTTPAuth" ||
            domain === "HTTPServer" ||
            domain === "Config" ||
            domain === "WWW" ||
            domain === "RPC" ||
            level !== "info")
        {
            const now = new Date();
            console.log(now.toLocaleString() + " [" + domain + "] " + message);
        }
    }

    LocalFS {
        id: localFs
    }
    
    RegistryFile {
        id: registryFile

        filesystem: localFs
        path: __dirname + "/../config.db"

        onReadyChanged: async () =>
        {
            if (ready)
            {
                const contents = await list("/");
                if (! contents.includes("server"))
                {
                    console.log("add server");
                    mkdir("/server");
                    create("/server/address", "0.0.0.0");
                    create("/server/port", 8000);
                    create("/server/use_ssl", false);
                    create("/server/certificate", "");
                }
                if (! contents.includes("users"))
                {
                    mkdir("/users");
                    mkdir("/users/admin");
                    create("/users/admin/name", "admin");
                    create("/users/admin/hash", "b80648545a30e0999892b517127c0e17");
                    create("/users/admin/root", "/");
                }
            }
        }
    }

    EpgService {
        id: epgService
    }

    VideoEditor {
        id: videoEditor
    }

    TokenAuth {
        id: auth
    }

    HTTPAuth {
        id: httpAuth

        async function updateUsers()
        {
            console.log("UPDATE USERS DB");
            const m = { };
            const contents = await registryFile.list("/users");
            for (let i = 0; i < contents.length; ++i)
            {
                const name = contents[i];
                const hash = await registryFile.read("/users/" + name + "/hash", "");
                if (hash !== "")
                {
                    m[name] = hash;
                }
            }
            console.log(JSON.stringify(m));
            users = m;
        }

        registryFile.onReadyChanged: () =>
        {
            if (registryFile.ready)
            {
                updateUsers();
            }
        }

        registryFile.onChangeValue: path =>
        {
            if (path.startsWith("/users"))
            {
                updateUsers();
            }
        }
    }

    VirtualFS {
        id: vfs

        filesystem: localFs

        RarFS {
            property vfsMimeTypes: ["application/x-rar-compressed"]
        }

        ZipFS {
            property vfsMimeTypes: ["application/zip"]
        }
    }

    // Who am I?
    HTTPRoute {
        authentication: auth
        when: pathPrefix("/whoami")

        delegate: template HTTPSession {
            onRequest: req =>
            {
                const data = {
                    name: req.user,
                    apps: [
                        { name: "Files", icon: "fs-folder", source: "FilesApp.shui" },
                        { name: "EPG", icon: "fs-file-video", source: "EpgApp.shui" }
                    ]
                };
                response(200, "OK")
                .body(JSON.stringify(data))
                .send();
            }
        }
    }

    // Guest login with code
    HTTPRoute {
        when: req => req.url.path === "/login" && req.url.parameters.code

        delegate: template HTTPSession {
            onRequest: req =>
            {
                auth.awaitToken(req.url.parameters.code, "guest", req.sourceAddress)
                .then(token =>
                {
                    console.log("Sending Auth Code " + token);
                    response(200, "OK")
                    .header("Set-Cookie", "AuthToken=" + token + "; Max-Age=43200")
                    .send();
                })
                .catch(err =>
                {
                    response(401, "Unauthorized")
                    .send();
                });

                console.log("SOURCE: " + req.sourceAddress);
                if (req.sourceAddress.startsWith("192.168.") || req.sourceAddress === "127.0.0.1")
                {
                    auth.authorizeCode(req.url.parameters.code);
                }
            }
        }
    }

    // Login
    HTTPRoute {
        authentication: httpAuth
        when: pathPrefix("/login")

        delegate: template HTTPSession {
            onRequest: req =>
            {
                console.log("Login As: " + req.user);
                const authToken = auth.issueTokenFor(req.user, req.sourceAddress);
                response(200, "OK")
                .header("Set-Cookie", "AuthToken=" + authToken + "; Max-Age=43200")
                .send();
            }
        }
    }

    // Logout
    HTTPRoute {
        authentication: auth
        when: pathPrefix("/logout")

        delegate: template HTTPSession {
            onRequest: req =>
            {
                const token = req.cookies.get("AuthToken");
                auth.revokeToken(token);

                response(401, "Unauthorized")
                .send();
            }
        }
    }

    // Accept login request
    HTTPRoute {
        authentication: auth
        when: pathPrefix("/acceptLogin?")

        delegate: template HTTPSession {
            onRequest: req =>
            {
                auth.authorizeCode(req.url.parameters.code);
                response(200, "OK")
                .send();
            }
        }
    }

    HTTPRoute {
        authentication: auth

        when: req => req.url.path === "/::rpc"
        generateSessionId: req => req.headers.get("x-shellfish-rpc-session") || core.generateUid()

        delegate: template RpcSession {

            onInitialization: () =>
            {
                registerMethod("diskInfo", async () =>
                {
                    const path = await registryFile.read("/users/" + user + "/root", "/");
                    const di = new diskinfo.DiskInfo();
                    di.path = path;
                    return proxyObject(di);
                });

                /*
                registerMethod("exec", (cmd, opts) =>
                {
                    const handle = new pty.Pty(cmd, opts);
                    return proxyObject(handle);
                });
                */

                registerMethod("registry", () =>
                {
                    return proxyObject(registryFile, ["read", "write", "list", "info"]);
                });

                registerMethod("epgService", async () =>
                {
                    return proxyObject(epgService);
                });

                registerMethod("videoEditor", async () =>
                {
                    const root = await registryFile.read("/users/" + user + "/root", "/");
                    console.log("USER: " + user + " -> " + root);
                    const obj = {
                        cutVideo: (path, directions, cb1, cb2) =>
                        {
                            videoEditor.cutVideo(root + path, directions, cb1, cb2);
                        }
                    };
                    return proxyObject(obj);
                });
            }

        }
    }

    // Password hash
    HTTPRoute {
        authentication: auth
        when: pathPrefix("/::setPassword")

        delegate: template HTTPSession {
            onRequest: req =>
            {
                const user = req.url.parameters.user;
                const pw = req.url.parameters.password;
                const hash = httpAuth.passwordHash(user, "", pw);

                registryFile.write("/users/" + user + "/hash", hash);

                response(200, "OK")
                .send();
            }
        }
    }

    // Shellfish resources accessible without authentication
    HTTPRoute {

        property WHITELIST: [
            "/shellfish.pkg",
            "/shellfish-ui.pkg",
            "/icons/comm-icons.css",
            "/icons/fs-icons.css",
            "/icons/media-icons.css",
            "/icons/ui-icons.css",
            "/require.js"
        ]

        when: req =>
        {
            return WHITELIST.indexOf(req.url.path) !== -1;
        }

        delegate: template WebSession {
            filesystem: localFs
            //root: __dirname + "/../shellfish"
            root: __dirname + "/../../shellfish/dist"
        }

    }//HTTPRoute

    // Proxy Access
    HTTPRoute {
        authentication: auth
        when: pathPrefix("/::proxy")

        delegate: template ProxySession {

        }
    }

    // Applications
    HTTPRoute {
        when: pathPrefix("/::")

        delegate: template WebSession {
            urlMapper: url => { return "/" + url.substr(3); }
            filesystem: localFs
            indexFile: "index.html"
            root: __dirname + "/../app"

            onResponseReady: r => { r.enableCrossOriginIsolation(); }
        }

    }

    // WebDAV access
    HTTPRoute {
        authentication: auth

        delegate: template ViewsDAVSession {
            filesystem: vfs
            root: user ? registryFile.readSync("/users/" + user + "/root", "/")
                       : "/"
        }

    }

}
