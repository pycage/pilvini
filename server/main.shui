require "shellfish/server";
require "./proxysession.js";
require "./virtualfs.js";
require "./rarfs.js";
require "./viewsdavsession.js";
require "./zipfs.js";
require "./ConfigSession.shui";

HTTPServer {

    enabled: configStore.ready
    secure: configStore.server.use_ssl
    certificate: __dirname + "/../cert/server.cert"
    key: __dirname + "/../cert/server.key"
    port: configStore.server.port

    function log(domain, level, message)
    {
        if (domain === "HTTP" ||
            domain === "TokenAuth" ||
            domain === "HTTPAuth" ||
            domain === "HTTPServer" ||
            domain === "Config" ||
            domain === "WWW" ||
            level !== "info")
        {
            const now = new Date();
            console.log(now.toLocaleString() + " [" + domain + "] " + message);
        }
    }

    LocalFS {
        id: localFs
    }
    
    FileStorage {
        id: configStore

        filesystem: localFs
        path: __dirname + "/../config.json"

        property server: ({
            address: "0.0.0.0",
            port: 8000,
            use_ssl: false,
            certificate: ""
        })
        property users: [
            {
                "name": "admin",
                "hash": "b80648545a30e0999892b517127c0e17",
                "root": "/"
            }
        ]
    }

    TokenAuth {
        id: auth
    }

    HTTPAuth {
        id: httpAuth

        users: (() =>
        {
            const m = { };
            configStore.users.forEach(entry => m[entry.name] = entry.hash);
            return m;
        })()
    }

    VirtualFS {
        id: vfs

        filesystem: localFs

        RarFS {
            property vfsMimeTypes: ["application/x-rar-compressed"]
        }

        ZipFS {
            property vfsMimeTypes: ["application/zip"]
        }
    }

    // Who am I?
    HTTPRoute {
        authentication: auth

        when: req => { return req.url === "/whoami"; }

        delegate: template HTTPSession {
            onRequest: req =>
            {
                response(200, "OK")
                .body(req.user)
                .send();
            }
        }
    }

    // Login
    HTTPRoute {
        authentication: httpAuth

        when: req => { return req.url === "/login"; }

        delegate: template HTTPSession {
            onRequest: req =>
            {
                console.log("Login As: " + req.user);
                const authToken = auth.issueTokenFor(req.user, req.sourceAddress);
                response(200, "OK")
                //.cookie("AuthToken", authToken + "; Max-Age=86400")
                .header("Set-Cookie", "AuthToken=" + authToken + "; Max-Age=86400")
                .send();
            }
        }
    }

    // Guest login with code
    HTTPRoute {
        when: req => { return req.url.startsWith("/login?"); }

        delegate: template HTTPSession {
            onRequest: req =>
            {
                auth.awaitToken(req.url.parameters.code, "guest", req.sourceAddress)
                .then(token =>
                {
                    console.log("Sending Auth Code " + token);
                    response(200, "OK")
                    .header("Set-Cookie", "AuthToken=" + token + "; Max-Age=86400")
                    .send();
                })
                .catch(err =>
                {
                    response(401, "Unauthorized")
                    .send();
                });
            }
        }
    }

    // Logout
    HTTPRoute {
        authentication: auth

        when: req => { return req.url === "/logout"; }

        delegate: template HTTPSession {
            onRequest: req =>
            {
                const token = req.cookies.get("AuthToken");
                auth.revokeToken(token);

                response(401, "Unauthorized")
                .send();
            }
        }
    }

    // Accept login request
    HTTPRoute {
        authentication: auth

        when: req => { return req.url.startsWith("/acceptLogin?"); }

        delegate: template HTTPSession {
            onRequest: req =>
            {
                auth.authorizeCode(req.url.parameters.code);
                response(200, "OK")
                .send();
            }
        }
    }

    // Server configuration
    HTTPRoute {
        authentication: auth

        when: req => { return req.url.startsWith("/::config/"); }

        delegate: template ConfigSession {
            target: configStore
            authentication: auth  // for passwordHash
        }
    }

    // Shellfish resources accessible without authentication
    HTTPRoute {

        property WHITELIST: [
            "/shellfish.pkg",
            "/shellfish-ui.pkg",
            "/icons/comm-icons.css",
            "/icons/fs-icons.css",
            "/icons/media-icons.css",
            "/icons/ui-icons.css",
            "/require.js"
        ]

        when: req =>
        {
	        //console.log(__dirname + ", " + "/shellfish" + ", " + req.url);
            return WHITELIST.indexOf(req.url) !== -1;
        }

        delegate: template WebSession {
            filesystem: localFs
            //root: __dirname + "/../shellfish"
            root: __dirname + "/../../shellfish/dist"
        }

    }//HTTPRoute

    // Proxy Access
    HTTPRoute {
        authentication: auth

        when: req => { return req.url.startsWith("/::proxy"); }

        delegate: template ProxySession {

        }
    }

    // Applications
    HTTPRoute {
        when: req => { return req.url.startsWith("/::"); }

        delegate: template WebSession {
            urlMapper: url => { return "/" + url.substr(3); }
            filesystem: localFs
            indexFile: "index.html"
            root: __dirname + "/../app"

            onResponseReady: r => { r.enableCrossOriginIsolation(); }
        }

    }

    // WebDAV access
    HTTPRoute {
        authentication: auth

        delegate: template ViewsDAVSession {
            filesystem: vfs
            //root: configStore.server.root
            root: user ? (configStore.users.find(item => item.name === user)?.root || "/") : "/"
        }

    }

}
