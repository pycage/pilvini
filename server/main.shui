require "shellfish/server";
require "./proxysession.js";
require "./virtualfs.js";
require "./rarfs.js";
require "./registryfile.js";
require "./registrymonitor.js";
require "./viewsdavsession.js";
require "./zipfs.js";
require "./ConfigSession.shui";

HTTPServer {

    enabled: false
    certificate: __dirname + "/../cert/server.cert"
    key: __dirname + "/../cert/server.key"

    function log(domain, level, message)
    {
        if (domain === "HTTP" ||
            domain === "TokenAuth" ||
            domain === "HTTPAuth" ||
            domain === "HTTPServer" ||
            domain === "Config" ||
            domain === "WWW" ||
            level !== "info")
        {
            const now = new Date();
            console.log(now.toLocaleString() + " [" + domain + "] " + message);
        }
    }

    registryFile.onReadyChanged: () =>
    {
        if (registryFile.ready)
        {
            wait(100).then(() =>
            {
                host = registryFile.read("/server/address");
                port = registryFile.read("/server/port");
                secure = registryFile.read("/server/use_ssl");
                enabled = true;
            });
        }
    }

    LocalFS {
        id: localFs
    }
    
    RegistryFile {
        id: registryFile

        filesystem: localFs
        path: __dirname + "/../config.db"

        onReadyChanged: () =>
        {
            if (ready)
            {
                if (! list("/").includes("server"))
                {
                    console.log("add server");
                    mkdir("/server");
                    create("/server/address", "0.0.0.0");
                    create("/server/port", 8000);
                    create("/server/use_ssl", false);
                    create("/server/certificate", "");
                }
                if (! list("/").includes("users"))
                {
                    mkdir("/users");
                    mkdir("/users/admin");
                    create("/users/admin/name", "admin");
                    create("/users/admin/hash", "b80648545a30e0999892b517127c0e17");
                    create("/users/admin/root", "/");
                }
            }
        }
    }

    RegistryMonitor {
        id: registryMonitor

        registry: registryFile
        mapping: ({
            "/server/address": "serverAddress",
            "/server/port": "serverPort",
            "/server/use_ssl": "serverUseSsl"
        })

        property serverAddress: ""
        property serverPort: 8000
        property serverUseSsl: false
    }

    TokenAuth {
        id: auth
    }

    HTTPAuth {
        id: httpAuth

        function updateUsers()
        {
            console.log("UPDATE USERS DB");
            const m = { };
            registryFile.list("/users").forEach(name =>
            {
                const hash = registryFile.read("/users/" + name + "/hash", "");
                if (hash !== "")
                {
                    m[name] = hash;
                }
            });
            console.log(JSON.stringify(m));
            users = m;
        }

        registryFile.onReadyChanged: () =>
        {
            if (registryFile.ready)
            {
                updateUsers();
            }
        }

        registryFile.onChangeValue: path =>
        {
            if (path.startsWith("/users"))
            {
                updateUsers();
            }
        }
    }

    VirtualFS {
        id: vfs

        filesystem: localFs

        RarFS {
            property vfsMimeTypes: ["application/x-rar-compressed"]
        }

        ZipFS {
            property vfsMimeTypes: ["application/zip"]
        }
    }

    // Who am I?
    HTTPRoute {
        authentication: auth
        prefix: "/whoami"

        delegate: template HTTPSession {
            onRequest: req =>
            {
                response(200, "OK")
                .body(req.user)
                .send();
            }
        }
    }

    // Guest login with code
    HTTPRoute {
        prefix: "/login?"

        delegate: template HTTPSession {
            onRequest: req =>
            {
                auth.awaitToken(req.url.parameters.code, "guest", req.sourceAddress)
                .then(token =>
                {
                    console.log("Sending Auth Code " + token);
                    response(200, "OK")
                    .header("Set-Cookie", "AuthToken=" + token + "; Max-Age=43200")
                    .send();
                })
                .catch(err =>
                {
                    response(401, "Unauthorized")
                    .send();
                });
            }
        }
    }

    // Login
    HTTPRoute {
        authentication: httpAuth
        prefix: "/login"

        delegate: template HTTPSession {
            onRequest: req =>
            {
                console.log("Login As: " + req.user);
                const authToken = auth.issueTokenFor(req.user, req.sourceAddress);
                response(200, "OK")
                .header("Set-Cookie", "AuthToken=" + authToken + "; Max-Age=43200")
                .send();
            }
        }
    }

    // Logout
    HTTPRoute {
        authentication: auth
        prefix: "/logout"

        delegate: template HTTPSession {
            onRequest: req =>
            {
                const token = req.cookies.get("AuthToken");
                auth.revokeToken(token);

                response(401, "Unauthorized")
                .send();
            }
        }
    }

    // Accept login request
    HTTPRoute {
        authentication: auth
        prefix: "/acceptLogin?"

        delegate: template HTTPSession {
            onRequest: req =>
            {
                auth.authorizeCode(req.url.parameters.code);
                response(200, "OK")
                .send();
            }
        }
    }

    // Server configuration
    HTTPRoute {
        authentication: auth
        prefix: "/::config"

        delegate: template ConfigSession {
            registry: registryFile
        }
    }

    // Password hash
    HTTPRoute {
        authentication: auth
        prefix: "/::setPassword"

        delegate: template HTTPSession {
            onRequest: req =>
            {
                const user = req.url.parameters.user;
                const pw = req.url.parameters.password;
                const hash = httpAuth.passwordHash(user, "", pw);

                registryFile.write("/users/" + user + "/hash", hash);

                response(200, "OK")
                .send();
            }
        }
    }

    // Shellfish resources accessible without authentication
    HTTPRoute {

        property WHITELIST: [
            "/shellfish.pkg",
            "/shellfish-ui.pkg",
            "/icons/comm-icons.css",
            "/icons/fs-icons.css",
            "/icons/media-icons.css",
            "/icons/ui-icons.css",
            "/require.js"
        ]

        when: req =>
        {
	        //console.log(__dirname + ", " + "/shellfish" + ", " + req.url.path);
            return WHITELIST.indexOf(req.url.path) !== -1;
        }

        delegate: template WebSession {
            filesystem: localFs
            //root: __dirname + "/../shellfish"
            root: __dirname + "/../../shellfish/dist"
        }

    }//HTTPRoute

    // Proxy Access
    HTTPRoute {
        authentication: auth
        prefix: "/::proxy"

        delegate: template ProxySession {

        }
    }

    // Applications
    HTTPRoute {
        prefix: "/::"

        delegate: template WebSession {
            urlMapper: url => { return "/" + url.substr(3); }
            filesystem: localFs
            indexFile: "index.html"
            root: __dirname + "/../app"

            onResponseReady: r => { r.enableCrossOriginIsolation(); }
        }

    }

    // WebDAV access
    HTTPRoute {
        authentication: auth

        delegate: template ViewsDAVSession {
            filesystem: vfs
            root: user ? registryFile.read("/users/" + user + "/root", "/")
                       : "/"
        }

    }

}
